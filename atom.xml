<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[第七章]]></title>
  <link href="http://kobe1941.github.io/atom.xml" rel="self"/>
  <link href="http://kobe1941.github.io/"/>
  <updated>2023-09-27T20:57:13+08:00</updated>
  <id>http://kobe1941.github.io/</id>
  <author>
    <name><![CDATA[第七章]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[《李光耀观天下》]]></title>
    <link href="http://kobe1941.github.io/blog/see-world-by-president-li.html"/>
    <updated>2023-09-27T20:37:39+08:00</updated>
    <id>http://kobe1941.github.io/blog/see-world-by-president-li</id>
    <content type="html"><![CDATA[<p>就新加坡而言，我们的成功股市取决于三大特性：确保这是个让人们生活与工作的最安全国家，平等对待每一个公民，以及确保每一代新加坡人能持续成功。</p>

<!--more-->

<p>中国</p>

<p>五千年来，中国人一直认为，只要中央政权是强大的，这个国家就安全。如果中央虚弱了，国家就会紊乱。一个强大的中央会带来一个和平繁荣的中国。每个中国人都这样认为，这是他们从根深蒂固的历史教训中吸取的基本原则。在短期内，人们不可能背离这一原则。这种心态比共产主义的历史要长，已存在数个世纪，甚至数千年了。</p>

<p>西方一些人希望看到中国实现西方传统的民主，这是不可能的事。美国人认为，如果不实现一人一票的选举制度，以及每隔数年更换总统和改选议会，就不可能称为一个成功的国家。这是他们对世界先入为主的看法。中国人从来没有这样的传统。中国是一个地域广阔、拥有13亿人口、人民具有不同文化和历史传统的国家。它将会走自己的道路。</p>

<p>即使这种事（政治改革）会发生，也不会出现一人一票的制度。将会出现的是一批领导人被另一批领导人所取代。这是源于文化和历史的原因，中国人相信，强大的中央政权能带来和平与繁荣。一人一票制度从未在中国存在过，也绝不会带来一个繁荣的中国。他们将不会尝试这种制度。</p>

<p>被剥夺公民权利的农村劳动力为数并不很多，而且没有被组织起来。他们渴望能加入城市的中产阶层，改善生活。而中产阶层却急于想进入社会的上层。在他们设法进入新阶层并稳固地位后，就有可能要求更多的透明度，要求在国家治理方面有更多的话语权，但是这可能是若干年后的事。总之，目前的制度需要逐渐演变，但还没有到崩溃的边缘。</p>

<p><img src="http://kobe1941.github.io/images/2023/09/2.jpg" alt="" /></p>

<p>我认为，他们不会对国家几乎所有方面放弃全面彻底的孔子。腐败、缺乏法制和治理制度可能会继续成为中国体制的特色，这些都是明显的弱点。</p>

<p>做事不太理会法律或治理制度，是根深蒂固的中国文化。</p>

<p>在中国，人大于制度。因此，你可以当国家主席，但是如果没有军队的支持，你这个国家主席就大不一样。但在新加坡、英国、欧洲或者美国，如果你是总统或者总理，军队领导人自动的接受你的命令，因为制度大于人。</p>

<p>中国将发展其制度和体制，但完全是中国式的。不管它们的改革发展成怎样，有一点不会改变：他们将维持一个强大的中央政权。</p>

<p><img src="http://kobe1941.github.io/images/2023/09/3.jpg" alt="" /></p>

<p><img src="http://kobe1941.github.io/images/2023/09/4.jpg" alt="" /></p>

<p>就中美而言，两国都有核武库，他们都不想在战场上对抗；再进一步说，不同于美苏间的关系，美国与热衷于信奉市场经济的中国质检的关系，目前不存在激烈的不可调和的意识形态冲突。中国需要与美国保持友好关系，确保继续获得其市场、投资、技术，以及获准进入其大学。美国更没有必要与中国长期为敌。</p>

<p>美中两国间会出现的最大危机是在台湾问题上。但是我认为，美国不会为了维护台湾的“独立”与中国交战，这得不偿失。你可以交战并赢得第一回合，但美国人是否准备打仗、打仗、再打仗？请记住，没有一位中国领导人，如果台湾在他执政期间失去，会继续掌权。因此，对中国人来说，这是一个非常严肃的课题。即使中国在第一轮打输了，也会返回来打第二轮、第三轮、第四轮，不断的打，直至胜利，这对美国来说不值得。</p>

<p>台湾与大陆的重新统一是时间的问题，这是任何国家无法阻挡的。经济将会解决这个问题，逐步和不可阻挡的经济整合将把这两个社会连接在一起。中国将认识到没有使用武力的必要。两岸不断发展的互相依赖关系将会使台湾无法实现“独立”。</p>

<p>问：在台湾当地的调查显示，支持“独立”的人比要统一的人更多。
答：（这种民调）是毫无意义的。如果你是一名台湾人，你是希望“独立”，还是保持现状，或者成为中国的一部分？台湾的未来能按你的想法确定吗？南部的台湾人绝对不希望与中国融合，他们将始终是这样。但是他们的观点能得到大家的赞同吗？台湾的前途不是根据台湾人民的意愿确定的，而是台湾与大陆力量对比的现实，以及美国是否打算进行干预来确定的。这不是以民意调查来决定的。</p>

<p>问：中国对朝鲜还有多少影响？
答：朝鲜能够生存，很大程度上依赖中国。他们处理经济的方式时而造成朝鲜人几乎处于饥饿状态，中国向他们提供了食品和救助。</p>

<p><img src="http://kobe1941.github.io/images/2023/09/5.jpg" alt="" /></p>

<p>问：我们有一天会给中国海军提供一个后勤中心或其他形式的基地吗？
答：我不能这么说。这在我有生之年不会发生。我认为，第一步将是为这两国的海军提供共后勤中心，而不是只为一国。千万不要在它们之间做选择。</p>

<p>问：您认为新加坡不在它们之间做选择的立场能保持多久？
答：我不好说。这取决于美国的经济情况和它们发挥影响力的能力等。</p>

<p>航天研究、全球定位系统不是经济增长的来源，但能确保他们的经济增长不受军事行动的损害。</p>

<p>中国面临的挑战是，要确保因财富差距引起的不满，不至于发展到无法控制的地步。</p>

<p>中国面临更为迫切的问题是如何处理那些低效的国有企业。在这方面，中国面对的是个人激励这个根本问题。</p>

<p>中国需要从出口导向经济，转变为如同美国的经济那样，以国内消费为导向。为了实现这一转变，你必须使中层和中下阶层在思维上产生变化。</p>

<p>穷人即使有了钱，其举止还会像穷人那样。因为你穷了那么长时间了，害怕还会变穷，就只想着积累更多的财富，有更多的储蓄。只有当你变得有信心了，相信经济繁荣将继续，意识到困守原有的生活方式是愚蠢的，才会开始花钱。他们要想使经济持续增长，必须进入这个阶段。他们没有太多的时间了，必须在10年至20年内完成这一转变。</p>

<p>然而，财富必须更加合理的分配。由于目前消费动力只存在于沿海省市，而不是出现在更大量的农村人口和内陆居民中，因此收入的差距是阻碍国内消费的一个因素。</p>

<p><img src="http://kobe1941.github.io/images/2023/09/6.jpg" alt="" /></p>

<p>我确信，国内消费最终会成为他们经济持续增长的唯一途径。为了实现这一目标，他们必须重新分配增长。因为一些内陆省份不具备消费力，你必须让经济增长惠及所有的人。</p>

<p>欧洲</p>

<p>欧元的根本问题是，如果财政尚未整合，就不可能实行货币一体化，尤其是当一个地区同时有德国与希腊这种消费和节俭习惯如此迥异的国家。当一群杂牌军尝试听命于同一个鼓手时，结果是什么？这就是欧元区面临的情况：有些国家迅速发展，其他国家挣扎跟上。</p>

<p>对欧洲：福利社会最坏的影响，不在于其僵化的或难以为继的本质，而是它削弱人们努力奋斗的动力。如果社会保障体系设计成不管一个人努力工作还是悠闲过活都能得到同样的好处，那他为什么还要努力？他根本没有向前走的推动力。</p>

<p>美国人自力更生的态度比较普遍，因为就算失业获得了援助，也有措施确保他们会积极甚至强迫去找工作。</p>

<p>在欧洲前方是苦日子。由于独特的历史情况，欧洲人选择了福利和劳工保护的发展道路。比起美国，欧洲人的选择造就了一个比较温和的社会，底层阶级比较少，成功者和失败者之间的差距也比较小。在一段时间内，许多欧洲人的生活仍将舒适，因为他们在年头好的时候积累了储备。但不管他们是否乐意，他们在战后为自己创造的舒适和受到百般呵护的世界，最终会被外部力量弄垮。届时，他们就得协商一个新的社会契约。</p>

<p>北欧国家福利支付行得通的原因：瑞典、挪威和丹麦人口少，这三个北欧国家的人口总和大约只有法意西三国总人口的十分之一。因为，无论是问题的规模、利益的多元还是治理的复杂问题，北欧国家的情况非常不一样。另外就是北欧三国的民族相对单一，这使它们拥有一种欧洲其他地方不可能有的内部凝聚力，其人民有更加强烈的一体性和团结意识。如果是一家人，对于缴税去帮助那些不那么富有的人，你就不会持有那么强烈的怀疑态度。但是，如果你周围有大量的外国人，而法律规定在发放福利时不得有歧视，你的态度就会改变。</p>

<p>过去几年，北欧国家对收留难民和受迫害者采取了宽松的政策。难民大量涌入会如何改变瑞典人的公有社会主义观仍然有待观察，但是如果按照其他国家的情况来看，这个人口变化的结果迟早会改变他们对于慷慨援助低收入群体的看法。</p>

<p>由于生育率下降和需要劳动力，欧洲国家这些年来已经接纳了来自亚洲、中东、非洲和东欧的移民。移民舒缓了经济和人口的压力，但也产生了不同的问题。</p>

<p>德国至少有250万人是土耳其后裔。在法国巴黎，突然形成由少数种族主导的郊区，也让政府头痛不已。因为觉得被边缘化，这些地区的居民不时的制造骚乱。</p>

<p>到过英国任何一个主要城市的人都会觉得，英国的种族越来越多元化了。不过，由于华族社群比较不求闻达，并被视为最不会乱添麻烦，当地社会对华族的焦虑已经逐渐转移到其他种族。</p>

<p>种族问题因为宗教元素变得更加复杂。许多移民正好是回教徒（穆斯林），近年来，他们要求建造有尖塔的回教堂（清真寺）的呼声越来越大。不管多数欧洲人现在还去不去教堂，欧洲作为一个以基督教为主要宗教的社会，当外来移民多数是回教徒时，分歧自然会出现。</p>

<p>落户德国的土耳其人未能成为德国人，迁居法国的阿尔及利亚人和突尼斯人也未能变成法国人。欧洲日益认为这些人难以融入社会。虽然宗教、文化和语言都各有影响，种族还是那个抗拒融合的根本原因。</p>

<p>除了和平，欧洲融合还具有其他巨大的潜力。一个在意义上整合的欧洲将拥有更大的经济影响力，更重要的是，它在国际事务上可以有更大的发言权。简单的说，这是一个更加强大的欧洲。如果欧洲人进一步加强融合的努力，接受一个财政部长，甚至一个外交部长和一个国防部长，其硬实力的提升将是巨大的。</p>

<p>可惜，所有的迹象都指向欧洲不可能完全融合。欧洲国家迄今未能成功让单一货币行得通，要进一步发展到单一外交政策或单一军队的可能性更小。</p>

<p>欧洲在国际舞台上将知识次要的演员。面对美国、中国和未来也可能成为大国的印度，欧洲终将沦为配角。</p>

<p>尽管欧洲在国际事务上失声，这个大路上的国家所拥有的高水平教育和技能，足以让欧洲人过上好生活。个别国家将有些衰退，但会根据自身的竞争力水平达到一个稳定的状态，欧洲人的生活还是能过的很开心的。</p>

<p>过去苏联是一个安全威胁，但今日的俄罗斯要保持强国的地位会有困难。它的人口下降，经济依赖石油和天然气，也没发展出真正的社会经济。人们酗酒，妇女不多生育，都折射出一种普遍的悲观情绪。</p>

<p><img src="http://kobe1941.github.io/images/2023/09/7.jpg" alt="" /></p>

<p>欧洲移民就是恐怖分子，即使融入了，他们还是会称为恐怖分子，因为他们是通过互联网自我进化的。</p>

<p>日本、朝韩和印度</p>

<p>日本眼前最严峻的挑战是人口问题。它的人口正在迅速老龄化，生育率也达不到人口替代水平。其他如经济停滞不前及政治领导班底虚弱等问题，相比之下是小巫见大巫。日本若不解决人口问题，前景将非常黯淡。</p>

<p>新加坡也面对低生育率问题，情况和日本没什么不同。但新加坡引进移民，稍微减缓了这个问题，而日本却对接纳外国移民极为抗拒。由于保持种族纯洁性的观念是那么根深蒂固，日本人从未尝试公开讨论其他选择。</p>

<p>一个国家的人口结果决定了人民的命运。人口萎缩意味着国家的力量正在减弱。为此，我对日本的未来感到十分悲观。</p>

<p>政府为鼓励人民多生育而出台的激励措施往往作用有限，因为这不是钱，而是生活方式和志向改变的问题。即使是一些看到成效的国家，例如法国或瑞典，这个过程始终是缓慢而代价高昂的。</p>

<p>问：您认为20年后的日美同盟会是什么样的情况？
答：这得看到时美国经济的情况。如果美国到时已无法负担这样的同盟关系，那它将逐渐淡化。若是这样，日本就得向中国低头，成为其附庸国。它无法对抗中国，必须听中国的话。假如日本船只和中国船只在钓鱼岛相撞，日本船只只会撤退。</p>

<p>假如美国在这个区域的影响减弱，日本或许会以建立防御型核武力量作为最后手段。</p>

<p>在朝鲜，人民几乎与世隔绝。朝鲜自称是社会主义的人间天堂，事实上它是全世界治理得最差的郭嘉之一，就连让人民温饱的基本要求，也无法达到。</p>

<p>在可预见的未来，朝鲜半岛的形势估计将保持不变，因为眼前并没有什么改变现有均势的强烈动力。关注朝鲜问题的各方，包括中国和美国，几乎都不希望看到战争爆发或和平统一的情况出现。这其中的风险太大了。</p>

<p>即使没有美国介入，朝鲜也无法战胜韩国。因为韩国有着绝对的经济优势。决定国家实力的是工业产能，而不是军舰和枪炮的多寡。你若光有军备，却没有强大的经济基础作为后盾，即便你能为战争做更好的准备，也未必能持久战斗下去。</p>

<p>韩国人也不想看到双方骤然统一，由于韩国首都首尔在朝鲜的火炮射程之内，因此战争对他们来说是非常冒险的。所以即使韩国或许能打赢这场战，其首都也可能在战争中被摧毁，而韩国有约五分之一的人居住在这里。韩国人也未必乐见和平统一，尽管统一是他们的长期愿望和最终目标，韩国人却认定和平统一的经济代价会大得令人咋舌，因此他们宁可暂时将它缓一缓。</p>

<p>朝鲜为韩国带来的问题，将比东德为西德带来的严重两三倍。这是因为朝鲜比东德的情况糟糕得多。</p>

<p>韩国人更希望看到朝鲜逐渐对世界开放，并在隔了一段较长的时间，或许是改革开放数十年后，才同韩国统一。</p>

<p>美国希望朝鲜半岛局势长期保持平静，中国则不希望看到朝韩通过战争或以和平方式实现统一。中国人把朝鲜视为缓冲国，统一的南北朝鲜将受韩国控制，而美军将有可能获准前往位于中朝边境的鸭绿江。即使美军在韩朝统一后撤出朝鲜半岛，中国仍然不会将统一视为好消息。他们为何要看到邻国出现强大的、统一的南北朝鲜？按常理说，领国内部分裂，自己岂不是更加安心？</p>

<p>倘若美国的经济走下坡路，无法再在亚洲部署军力，韩国就会发展核武器。日本将会是东北亚最后一个发展核武器的国家，由于历史原因，日本民众对核武器相当反感。</p>

<p>经过这些年，我得出的结论是中国和印度是不能相比的。中国是经过自然发簪逐渐形成单一国民的。中国有9成人口是汉族人，而全国几乎每个人都能说同一种语言。中国有着印度所缺乏的某种凝聚力。印度就是不具备中国那样的决心和专心致志。</p>

<p>我一开始是为印度加油，因为它是一个民主国家。但随着年龄的增长，我领悟到了两件事。第一，民主制度并非什么灵丹妙药，它无法为所有人解决所有的问题。第二，社会内有一些根本的势力是难以改变的，那么历史越是悠久的国家越是如此。印度受制于其内部结构几乎无法改变的现实，并被种姓制度仅仅束缚，无法挣脱。</p>

<p>东南亚</p>

<p>马来西亚的马来族拥有特权，华人和印度族人属于二等公民，不能公平的分享权力。</p>

<p>新加坡最重要的任务，是建立和维持一个强大的武装力量，以维护国家的主权。只要我们拥有一支能够阻吓侵略者的新加坡武装部队，就不会有人来干涉我们。</p>

<p>他信将原本被曼谷政权及中上阶层独占的资源转移到泰国较贫穷的地区，颠覆了泰国的政治现状。他信的政治理念较具包容性，并让来自北部和东北部的农民分享国家经济增长的果实。</p>

<p>越南人是东南亚最能干和精力最充沛的人民之一。他们有着这么精明的人才，却没能充分发挥潜能，着实令人感到惋惜。但愿在经历战争的一代告别人生舞台后、年轻一代接棒时，他们能够看到泰国的良好发展，从此肯定自由市场的重要性。</p>

<p>如果新加坡最终决定走向两党制，我们将注定平庸。</p>

<p>两党制最大的问题是，一旦落实，最优秀的人才不会选择从政。参选得冒很大风险。竞选活动会变得非常不文明，甚至卑鄙恶毒。渴望当总裁的青年才俊自然远比希望当美国总统的人来得多。</p>

<p>国家要往哪个方向走，将取决于新加坡年轻一代做出什么样的决定。无论选择什么，我敢肯定的是，新加坡一旦选出一个愚蠢的政府，我们就全完了。国家将会沉沦，化为乌有。</p>

<p>即使是巨额的金钱奖励，对生育率还是起不了太大的作用。生育率下降是因为生活方式与思维观念已经不一样了。</p>

<p>一旦妇女受教育，有了平等的就业机会，她们就再也不把生儿育女照顾家庭视为首要任务。妇女要像男人一样充分发展事业，要更多闲暇时光，到处旅游看世界，不想受子女所牵绊负累。</p>

<p>如果要我说出哪个问题对新加坡的生存威胁最大，我会说是人口问题。这个问题我无从解决，也早已放弃。</p>

<p>我们在过去几十年奠定了很好的优势：劳动队伍受过良好教育并以英文为第一语言、华文为第二语言；法治制度完善，尊重知识产权；各个领域都随时准备引进最新科技；政府清廉且高度透明，并时时创造利于经商的环境。</p>

<p>遗憾的是，随着经济的持续增长，收入差距也日益扩大。</p>

<p>中东</p>

<p>中东世界在历史上没有少数服从多数的传统。打从远古的伊斯兰教时代，到比较近代的殖民统治，到后殖民时代民族主义运动兴起，这个地区从来就没有民主传统。当年英法保护领地分裂为各个独立多加之后，全都演变成一人专政体制。这不是巧合，而是有着根深蒂固的社会文化因素。</p>

<p>中东除了不曾有过代议政治的实际经验，中东也缺乏某些必要的社会元素，去建构一个让民主主义足以萌芽扎根的坚实基础：
1.首先是公民平权。意即你我即使在财富、社会地位、成就、体质和智力等方面有差别，只要同为一国子民，我们还是平等的。凡国家赋予的任何公民的权益与义务，你我也都共同享有、共同担当。法律上你我平等，道德上亦然。公民平权是发展实质民主程序与体制不可或缺的前提条件，不光需要在知识界和进步圈中受到认可，还必须能深入社会民间。</p>

<p>2.民主体制要趋于成熟，要让公民不单能接受革命以后的首届大选的结果，还要接受接下来每一届大选的结果。这个元素是让经济真正发展起来的“资本”。</p>

<p>没有真正的经济发展，新上台的民主政权是不可能长久持续的。对街头巷尾的平民百姓来说，无法换来实质成果的民主，还能有多大的存在意义？</p>

<p><img src="http://kobe1941.github.io/images/2023/09/8.jpg" alt="" /></p>

<p>以色列和巴勒斯坦和解虽然未必是导致整个中东地区和平的充分条件，却是必要前提。</p>

<p>我不相信以色列能阻止伊朗发展核武器。美国做得到，但必须准备发动一场地面侵略行动，而这个可能性微乎其微。由于存在可怕的估算错误，这意味着世界较不稳定。我们或许会见证本地区在二战后率先动用核武器。</p>

<p>全球经济何去何从</p>

<p>资本主义制度并不存在根本的缺陷，这个制度无需摒弃或重建。</p>

<p>长远而言，资本主义制度对世界更好，并会让它的增长加快许多。这是因为历史已清楚的证明，无论在哪一种社会，自由市场都是组织生产性力量的最有效方式。</p>

<p><img src="http://kobe1941.github.io/images/2023/09/9.jpg" alt="" /></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《人类简史》]]></title>
    <link href="http://kobe1941.github.io/blog/human-history-simple.html"/>
    <updated>2023-09-27T20:31:54+08:00</updated>
    <id>http://kobe1941.github.io/blog/human-history-simple</id>
    <content type="html"><![CDATA[<p>历史的铁则就是：事后看来无可避免的事，在当时看来总是毫不明显。</p>

<p>特别要强调的是，那些在当代看来最不可能发生的事，常常就是最后成真的事。</p>

<!--more-->

<p>但这也不是说一切都有可能发生，地理、生物和经济力量确实会造成限制。但限制下仍然有许多发展空间，目前还没有什么确实加以制约的法则。</p>

<p>对于许多希望看到历史必然性的人来说，这种说法大概有些令人失望。毕竟，宿命论吸引人的地方，就在于觉得这个世界和我们的信念都是历史上自然且必然的产物。于是，我们似乎是自然而然就发展处民族货架，自然就遵循资本主义经济原则，也是自然而然地坚信着人权的概念。如果承认历史并非必然，等于是承认了现在的民族主义、资本主义和人权都只是巧合的产物。</p>

<p>然而，历史就是这样的一团混沌，历史就是无法解释得斩钉截铁，无法预测得十拿九稳。在同一时间，有多方力量互相影响、互相牵制，只要某方力量有了极小的改变，结果就会有巨大的不同。</p>

<p>历史不像是物理学或者经济学，目的不在于做出准确预测。我们之所以 研究历史，不是为了要知道未来，而是要拓展视野，要了解现在的种种绝非“自然”，也并非无可避免。未来的可能性远超过我们的想象。举例来说，研究欧洲人究竟是如何控制了非洲人，我们就知道种族歧视绝非自然或无可避免，而且知道世界大有可能是完全不同的样貌。</p>

<p>目前来看，对快乐与否的影响，家庭和社群要比金钱和健康来得重要。那些家庭关系紧密良好，社群互相扶持帮助的人，明显比较快乐。而那些家庭机能失调，一直无法融入某个社群的人则明显比较不快乐。而其中，婚姻又是特别重要的一项因素。多项重复研究发现，婚姻美好与感觉快乐，以及婚姻不协调与感觉痛苦，分别都呈现高度相关。而且，不论经济状况和身体健康如何，情况都是如此。</p>

<p>现代社会每个人都拥有了前所未有的自由，能够决定自己要走哪条路，但也让我们越来越难真正信守承诺，不离不弃。于是，社群和家庭的凝聚力下降而解体，这个世界让我们感到越来越孤独。</p>

<p>正如尼采所言，只要有了活下去的理由，几乎什么都可以忍受。生活有意义，就算在困境中也能甘之如饴；生活无意义，就算在顺境中也度日如年。</p>

<p>我们对生活所赋予的任何意义，其实都只是错觉。不管是中世纪那种超凡脱俗的生活意义，还是现代人文主义，民族主义和资本主义，本质上都完全相同，没有高下之别。可能有科学家觉得自己增加了人类的知识，所以他的生命有意义；有士兵觉得他保卫自己的国家，所以他的生命有意义。不论是创业者想要开新公司，还是中世纪的人想要读经，参与圣战，兴建新庙，他们从中感受到的意义，都只是错觉和幻想。</p>

<p>佛教认为，快乐既不是主观感受到愉悦，也不是主观觉得生命有意义，反而是在于放下追求主观感受这件事。</p>

<p>佛教与现代生物学和新世纪运动的相同点，在于都认定快乐不在于外在条件。但佛教更重要也更深刻的见解在于，真正的快乐也不在于我们的主观感受。我们如果越强调主观感受，反而就越痛苦。佛教给我们的建议是，除了别在追求外在成就之外，同时也别在追求那些感觉良好的心理感受了。</p>

<p>许多传统哲学和宗教（如佛教）认为，快乐的关键在于追求真我、真正的了解自己。苦真正的来源不在于感受本身，而是对感受的不断追求。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《股票大作手回忆录》]]></title>
    <link href="http://kobe1941.github.io/blog/great-stocker-memory.html"/>
    <updated>2023-09-23T22:03:49+08:00</updated>
    <id>http://kobe1941.github.io/blog/great-stocker-memory</id>
    <content type="html"><![CDATA[<p>赚大钱不能靠个股的波动，而要靠大盘走势；不能考解读盘面，而要靠预判整个市场和市场趋势。</p>

<p>既能正确判断市场走势又能坚守操作准则的人少之又少，我发现这是最难学到的事情之一。</p>

<p><!--more--></p>

<p>在牛市你要做的就是在自己认为牛市走到终点之前一直买入和持有。要做到这一点，你必须研究大盘，而不是靠小道消息或者影响个股的特殊因素。</p>

<p>我的资金积累的并不快，因为我总是在享受生活。我不愿意剥夺像我这个年龄、有我这种品味的人想要的东西，我有自己的汽车，当我可以从市场上赚到钱的时候，我不认为有任何理由去节衣缩食。让资产增值的最好方法是，不要节省生活的花销。</p>

<p>在上涨行情中入手是买进股票最稳妥的方式。</p>

<p>重点不在于尽可能以便宜的价格买进或是以最高的价格卖出，而在于在正确的时机买进或卖出。当我看空而卖出股票时，每次卖出的价格都比上一次低，当我买进时正好相反。我一定是向上买进，我做多时不会以低于之前的价格，而是以高于之前的价格买进。</p>

<p>我操作的前提是我已经相当深入的研究过市场大势，确定当时是多头市场。我从来不希望以过于低廉的价格或是太容易的买到股票。</p>

<p>很多事情成功与否，取决于开始的时机是否完全正确。我花了很多年才认识到这一点的重要性，也让我付出了数十万美元的代价。不要曲解我的意思，我不是建议你持续加码。当然一个人可以连续操作赚到大钱，否则也就赚不到钱。我想说的意思是：假设一个操作最大值是500股，我建议他不要一次性全部买入。假设他买进第一笔100股立刻就出现了亏损，那么为什么他还要继续操作买入更多股票呢？他应当立刻停手观察，看看自己是否犯了错，至少暂时是错了。</p>

<p>即便是在孩提时代，我也总是通过自己的观察从事实中得出结论。当我做多股票时，是因为通过解读大盘让我看多后市。我不会允许自己的持仓情况或者先入为主之见去左右自己的思考，这就是为什么我总在说我不会去与大盘争论的原因。</p>

<p>老帕特里奇先生一直坚持在牛市中要持续看多的重要性，毫无疑问，这种看法让我认定，确定你当前所处的市场类型比任何其他事情都重要。我开始意识到只有在大趋势中才能赚到大钱。</p>

<p>我放空的速度太快了。这让我付出了惨痛的代价。我在市场中的位置正确，但操作错误。我没有等待去判断时机是否适合全力放空，在我应当借助自己看盘能力的时候却没有这样做。正是这些经历让我学会：即使在熊市初期正确地判断出后市走向，看淡后市，在确定没有行情回弹的风险之前，不宜开始大规模的放空。</p>

<p>我有一个古老的交易理论，那就是一只股票在第一次突破100点、200点或300点时，不会在这个整数点大关停下来，而是会继续一路上扬。所以，如果你在股价刚刚突破整数点关口时买入几乎肯定是可以赚钱的。</p>

<p>市场经历了一轮疯狂的反弹行情之后开始有了放空的需求。为什么？因为人们又在开始谈论牛市了。</p>

<p>因为在经历低谷之后，一个人会 很享受处在顶峰的感觉，虽然他还没有到达顶峰。挣钱的方法就是去做可以挣钱的事情；挣大钱的方法就是在合理的时机做挣钱的事情。</p>

<p>在濒临钱荒之际，内部人士们却提高分红比率，这无异于在双膝跪地求着我放空。</p>

<p>我最伟大的发现是一个人必须去研究基本形势、评估这些因素，从而能够去预测各种可能性。</p>

<p>认识自己的错误比分析成功的原因更有益处。</p>

<p>犯错误而且不认就不仅仅是财产上的损失了，更是对心灵的伤害。</p>

<p>每一个年轻人或正常的人用不了多长时间就可以丢掉身为穷人时的那些习惯，而忘记自己曾经富有却需要很长时间。我认为这种现象的原因是金钱带来欲望，或者说鼓励享受。我的意思是，当一个人从股市上赚到钱以后他很快就会丧失节俭的习惯，但当他亏掉自己的钱之后却要花很长的时间才能改掉大手大脚的习惯。</p>

<p>观察市场行情，目的只有一个：确定方向，也就是价格趋势。价格和其他东西一样，沿着最小阻力方向运动。怎么走比较省力它们就怎么走，因为，如果上涨的阻力比下跌的小，那么它们就会往上走，反之亦然。</p>

<p>永远不要因为价格太高而不买，永远不要因价格太低而不愿抛出。从本质上来说，价位高低与我找到最小阻力线毫无关系。</p>

<p>在多头市场中，人们就会忽略利空消息，而利好的消息总是被夸大，反之亦然。</p>

<p>我总结出一条规律：在震荡幅度走窄的市场中，如果市场走不出明确方向，只是在一个狭窄的区间内波动，预测下一次大行情是涨还是跌毫无意义。此时，你要做的是观察市场，研读盘势，确定无方向震荡的区间有多大，并且做出决定，在价格没有突破向上或向下的边线之前不要轻举妄动。投机客必须思考如何从市场中赚钱，而不是偏执的要求让盘势行情与自己的判断一致。永远不要和盘势争论，也不要让大盘给你理由或解释。</p>

<p>如果我买入一只股票，我会在顶部买入；如果我卖出一只股票，那肯定是在底部卖出，要么就不卖。交易者要等到最小阻力线显露无遗时才出手，而且只在盘势显示应该买入时才买入，在盘势显示应该卖出时才卖出。在上涨行情中，交易者应该一路加码，先买入仓位的1/5。如果这笔交易无利可图就不能加仓，因为那样做显然已经开始犯错了，至少暂时错了，而犯错无论在什么时候都不能带来利润。凡事开头出错便绝不会有利可图。</p>

<p>这就是我所谓的交易体系：只在赚钱的时候才重仓操作，而在赔钱的时候只亏一点探测性的赌注而已。</p>

<p>一个人在同一件事上花了几年工夫，免不了会产生一种大大有别于普通新手的习惯性态度，正是这一点将专业人士与业余人士区分开来。一个人看待事物的方式决定了他在投机市场中是赚还是亏。一般公众对自己的操作的认识还非常浅薄，他们的思考总是掺杂着过多的自我因素，因此不可能深入彻底。而专业人士注重的是力求行事正确，而不只是赚钱，因为他们明白，水到渠成之日利润自然会来。</p>

<p>棉花交易出现亏损，我却继续持有；小麦交易出现利润，我却抛出。这真是一次极其愚蠢的操作。抛出产生损失的头寸，保留获利的头寸，这才是非常明智的做法。</p>

<p>指望股市为你买单正是华尔街最常见的亏损原因之一。如果你固执己见，就会赔掉一切。</p>

<p>在华尔街凡是想让股市为自己付钱购买汽车、首饰、游艇或者名画的人，没有一个不是赔钱的。投资者想让股市付钱为自己买生日礼物，但吝啬的股市予以拒绝，投资者们为此付出的代价足够建立一所大型医院了。</p>

<p>当一个人急于让市场满足自己的需求时，他会怎么做？他是在赌博，所以他因此承受的风险远高于他理智时的操作。</p>

<p>感激之情是任何一个谦谦君子都无法抑制的情感，但它不应该成为羁绊别人的东西。</p>

<p>无私报恩没有错，但这个原则不能用在股市之中，因为大盘并没有这种侠义风度，不会报答你的忠诚。</p>

<p>我非常冷静的得出一个结论：只要还忧心忡忡，就不会做成任何有用的事，而同样明显的是，只要我欠着钱，我就会一直担心。</p>

<p>一个投资者除了研究基本形势，牢记市场先例，把外界公众的心理以及他的经纪商的局限铭记在心之外，他还必须认识自己并且准备好应对自己的弱点。</p>

<p>我的经验是：无论什么时候，一只股票首次上涨过100点，200点或300点的整数关口，几乎总是会继续上涨30-50点，突破300点之后，上涨的速度会比越过100或200点时更加快。</p>

<p>无论从事任何事业，“好的开始是成功的一半”。</p>

<p>一个人赚钱的时候到来时，想不赚钱都难，就像在暴雨中没有打伞，想不被淋湿都是不可能的一样。这是我们见过的最明确无误的牛市，每个人都清楚，协约国购买美国制造的各种各样的供给品，美国成了世界上最繁荣的国家。与其他经济繁荣相比，战时繁荣发展得更为自然和迅猛，除此之外，也会为公众带来史无前例的利益。</p>

<p>还有一件事需要记住，那就是市场不会再灿烂光辉的照耀之下登上顶点，也不会以另外一种突然反转的形式而终结。股市可能而且经常是在价格普遍开始下跌之前很久就已经走出牛市。（股市领先实体经济的表现）</p>

<p>在牛市，价格走势当然是在坚决明确的上涨。所以，每当有一只股票背离大势，你就有理由认为这只股票在某些方面出了问题。对于经验丰富的交易者而言，这足可以让他们察觉到行情的不妙。</p>

<p>领头羊们已经停止了领涨，所以我卖出它们，每只都做空5000股，然后再做多最新的领涨股。</p>

<p>这些突发事件往往是沿着阻力最小的方向推进。</p>

<p>绝对不要试图在最高点卖出。这种做法是不明智的，股票下跌之后没有再强势反弹就应当卖出了。</p>

<p>正常的交易风险并不会一个人出门逛街或者乘坐火车旅行的风险更大。当因为一些无人可以预知的事情的发生而亏损时，我认为自己对此的怨恨不过像是一场不合时宜的暴风雨。从摇篮到坟墓，人生本身就是一场赌博。</p>

<p>对错误的惩罚就是亏损；对正确的奖赏就是盈利。</p>

<p>没有操纵手段可以打压股价并让股价一直走低。</p>

<p>内幕消息的提供人士不在乎消息质量，打听消息的人并不是在追求准确的消息，而是希望得到任何消息。</p>

<p>我一直认为靠内幕消息交易是愚蠢透顶的。</p>

<p>所有人都相信会有奇迹发生，这种信念是过度放纵欲望的结果。</p>

<p>人们听信内幕消息不是因为他们都是笨蛋，而是因为他们喜欢喝我前面提到的“希望之酒”。</p>

<p>观察、经验、记忆和数学——这些是成功交易人士的必备要素。</p>

<p>经验教会我们，市场的走向是一个作手应当追随的最佳向导。</p>

<p>我们知道所有的股票不会一起沿着同一个方向波动，但同一板块的股票却会在牛市中一起上涨，在熊市中一起下跌。</p>

<p>经验告诉我，不要去买那些没有追随板块领涨股的股票。</p>

<p>另一方面，不知内情的外部股民现在开始买入，因为股价曾经爬高到45美元，现在跌到了35美元以下，看起来非常便宜。</p>

<p>研究投机中的人性因素，就会很容易理解为什么人们会轻信那些自己希望相信的事情，为什么他们纵容自己或者说实际上是鼓励自己去贪图钱财，或者像芸芸众生那样因为疏忽大意而失掉钱财。</p>

<p>谁卖出自己手中没有的东西，要么买回来，要么进监狱。</p>

<p>你可以把一匹马牵到水边，却不能强迫它喝水。最好牢记炒作的一条原则，这也是基恩和其他优秀的前辈都明白的原则，即尽可能把股票炒到最高点，然后在下跌的过程中出货给公众。</p>

<p>如果希望把一只股票卖出去，应该尽快把价格炒到最高，然后抛售。我重复这一点，一是因为这是基本原则；二是因为显然公众都相信所有的卖出都应该在高位进行。有时一只股票会徘徊不前，在这种情况下，股价不再上涨，这就是卖出的好时机。</p>

<p>当我的买盘不能拉台股价时，我会停止买进，然后开始抛售，即使我恰好没有在炒作这只股票，我仍然会同样操作。你应该知道，脱手一只股票的主要方式是在下跌过程中卖出。在股价下跌时可以处理掉这么多股票，确实令人惊奇。</p>

<p>当操盘手无法让一只股票按照自己的意愿波动时，就应该终止操作了。当你操作的股票没有按照它应有的表现波动时，要立刻出清离场。不要与大盘争辩，不要指望去挽回利润。该离场时就离场，这是最合适和划算的操作方法。</p>

<p>正如声誉良好的报纸总是设法找出市场波动的理由然后发表出来，这就是新闻。读者们不仅想要知道股市发生了什么，还想知道其中的缘由。</p>

<p>很多股东希望在下跌时把股票卖掉，但不愿在低于顶部三四个点的价位卖出。这种投机者总是发誓说，下次再有反弹，他们一定卖出。于是股价上涨时他们挂出卖单，当看到股价走势改变，心态就又发生了变化。</p>

<p>操作方向错误让人赚不到钱，股票市场尤其如此。</p>

<p>一个人违背经验教训和常识行动不是 好事。但是华尔街的傻瓜不全都是外行人。</p>

<p>普通股民从来不考虑股票的价值，只考虑价格，而且他们的行动不是由市场大势控制，而是内心的恐惧在操控。</p>

<p><img src="http://kobe1941.github.io/images/2023/09/1.jpg" alt="" /></p>

<p>市场一路向下，在这样的市场行情之中，卖出的唯一方法未必是不计后果，但一定是不计成本。</p>

<p>投机买卖股票的人成千上万，但能够获利的只是少数。</p>

<p>如果禁止刊登任何匿名的利好消息，公众的损失将会大大减少。我指的是那些刻意引诱公众买入或持有股票的言论。</p>

<p>除了听信利好消息买进股票而遭受重创之外，公众因为听从劝告没有及时抛出股票而蒙受损失的情况也经常发生。</p>

<p>公众应该坚定不移的掌握一个要点：股价长期下跌的真正原因绝对不是空头打压。当一只股票不断下跌时，你应该猜到其中必有问题，不是市场的问题就是公司自身的问题。如果是无厘头的下跌，股价很快就会跌到其真正价值之下，这就会带来买盘阻止跌势。</p>

<p>在牛市之中，尤其是市场景气时，公众刚开始都会赚到钱，但随后就全部都赔掉了，原因就在于停留在牛市之中的时间太长了。</p>

<p>市场走势总是领先实际状况6-9个月。一只股票当前的收益情况不能成为经纪公司建议客户买入该股的根据，除非有一定把握，可以确定6-9个月之后公司的业务前景可以维持相同的收益率。</p>

<p>公众应该始终记住股票交易的基本要领。当一只股票价格上涨时，没有必要详细解释上涨的原因，持续的买盘会让价格不断上涨。只要股价保持上涨，偶尔出现自然的小幅回调，那么跟随涨势操作是非常安全的。然而，如果股价经过长期的稳定的涨势之后开始掉头下跌，只是偶尔有些反弹，那么显然阻力最小方向已经由上涨转为下跌了。情形就是这样，为什么要寻求解释呢？</p>

<p>我作为股票作手多年的经验让我相信，一个人在某些特定情况下在一些个股上可以赚到钱，却做不到一直不断的战胜股市。</p>

<p>根据内幕消息进行操作让人破产的速度更快。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《彼得林奇的成功投资》]]></title>
    <link href="http://kobe1941.github.io/blog/peter-lynch-successful-investment.html"/>
    <updated>2020-08-22T11:57:12+08:00</updated>
    <id>http://kobe1941.github.io/blog/peter-lynch-successful-investment</id>
    <content type="html"><![CDATA[<p>整体上很不错的一本书，值得多次阅读复习。但是其中也有一些在今天看来不太适合实操的内容要引起注意，比如：</p>

<p>1.林奇说业余投资者没有基金管理者的那么多的限制，从而更容易买到大牛股。这个是相对的，基金贵购买股票的限制是为了规避风险，比如不买小市值的股票，不买ST的股票，虽然可能会错过某些收益很高的股票，但也避免了重大损失，这些规则限制内的股票能够成长为大牛股的实在是太小了，个人投资者最好慎重理解林奇的这个见解。</p>

<p>2.13条选股准则。这些准则除了回购股票和分散经营营收不依赖单个大客户这两条之外，其他真的是一言难尽，把这些规则推荐给业余投资者，在现在这个时间点看来是非常不合适的。</p>

<p>林奇写作的本书是一本最简明易懂、为 业余投资者讲述投资基本知识的投资入门书籍。 林奇在本书中为业余投资者系统讲述了 一套最实用有效的股票投资策略。</p>

<p>林奇在本书中最精辟、最深刻地分析 了业余投资者常见的投资心理误区，能够帮助投资 者避开导致亏损严重的投资陷阱。</p>

<p>林奇忠告业余投资者要在买好住房、存够生活 必需支出之后再将闲钱用于股票长期投资；林奇将卖出赚钱的股票却死抱住亏钱股票的行为比喻为 “拔掉鲜花浇灌野草”；林奇用鸡尾酒会理论形象地告诉我们在每个人都谈论股市时反而是最危险的时候，在每个人都不愿谈论股市时反而是最安全的时候。</p>

<p>林奇将股票分为缓慢增长型、 稳定增长型、快速增长型、周期型、困境反转型、 隐蔽资产型 6 大类股票并逐一分析各自的不同特点， 总结出 10 倍股的 13 个特点，提醒应该小心避开 6 种危险股票，并告诉我们如何构建投资组合、应该持有多少股票最为合理、何时应该买入股票、何时应该卖出股票，从而为业余投资者提供了一套选择大牛股，获得最高长期投资收益率的系统方法和准则。</p>

<!--more-->

<p>本书由三个部分构成。</p>

<p>第一部分，投资前的准备工作(第 1~5 章)，讨论业余投资者如何评估自己作为一位选股者是否胜任，怎样评估投资竞争对手 (包括投资组合管理人员、机构投资者以及其他华尔 街投资专家)，如何判断股票是否比债券的投资风险 更大，如何检查自己的财务需求以及如何发展形成 一个成功的选股模式。</p>

<p>第二部分，如何选择大牛股 (第 6~15 章)，讨论如何找到最有潜力的投资机会， 要选择什么样的公司以及避开什么样的公司，如何 利用经纪人和年报以及其他资源获得最大的信息优势，如何计算那些经常在股票专业分析中用到的各 种数据指标(如市盈率、账面价值、现金流量等)。</p>

<p>第三部分，长期投资观点(第 16~20 章)，讨论如何 设计投资组合，如何跟踪分析你感兴趣的公司的情况，何时应该买入以及何时应该卖出，期权和期货 交易的蠢行以及我本人对于华尔街、美国企业以及 股票市场的发展是否健全的整体观察等，这些都是 我在 20 年的投资生涯中一直持续关注的事情。</p>

<p>业余投资者阅读林奇的这本投资经典名著，可以一举多得：最成功的基金经理成为你的投资导师、 增强自己发挥自身优势战胜专业投资者的信心、系统掌握一套实用有效的选股准则、非常轻松地学习简单易懂的股票基本面分析知识、深刻认识和避免 容易产生的投资心理误区。既然如此，何乐而不读林奇的这本好书呢?</p>

<h2 id="section">序言</h2>

<p>我支持这样一个投资理念：公司盈利迟早决定证券投资的成败与否。关注今天、明天或者未来一周的 股价表现如何只会分散投资者的注意力。</p>

<p>在互联网热潮中，要避免以高得离谱的股价买入一家未来发展前景虚无缥缈的公司股票而亏得很惨的结局，投资者可以采取以下三种投资策略。</p>

<p>第一种投资策略是。铁镐和铁锨”(picks and shovels)投资策略。过去在淘金热潮中，大多数想 要成为矿主的淘金者都以失败告终，而那些向淘金 者出售铁镐，铁锨，帐篷和牛仔裤的人却发了大财 。——牛市中的券商</p>

<p>第二种投资策略是投资于“可以一分钱不花就 能拥有其互联网业务”(freeInternet play)的公 司。这是指投资者买入一家有着真实营业收入和合 理股价的非网络公司的股票，这家公司将网络业务 渠道嵌入传统业务渠道之中形成一个紧密结合的整 体，使投资者支付的股价只相当于非网络业务的价值，而与此同时不花一分钱就拥有了相关的网络业 务。</p>

<p>如果这家公司网络业务的 发展能够达到预期水平，那么投资回报将会非常丰 厚——这家公司会将其网络业务。分拆上市”(spin off)从而使网络业务的股票单独上市进行流通交易。 或者如果公司在网络业务上的冒险并不成功，但是 由于网络业务只是公司日常业务的一个补充而已， 因此其股价也不会怎么下跌，仍然可以保护投资者不会损失太大。</p>

<p>第三种投资策略是投资于因互联网发展而。附 带受益”(tangential benefit)的公司。指传统的 “砖头水泥。(brick and mortar)的实业公司通过 使用互联网而削减了成本。简化了业务流程。提高 了经营效率，从而实现了盈利能力的大幅增长。</p>

<p>那些目前卖价低于过去买价的严重套牢股票让 我想到一个重要的观点：你没有必要在所选择的每 一只股票上都赚钱。 投资者只要挑选到少数几只大牛股就能 够获得一生的投资成功，因为你从这几只大牛股上 获得的盈利会远远超过在那些表现不尽如人意的股 票上所遭受的损失。</p>

<p>历史情况告诉我们，市场修正(correction，下跌 10%或者更多)每隔几年就会发生一次，熊市(bear market，下跌 20%或者更多)每隔 6 年会出现一次。 从 l929—1932 年股市大崩盘之后，大熊市(severe bear market，下跌 30%或者更多)又发生了 5 次， 因此跟别人打赌说这是我们看到的最后一次熊市行 情无疑是非常愚蠢之举，这也正是为什么你一定要 牢记在心的非常重要的一个原则是：绝不要用你明 年的大学学费、结婚费用或者其他开支的资金来购 买股票或者共同基金。这样你就不必在一个大跌的 市场中被迫卖掉股票以换成现金来支付不得不支付 的必要开支。如果你是一个长线投资者，那么时间最终会站在你这一边。</p>

<p>股票投资的基本原则非常简单并且永恒不变。 股票并非彩票。与每一只股票紧密相关的都是一家 上市公司，公司经营有时会更好、有时会更差。如 果一家公司的经营状况比以前更差，那么这家公司 的股价就会下跌；如果一家公司的经营状况比以前 更好，那么这家公司的股价就会上涨。如果你持有 一家盈利不断增长的公司的股票，那么你的股票投 资回报将会十分丰厚。</p>

<h2 id="section-1">前言与导论</h2>

<p>“在这本书中我要告诉读 者的第一条投资准则是:千万不要听信任何专业投资者的投资建议！在投资这一行 20 年的从业经验使 我确信，任何一位普普通通的业余投资者只要动用 3%的智力，所选股票的投资回报就能超过华尔街投资专家的平均业绩水平，即使不能超过这些专家， 起码也会同样出色。”</p>

<p>业余投资者没有专业投资者那样内部或外部的各种限制和监管，也没有投资理论和教条的束缚，更有机会在生活中早于专业投资者好几年发现最有成长性的好公司，从而有机会提前买入上涨数十倍的大牛股。</p>

<p>从 10 月的股市暴跌中我们可以汲取很多教训， 我自己总结 3 点：(1)不要让烦心之事毁掉一个很好的投资组合；(2)不要让烦心之事毁掉一次愉快的度假；(3)当你的投资组合中现金比重很小时千 万不要出国旅游。</p>

<p>不管 某一天股市下跌 508 点还是 108 点，最终优秀的公司将会胜利，而普通的公司将会失败，投资于这两类完全不同的公司的投资者也将会相应得到完全不 同的回报。</p>

<p>不要投资于你根本不了解的公司股票 。</p>

<h2 id="section-2">第一部分  投资准备</h2>

<p>现在我回过头来看，很显然，学习历史和哲学 比学习统计学能够更好地为股票投资做好准备。股 票投资是一门艺术，而不是一门科学，因此一个接 受训练、习惯于对一切事物进行严格数量分析的人 在投资中反而有很大的劣势。</p>

<p>逻辑学应该是在选股方面对我帮助最大的一门 学科，因为正是逻辑学教我认识清楚了华尔街特有 的不合逻辑性。</p>

<p>事实上，如果面临两种投 资选择，第一种选择是有可能投资于一家不知名的 公司股票会赚到一大笔钱，第二种选择是可以确定 投资于一家已被广泛认可的公司的股票只有少量的 损失，那么无论是共同基金经理人、养老基金经理 人，还是公司投资组合经理人都会毫不犹豫地放弃 赚大钱的可能性而选择亏小钱的确定性。对于专业 投资人来说，能赚大钱固然是好事，但更为重要的 是万一你投资失败时你也不会落得个悲惨下场。华 尔街上有一条不成文的潜规则:“如果你购买是 IBM 的股票而使客户资金遭受损失，那么你永远不会因 此而丢掉你的饭碗。”</p>

<p>一般说来基金管理者要花将近 1/4 的工作时间 来解释自己最近如何投资操作—首先是向部门内部 自己的顶头上司，然后是最终的老板也是他们的客户进行解释(就像道格的客户怀特面包公司的弗林 特)。这里有另外一条不成文的规则，即客户的资产规模越大，投资组合经理人与这家客户的管理者进 行交谈以取悦他们所需要的时间也就越多。</p>

<p>如果你本身就是一个业余投资者，顺其自然自由自在地进行投资思考就可以了，没有必要强迫自己像一个专业投资者那样思考投资。</p>

<p><strong>最后我再说一次，也许你根本不应该与股票市场沾边儿，这是一个值得进一步详细讨论的问题， 因为进入股市必须要有坚定的信念，没有坚定信念 的投资者只会成为股市中的牺牲品。</strong></p>

<p>历史数据无 可辩驳地证明，股票投资收益率要比债券投资收益率高得多。事实上从 1927 年以来，普通股票的平均 年投资收益率为 9.8%，而公司债券为 5%，政府债券 为 4.4%，短期国库券为 3.4%。</p>

<p>根据消费价格指数(consumer price index， CPI)计算，长期通货膨胀率每年为 3%。扣除通货 膨胀率后普通股票的实际年投资收益率为 6.8%，而 扣除通货膨胀率后短期国库券这种以最保守和最明 智而闻名的投资工具的实际年投资收益率却几乎是 零，是的，它的实际收益率确实是零。</p>

<p>为什么股票长期投资收益率远远超越公司债券 和国库券呢?对此一个合乎逻辑的解释是：投资股票时投资者可以从公司的增长中分享到相应的回报， 股票投资者是一家业务兴盛且迅速扩张的公司的一 个合伙人，而投资债券的投资者不过只是公司吸引 的闲置资金的一个最方便的来源而已。当你借给别 人钱时，你可以得到的最大回报无非就是收回本金， 再加上一点利息而已。</p>

<p>各位想一想，这些年来一直持有麦当劳公司债 券的那些投资者，他们和麦当劳之间的关系开始于购买债券之时，而当麦当劳债券到期付清本金时他们之间的关系也就结束了，这些债权人与最激动人心的麦当劳快速成长的大牛股神话毫不沾边儿。</p>

<p>即使是买对了正确的股票，但如果在错误的时间以错误的价格买入，也会损失惨重。</p>

<p>如果投资方法错误(如购买了一只股价被过度高估 的股票)，即使是购买百时美公司或者亨氏公司这样 著名大公司的股票也会导致巨大的损失，同时会因 此丧失掉其他很多的投资机会。</p>

<p>开始投资任何股票之前，投资者都 应该首先问自己以下三个个人问题：(1)我有一套 房子吗?(2)我未来需要用钱吗?(3)我具备股 票投资成功所必需的个人素质吗?</p>

<p>购买一套房子可以一举多得：地方政府房地产 税可以用来抵扣联邦税相当于获得了一份红利，房 屋本身可以抵御通货膨胀，房地产在经济萧条时期 是资产保值的最佳避风港，更不用说房屋每天为你 遮风挡雨带来的舒服享受。最后，如果你决定将房 子卖出，你可以用你获得的收入再购买一套更好的 房子，这样就可以避免为你上一次获得的房屋投资 利润交税。</p>

<p>普通人一般买房的过程如下：先买一套面积较 小的房子(第一套房子)，然后换成一套面积中等大 小的房子，再往后再换成一套大房子，最终等到孩 子们长大搬出去住以后，你就不再需要这么大的房 子了，这时你可以卖掉这套大房子，搬到一套较小 的房子里去，在这样一连串的搬迁中你会赚到一笔 可观的利润足以让你安度晚年，而且这笔增值收入 还不用交税，因为富有同情心的政府给了你一生唯 一一次买卖房屋增值收入的免税待遇。 这种优惠待遇在股票买卖中永远不会发生，政府只会对股票交 易利得尽可能多而且尽可能重地征税。</p>

<p>“我未来需要用钱吗”是我们要问的第二个问 题。在你买股票之前首先重新检查一下家里的财政 预算情况是一件十分必要的事情。例如，如果你在 两三年之内不得不为孩子支付大学学费，那么就不应该把这笔钱用来投资股票。</p>

<p>在股票市场的投资资金只能限于你能承受得起的损失数量，即使这笔损失真的发生了，在可以预见的将来也不会对你的日常生活产生任何影响。</p>

<p>我认为股票投资成功所必需的个人素质应该包括：耐心、 自立、常识、对于痛苦的忍耐力、心胸开阔、超然、 坚持不懈、谦逊、灵活、愿意独立研究、能够主动 承认错误以及能够在市场普遍性恐慌之中不受影响 保持冷静的能力。就智商而言，最优秀的投资者的 智商既不属于智商最高的那 3%，也不属于最差的 10%，而是在两者之间。在我看来，真正的天才由于 过度沉醉于理论上的思考，结果他们的理论总是被 股票实际走势所背叛，现实中的股票走势远远比他 们想象出来的理论要简单得多。</p>

<p><strong>要想取得股票投资成功一个非常重要的个人素 质是要有能力在得到的信息不完全、不充分以及得 到的信息不完全准确的情况下做出投资决策。</strong>华尔街的事情几乎从来不会十分明朗，或者说一旦事情 明朗化时，再想要从中谋利已为时太晚，那种需要 知道所有数据的科学思维方式在华尔街只会一再受挫。</p>

<p>最后，至关重要的是你要能够抵抗得了你自己 人性的弱点以及内心的直觉。绝大多数的投资者内心的一个秘密角落里都会隐藏着一种自信，觉得自 己拥有一种预测股票价格、黄金价格或者利率的神奇能力，尽管事实上这种虚妄的自信早已经一次又 一次地被客观现实击得粉碎。</p>

<p><strong>投资的窍门不是要学会相信自己内心的感觉，而是要约束自己不去理会内心的感觉。只要公司的基本面没有什么根本的变化，就一直持有你手中的股票。</strong></p>

<h3 id="section-3">第一部分总结</h3>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
</pre></td><td class="code"><pre><code class=""><span class="line">不要过高估计专业投资者的技巧和智慧。
</span><span class="line">
</span><span class="line">充分利用你已经知道的信息和知识。
</span><span class="line">
</span><span class="line">寻找那些尚未被华尔街发现和证实的投资机会——在华尔街“雷达监测范围之外”的公司。
</span><span class="line">
</span><span class="line">在投资股票之前先买一套房子。
</span><span class="line">
</span><span class="line">投资的是公司，而不是股市。
</span><span class="line">
</span><span class="line">忽略股市的短期波动。
</span><span class="line">
</span><span class="line">投资股票能够赚大钱。投资股票也能够亏大钱。
</span><span class="line">
</span><span class="line">预测经济是没有用的。
</span><span class="line">
</span><span class="line">预测股市的短期走势是没有用的。
</span><span class="line">
</span><span class="line">股票的长期回报相对而言是可以预测的，而且远远高于长期债券的投资回报。
</span><span class="line">
</span><span class="line">持续关注你所持有股票的公司情况，就像是在玩一局永远不会结束的梭哈扑克牌游戏。
</span><span class="line">
</span><span class="line">并不是每个人都适合于股票投资，也并不是每个人一生中的每个阶段都适合于股票投资。
</span><span class="line">
</span><span class="line">一般业余投资者早在专业投资者数年之前，就已经十分了解当地优秀的上市公司及其产品了。
</span><span class="line">
</span><span class="line">拥有一种与众不同的优势将会帮助你在股票上赚钱。
</span><span class="line">
</span><span class="line">在股票市场上，一鸟在手胜过十鸟在林。 
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="section-4">第二部分 挑选大牛股</h2>

<p>我认为，购买股票之前首先要做好公司分析研究的功课，这和你以前发誓不再理会股票市场短期波动同等重要。 不做研究就投资如同不看牌就玩梭哈扑克游戏一样危险。</p>

<p>那些风行一时的快速增长行业早晚都会变成缓 慢增长行业，许多预期这些行业将会持续快速增长 的分析师和预言家会被事实无情地嘲弄。人们总是 倾向于认为事情永远不会改变，但是事实证明改变 永远不可避免。</p>

<p>在经济衰退时期人们对狗粮的购买也不会减少， 这就是为什么 Ralston Purina 的股票是值得持有的相对安全的股票。</p>

<p>所以当增长速度放慢时，规模较小的快速增长 型公司将会面临倒闭的风险，而规模较大的快速增长型公司则会面临股票迅速贬值的风险。一旦快速增长型公司的规模发展得过大，它就会像格列佛在小人国里一样遇到进退两难的困境，因为它再无法 找到进一步发展的空间。</p>

<p>但是只要能够持续保持较快的增长速度，快速增长型公司的股票就会一直是股市中的大赢家。我所寻找的是那种资产负债表良好又有着实实在在的丰厚利润的快速增长型公司。投资快速增长型公司 股票的诀窍是弄清楚它们的增长期什么时候会结束以及为了分享快速增长型公司的增长所付出的买入价格应该是多少。</p>

<p>任何傻瓜都能经营这项业务”是完美公司的 一个特点，而所我梦寐以求的正是完美公司的股票。</p>

<h3 id="section-5">13条选股准则</h3>

<p>公司名字听起来枯燥乏味，甚至听起来 很可笑则更好</p>

<p>公司业务枯燥乏味</p>

<p>公司业务令人厌恶</p>

<p>公司从母公司分拆出来。——大型的母公司根本不愿意看到分拆上市后的子 公司陷入困境，因为这样可能会对这家子公司产生 非常不利的公众影响，反过来又会使母公司受到非 常不利的公众影响。</p>

<p>机构没有持股，分析师不追踪。——如果你找到了一只机构投资者持股很少甚至根 本没有持股的股票，你就找到了一只有可能赚大钱 的潜力股。</p>

<p>公司被谣言包围：据传与有毒垃圾或黑 手党有关</p>

<p>公司业务让人感到有些压抑</p>

<p>公司处于一个零增长行业中</p>

<p>公司有一个利基(Niche) 。——无论如何夸大排他性的独家经营权对于一家公 司或者公司股东们的价值也不过分。 一旦你在任何一种产品上获得了排他性的独家 经营权，你就可以提高价格。</p>

<p>人们要不断购买公司的产品</p>

<p>公司是高技术产品的用户</p>

<p>公司内部人士在买入自家公司的股票</p>

<p>公司在回购股票。——回购股票是一家公司回报股东的最简单也是最 好的方法。</p>

<p>除了回购股票的做法以外，企业运用多余资金 一般还有以下几种选择：(1)提高股息；(2)开发 新产品；(3)开拓新的业务；(4)进行收购兼并。与回购股票相反的做法是增发新股，这也叫做 “稀释股份”。</p>

<p>如果说有一种股票我避而不买的话，那它一定是最热门行业中最热门的股票，这种股票受到大家 最广泛的关注。</p>

<p>高增长行业和热门行业吸引了一大批希望进入 这些行业淘金的聪明人，企业家和风险投资家都在 彻夜不眠地盘算着如何才能尽早地进入这些行业。 假如你有一个稳赚不赔的商业创意，但却无法用专 利或者利基来加以保护，那么一旦你获得成功，你 就得防备其他人群起效仿，在商业界，效仿是一种 最不纯粹要命的攻击方式。</p>

<p>另一类我避而不买的股票是被吹捧成下一个 IBM、下一个麦当劳、下一个英特尔，或者下一个迪 士尼之类公司的股票。</p>

<p>这些一旦冒险成功将获巨大回报但成功机会非 常微小的高风险股票的共同特点是它们都让你赔上 一大笔钱，除了这一事实以外，另一个共同特点就 是吹牛吹破天，却根本没有什么实质内容，这也正 是那些被人们小声耳语的股票的本质。</p>

<p>小心过于依赖大客户的供应商公司股票。如果一家公司把 25%一 50%的商品都卖给了 同一个客户，这表明该公司的经营处于十分不稳定 的状态之中。</p>

<p>除了取消合同的风险之外，大客户还拥有很大 的谈判优势可以逼迫供应商降价和提供其他优惠， 这将会大大压缩供应商的利润空间，因此购买这种 过于依赖大客户的供应商公司的股票几乎不可能获 得很大的投资成功。</p>

<p>尽管有时容易忘记，但是我们必须牢记。一股股票绝 非一注彩票。一股股票代表着对一家公司的部分所有权。</p>

<h6 id="section-6">即使关于市盈率你什么都记不住的话，你也一 定要牢记一点:千万不要买入市盈率特别高的股票。只要坚决不购买市盈率特别高的股票，就会让你避免巨大的痛苦与巨大的投资亏损。除了极少数例外 情况，特别高的市盈率是股价上涨的障碍，正如特 别重的马鞍是赛马奔跑的障碍一样。</h6>

<p>第一步，你已经弄清了自己所研究的公司股票 究竟是属于缓慢增长型、稳定增长型、快速增长型、 困境反转型、隐蔽资产型、周期型公司股票这六种 类型中的哪一种类型。第二步，根据股票的市盈率倍数，你可以大致估计一下，这只股票目前的价位 水平相对于公司不久的将来发展前景来说是低估还 是高估了。接着第三步是要尽可能详细地了解公司 正如何经营运作以使公司业务更加繁荣，增长更加 强劲，或者实现其他预期将会产生的良好效果，这 就是我们最想要了解的公司未来发展的“故事”。</p>

<p>这正是我 在研究 Bildner’s 公司股票时忘记询问的那个最重 要的问题:它的经营策略在其他地方进行复制也能 同样获得成功吗?</p>

<p>在公司经营能力得到证明之前，千万不要提前 贸然买入这家公司的股票。</p>

<p>当注视着同样一片天空时，成熟产业的人看到的是前途黑暗阴云密布，而非成熟产业的人看到的则是前途光明无限。</p>

<p>一些重要的财务分析指标 ：某种产品在总销售额中占的比例、市盈率、现金头寸——指公司账面的现金及现金等价物、负债因素和股息 。</p>

<p>短期负债(最差的一类负债，GcA 公司的负债就 属于短期负债)是债权人提出要求时必须马上偿还 的负债。这种负债不一定都是借自银行，一家公司 也可以采用商业票据的形式向另一家公司进行短期 借款。短期负债最重要的特点是期限很短，有时甚 至是对方通知就得马上还款</p>

<p>长期负债(从股东的观点来看，这是最好的一类 负债)的债权人就不能马上收回借款，无论借款人的 经营情况多么糟糕，只要还在继续支付利息，债权 人就不能要求提前归还本金。</p>

<p>投资者青睐派发股息的公司的一个强有力的理 由是，不派发股息的公司大都曾有过把大笔资金浪费在一系列愚蠢的多元化并购上的痛苦经历。</p>

<p>投资者青睐派发股息股票的另一个理由是：派息的股票更具有抗跌性，如果没有派发股息会导致 股价更大幅度地下跌。</p>

<p>那些小公司由于不派发股息可能会增长更快，它们把本来应该用来派发股息的资金用来进一步扩张业务。公司发行股票的首要目的是为了筹集资金进行扩张同时又不用承担银行贷款的债务负担。</p>

<p>如果你买入一只股票是为了获得股息，那么你就要弄清楚这家公司在经济衰退和经营糟糕时期是否仍然能够支付股息。</p>

<p>现金流量是指一家公司从业务经营中获得的现 金流入超过现金流出的净流入数量。</p>

<p>每隔几个月就应该重新核查一下你的公司基本面分析。</p>

<h3 id="section-7">股票分析要点</h3>

<h5 id="section-8">所有类型公司的股票</h5>

<p>·市盈率。对于这家公司来说市盈率是高还是低，这家公司的市盈率与同行业中类似的公司相比 是高还是低?</p>

<p>·机构投资者持股占该公司总股本的比例。机构投资者持股比例越低越好。</p>

<p>·公司内部人士是否在买入本公司股票?公司是 否回购自己的股票?二者都是有利的信号。</p>

<p>·迄今为 止公司收益增长的历史情况，公司收益增长时断时 续还是持续稳定增长(只有隐蔽资产型公司股票可 以说收益情况并不怎么重要)。</p>

<p>·这家公司的资产负 债情况是好是坏(负债与股东权益比率)，公司财务实力评级情况如何。</p>

<p>·现金头寸。</p>

<h5 id="section-9">缓慢增长型公司的股票</h5>

<p>·由于你购买这类公司股票的目的是为了获得 股息(不然的话为什么还要持有这类公司股票呢)， 所以你应该核查一下这类公司是否长期持续派发股 息以及是否能够定期提高股息水平。</p>

<p>·如果可能的话，弄清楚公司派发股息占收益 的比率是多少。如果股息占收益的比率比较低，那 么这家公司在经营困难时期仍有缓冲资金可以帮助 公司挺过难关，即使收益降低，公司仍然保证股息 的派发;如果股息占收益的比率比较高，那么股息 能否顺利派发就相当危险了。</p>

<h5 id="section-10">稳定增长型公司的股票</h5>

<p>·这类公司都是几乎不可能破产倒闭的大公司， 因此关键因素在于买入价格的高低，股票的市盈率会告诉你股价是否过高。</p>

<p>·检查公司可能进行的多元化经营情况，这有可能导致公司未来收益下降。</p>

<p>·检查公司收益的长期增长率，还要查看最近几年是否仍然保持着同样的增长势头。</p>

<p>·如果你打算永久持有一家稳定增长型公司的股票，就要好好看看这家公司在经济衰退以及股市 大跌时期的表现如何</p>

<h5 id="section-11">周期型公司的股票</h5>

<p>·密切关注周期型公司存货变化情况以及供需 平衡情况。注意市场上新 的竞争对手的进入，这通常是一个危险的信号。</p>

<p>·当公司业绩复苏时应该预测到市盈率将会降 低，当公司收益会达到最 高峰时投资者应该预期到公司增长周期可能即 将结束。</p>

<p>·如果你非常了解你持有的周期型公司的行业 周期，那么在预测周期波 动时就具有了一种优势。例如每个人都知道汽 车行业具有周期性，汽 车行业经过三四年的扩张期后就会出现三四年 的衰退期，汽车行业总 是这样涨涨跌跌反复波动。汽车越用越旧然后 就需要更换，人们可能 会比预期推迟一两年更换新车，但是迟早他们 总要去购买新车。</p>

<h5 id="section-12">快速增长型公司的股票</h5>

<p>·如果你推测某种产品能为公司赚大钱，那么 你应该调查研究一下这种产品的销售收入在公司整 个业务收入中是否占有很大的比重。</p>

<p>·最近几年公司的收益增长率</p>

<p>·公司已经在一个以上的城市或者乡镇顺利复 制了原来成功的经营模式，证明公司未来的扩张同 样能够取得成功。</p>

<p>·公司业务是否还有很大的增长空间。</p>

<p>·股票交易价格的市盈率是否等于或接近于公 司收益增长率。</p>

<p>·公司扩张速度是在加快</p>

<p>·只有很少几个机构投资者持有这只股票，并且只有少数几个证券分析师听说过这只股票。对于 那些正处于业务上升阶段的快速增长型公司来说， 这是一个能够让你低价买入的非常有利的因素。</p>

<h5 id="section-13">困境反转型公司的股票</h5>

<p>·最重要的是，一家困境反转型公司在经营困 难时期能否经受住债权人要求还款的打击而存活下 来?公司拥有多少现金?多少债务?困境反转型公司的债务结构如何?公司在赔本 的情况下还能经营多长时间并最终能够走出困境而 避免破产?</p>

<p>·如果这家公司已经宣布破产，那么公司破产 清算偿还债务之后还会给股东留下来多少资产?</p>

<p>·公司打算怎样摆脱困境重整旗鼓?它剥离了那 些赔钱的子公司了吗?这样做会使公司的收益发生 很大的变化。</p>

<p>·公司业务正在好转吗?</p>

<p>·公司正在削减成本吗?如果是的话，成本削减 效果又如何呢?</p>

<h5 id="section-14">隐蔽资产型公司的股票</h5>

<p>·公司的资产价值是多少？公司有隐蔽资产吗?</p>

<p>·公司有多少债务需要从这些资产中扣除掉？(首先要关注的就是向债权人的借款。)</p>

<p>·公司是否正在借入新的债务使资产价值进一 步减少?</p>

<p>·是否有袭击并购者对公司感兴趣准备收购公司？这将会帮助股东从隐 蔽资产的重估升值上大大获利。</p>

<h3 id="section-15">第二本部分总结</h3>

<p><strong>真正了解你所持股公司的业务情况，真正清楚你持有这家公司股票的具体理由。</strong></p>

<p>弄清楚你所持有的股票属于什么类型，这样你将会更清楚地了解你对投资回报的合理预期应该 是多少。</p>

<p>大公司的股票往往涨幅不会太大，而小公司 的股票往往涨幅很大。</p>

<p>如果你预测某家公司能够从某一种特定产品 获利的话，那么你应该考虑一下公司总销售收入的 规模，计算一下这种产品销售收入在公司总收入中 所占的比重。</p>

<p>找那些已经盈利并且事实证明它们能够在 其他地方复制其经营理念取得成功的小公司。</p>

<p>特别要小心那些年收益增长率高达 50%~100% 的公司，一定要用怀疑的眼光进行分析。</p>

<p>远离那些热门行业中的热门股。</p>

<p>不要相信多元化经营，事实证明多元化经营往往反而会导致公司经营状况恶化。</p>

<p>那些一旦成功将获得巨大回报但只有微小成 功机会的投资冒险几乎从来都不会成功。</p>

<p>在公司第一轮业绩上涨时最好不要盲目买入， 等等看公司的扩张计划是否确实有效再做决定更为稳妥。</p>

<p>业余投资者从其工作中能够获得有着巨大价 值的投资信息，而且往往要比专业投资者提前好几 个月甚至好几年得到。</p>

<p>把股票消息与提供股票消息的人分开，不要盲目听信任何人的股票消息，不管提供股票消息的 人多么聪明、多么有钱、上一次他的消息多么灵验。</p>

<p>投资那些业务简单易懂、枯燥乏味、普通平凡、不受人青睐，并且还没有引起华尔街专业投资者兴趣的公司股票。</p>

<p>在不增长行业中增长速度适中的公司(收益增 长率为 20%~25%)是十分理想的股票投资对象。</p>

<p>寻找那种拥有利基的公司。当购买那些公司 处于困境之中并且股价表现令人沮丧的股票时，要 寻找财务状况非常好的公司，要避开银行债务负担 沉重的公司。</p>

<p>没有债务的公司根本不可能破产。</p>

<p>管理能力也许非常重要，但是管理能力很难进行评估。购买某一家公司股票的依据应该建立在 公司发展前景之上，而不是建立在公司总裁的履历或者演讲能力之上。</p>

<p>一家处于困境中的公司成功东山再起会让投 资者赚到一大笔钱。</p>

<p>仔细考虑市盈率的高低。如果股票价格被严 重高估，即使公司其他情况都很好，你也不可能从 这种股票上赚到一分钱。</p>

<p>找到公司发展的主线，根据这一主线密切关 注监视公司的发展。</p>

<p>寻找那种一直在持续回购自己股票的公司。</p>

<p>研究公司过去几年的派息记录以及在经济衰 退期的收益情况如何。</p>

<p>寻找那种机构投资者持股比例很小或者机构 投资者根本就没有持股的公司。——值得商榷</p>

<p>如果其他情况都相同的话，那些管理者个人 大量持有自家公司股票的公司，要比那种管理者没 有持股只拿薪水的公司更值得投资。——你在说万科？</p>

<p>公司内部人士购买自家公司的股票是一个有 利的信号，特别是当公司内好几个内部人士同时购 买时。</p>

<p>每个星期至少抽出一个小时的时间进行投资 研究。计算累计收到的股息以及计算自己投资盈亏 情况并不算是投资研究。</p>

<p>一定要耐心。水越等越不开，股票越急越不涨。</p>

<p>只根据公司财务报表中的每股账面价值来购 入股票是非常危险的，也是根本不可靠的，应该根 据公司资产的真实价值而不是账面价值来买入股票。</p>

<p>怀疑时，等等看。</p>

<p>在选择一只新股票时要认真研究分析，至少应该与你选择一台新冰箱所花的时间和精力一样多。</p>

<h2 id="section-16">第三部分 长期投资</h2>

<p>本部分我将对以下主要问题发表一下自己的看法：怎样构造一个投资组合使业绩最大化而风险最 小化；何时应该买入及何时应该卖出；市场崩溃时 应该怎么办；一些关于股票价格为何上升和为何下 跌的愚蠢且危险的错误观念。</p>

<p><strong>在某些年份里你能够获得 30%的投资收益率， 但在其他年份里你可能只有 2%的投资收益率，甚至可能会亏损 20%，这正是投资世界的基本规律之 一，你别无选择只能接受。</strong></p>

<p><strong>过高的预期收益率错在哪里呢?如果你期望每 年应该获得 30%的投资收益率，那么当股票表现达 不到你预期的高收益率时，你很可能会因为希望落 空而感到严重受挫，这时焦躁不安的心情会使你恰 恰在最不应该放弃的时刻错误地放弃自己本来正确 的投资策略，或者更糟糕的是，在追逐这种镜中花 水中月般的高收益率时，你可能会冒不必要的风险。 不论是在投资收益很好还是很坏的时候，你都应该始终坚持一种正确的投资策略，只有这样才能使长 期投资回报最大化。</strong></p>

<p>一般股票的长期平均投资收益率为 9%~l0%， 这也是历史上股票指数的平均投资收益率。</p>

<p>尽管有指数基金和股票投资基金等那么多方便 的投资选择，业余投资者仍然坚持自己进行投资选股，那么要证明你付出时间和精力自己来选择股票 是值得的，从长期来看你应该从股票投资中获得 12%~15%的复利投资收益率，进行业绩计算时必 须扣除所有成本和佣金，并加上所有股息和其他红 利。</p>

<p>在股票投资中，一直持有股票的长期投资人的 收益率，要远远超过那些频繁买进卖出股票的短期投资人。对于小股民来说，频繁买进卖出股票要支付很多交易成本。</p>

<p>投资困境反转型股票你必须事先认识到这类股票高风险与高回报并存的特点 。</p>

<p>根本不存在任何一种合适的方法能够量化分析 投资风险与回报具体是多少，你在设计自己的投资 组合时，应该加入 2 只稳定增长型公司的股票，从 而在一定程度上平衡持有 4 只快速增长型公司股票 和 4 只困境反转型公司股票的巨大投资风险。</p>

<p>如果你以过高的价格买入一只股票，那么即使 这家公司后来获得了巨大的经营成功，你仍然无法从这家公司的股票上赚到一分钱，这真是一个莫大的悲剧。</p>

<p><strong>最后，你的投资组合设计可能需要随着年龄的 改变而改变。年轻的投资人未来还有一生的时间可 以挣得很多的工资收入，因此可以用更多的资金来 追逐 10 倍股；那些年纪大的投资人却并不能如此， 他们更需要从股票投资中获得稳定的收入来维持生 活。因此年轻的投资人比年长的投资人有更多的时 间进行尝试，即使犯一些错误也不要紧，直到寻找 到一只超级大牛股从而成就一番伟大的投资事业。</strong></p>

<p>我只会把一种 股票换成另一种股票，而不会换成现金，除非为应 付预计可能发生的基金赎回而必须准备一定数量的 现金。卖掉股票换成现金就意味着这一部分资金彻 底脱离了股票市场。我的观点是要把资金永远留在 股票市场里，根据基本面的变化把资金在不同股票 之间进行转换。我认为，你决定将一定数量的资金 一直留在股市之中进行投资，这样会使你避免许多时机选择失误的投资操作和由此产生的心理痛苦。</p>

<p>买入股票的最佳时机往往就是你确信发现了价值可靠却价格低廉的股票之时。</p>

<p>第一个可能发现特别便宜股票的特殊时期，是在一年一度通常在年底投资者为了减税而卖出亏损 股票的时候，因此一年之中股价下跌最为严重的时 期是在 10~12 月间并不让人感到意外。</p>

<p>第二个可能发现特别便宜的股票的特殊时期， 是在股市崩盘、大跌、激烈振荡、像自由落体一样 直线下跌的时候，这种现象股市每隔几年就会出现。</p>

<p>如果你抓住一只大牛股，你就应该一直持有直到获得最大的回报。 而不是中途卖出获利了结。</p>

<p>在一只股价上涨之后继续坚决 持有，往往要比股价下跌之后继续坚决持有困难得 多。这些日子如果我感觉自己有被假象愚弄而出局 的危险，那么我就会重新审视一下自己最初购买这 只股票的理由，看看现在和过去相比情况有否不同。</p>

<p>散户面对外在因素的心态</p>

<p><img src="http://kobe1941.github.io/images/2020/08/1.png" alt="" /></p>

<p>多年以来我学会的一个经验就是：像思考何时购买股票一样思考何时卖出股票。我毫不关注外部 宏观经济情况的变化，除了少数几个非常明显的重 大事件之外，我能够确定这一重大宏观经济事件将 会以某一具体方式影响到某一具体行业。比如，当 油价下跌时，很明显将会对石油服务公司产生影响， 但对制药公司却没有什么影响。</p>

<p>事实证明，如果你很清楚地知道自己当初买入 一只股票的理由，自然你就会清楚地知道何时应该 卖出这只股票。</p>

<h4 id="section-17">何时应该卖出一只缓慢增长型股票</h4>

<p>对于我持有的少数缓慢增长型公司股票，当上涨了 30%~ 50%时，或者基本面情况恶化时，即使股价已经下 跌我也会坚决赔钱卖出。</p>

<p>其他应该卖出缓慢增长型 公司股票的信号有:</p>

<p>①公司连续两年市场份额都在流失，并且正在 聘请一家新的广告代理商。</p>

<p>②公司没有正在开发新产品，研发经费开始削减，公司明显表现出吃老本的想法，满足于过去的 荣耀而不思进取。</p>

<p>③公司新收购了两个与主营业务无关的业务， 看起来有多元化发展导致经营恶化的趋向，并且公 司声称正在寻找收购“处于技术发展前沿”的公司。</p>

<p>④公司为收购兼并支付了太高的代价，导致资 产负债表恶化，从账上没有负债和有数以百万美元 的现金，变成账上没有现金和有数以百万美元的负 债，即使公司股价大幅下跌，公司也无多余资金可 以用来回购股票。</p>

<p>⑤尽管公司股价相对较低，但股息收益率仍然很低，分配无法引起投资者的兴趣。</p>

<h4 id="section-18">何时应该卖出一只稳定增长型股票</h4>

<p>我经常用其他类型股票来替换稳定增长型公司 股票。期望从稳定增长型股票中找到一只 10 倍股是 毫无意义的。如果一只稳定增长型股票的股价线超 过收益线，或者市盈率远远超过正常市盈率水平， 你应该考虑卖出这只股票，等股价回落后再买回来， 或者买入其他没有上涨的稳定增长型股票，就像我 做的那样。</p>

<p>其他一些应该卖出一只稳定增长型股票的信号是:</p>

<p>①过去两年中新产品的业绩有好有坏，其他产品仍然处于试验阶段，还需要一年时间才能投入市 场。</p>

<p>②这家公司的股票市盈率为 15 倍，而同行业中 与其相当的公司市盈率只有 11~12 倍。</p>

<p>③过去一年中没有公司管理人员和董事购买自 家公司股票。</p>

<p>④一个占公司利润 25%的主要业务部门容易受 到即将发生的经济萧条的严重打击(如房地产业、石 油勘探业等)。</p>

<p>⑤公司增长率已经开始放缓，尽管公司通过削减成本可以保持盈利，但未来成本削减的可能性相当有限。</p>

<h4 id="section-19">何时应该卖出一只周期型股票</h4>

<p>卖出周期型股票的最佳时机是在公司增长达到 顶峰周期即将结束时，但谁知道周期何时会结束呢? 究竟谁知道他们讨论的到底是什么周期? 有时早在 一家周期性公司出现第一个业绩滑坡信号的一年之 前，那些很有远见的先锋性投资者就开始卖出所持 有的全部股票。周期型股票往往根本没有任何明显 实在的原因就会无缘无故地开始下跌。</p>

<p>除了在扩张周期结束时卖出之外，另一个卖出 周期型股票的最佳时机是当某些事情确实开始变得 糟糕时。例如，成本已经开始增长，现有的工厂满 负荷运营，公司开始投资以增加生产能力。</p>

<p>另一个明显的卖出信号是，公司的存货不断增 加，而且公司无法处理掉新增加的存货，这意味着 公司将来只能以更低的价格和更低的利润处理掉这 些积压的存货。 我总是对存货的增加非常关注。当 公司停车场上都堆满了存货，这肯定是你应该卖出 周期型股票的时机，事实上这时你才卖出可能已经 有些晚了。</p>

<p>大宗商品价格下跌是另一个应该卖出周期型股票的信号，通常早在公司收益出现问题的几个月之 前，汽油、钢材等大宗商品价格就已经下跌了。还有一个有用的信号是商品期货价格低于现货价格。</p>

<p>商业竞争对于周期型公司来说同样是一个不利 的信号，新进入这个产业的竞争对手为了赢得顾客 只能大幅降价，这又会逼得其他所有厂商降价，从 而导致所有厂商的利润减少。</p>

<p>其他应该卖出周期型股票的信号包括:</p>

<p>①公司在未来 12 个月内两个关键的工会劳动合 同期满，而且工会领导人要求全部恢复他们在上一 个合同中放弃的工资和福利。</p>

<p>②公司产品的最终需求正在下降。</p>

<p>③与以较低的成本对老厂进行现代化改造相反， 公司已经决定用比改造老厂高一倍的资本支出预算 来建立一家非常豪华的新厂。</p>

<p>④公司努力降低成本，但仍然无法与国外厂商 竞争抗衡。</p>

<h4 id="section-20">何时应该卖出一只快速增长型股票</h4>

<p>快速增长型股票的卖出技巧是不要过早卖出而 错失一只未来会上涨 10 倍的大牛股。</p>

<p>你应该回避的股票的所有特征(见第 9 章)也正 是你应该卖出的股票的特征。</p>

<p>其他应该卖出快速增长型公司股票的信号是:</p>

<p>①公司最近一个季度同一商店销售额降低 3%。</p>

<p>②公司新开设的分店销售业绩十分令人失望。</p>

<p>③公司两位高级管理人员和几位核心员工辞职离开后加盟到竞争对手公司。</p>

<p>④最近公司刚刚结束了一场路演，在两个星期内穿梭 12 个城市与机构投资者交流沟通，向他们描 述公司极度乐观的发展前景。</p>

<p>⑤公司股票市盈率高达 30 倍，而未来两年最乐 观的盈利增长率预期只有 15%~20%而已。</p>

<h4 id="section-21">何时应该卖出一只困境反转型股票</h4>

<p>卖出一只困境反转型股票的最佳时机是在公司 成功转危为安之后，所有的困难都已经得到解决， 并且每个投资者都知道这家公司已经东山再起了。 无论在公司陷入崩溃困境之前是增长型、周期型或 其他类型，都早已是昨日云烟。原来持有过这家公 司股票遭受严重损失的股东并不需要因为再次持有 其股票而内心窘迫不安。一家公司重组成功后，与 重组之前相比会完全不同，你应该重新对这家公司 股票进行分类。</p>

<p>其他应该卖出困境反转型公司股票的信号是:</p>

<p>①过去连续 5 个季度公司债务持续下降，但公 司最近的季度财务报告显示这个季度公司债务增长 了 2500 万美元。</p>

<p>②公司存货增长速度是销售增长速度的两倍。</p>

<p>③市盈率相对于预期收益增长率而言高得离谱。</p>

<p>④公司下属实力最强的分公司 50%的产品都销 售给一个最主要的客户，而这家客户自身正在遭受 销售增速放缓的痛苦。</p>

<h4 id="section-22">何时应该卖出一只隐蔽资产型股票</h4>

<p>最近对于隐蔽资产型公司股票最好的投资策略 就是等待公司袭击并购者的出现，如果公司真的拥 有大量隐蔽资产，索尔。斯坦伯格(Saul Steinberg)、 哈夫特家族(The Hafts)或瑞克曼家族(The Reichmanns)就会发现这家公司并进行收购。只要一 家隐蔽资产型公司没有大量借债而导致资产价值下 降，投资者就应该坚持持有这家公司的股票。</p>

<p>其他应该卖出一只隐蔽资产型股票的信号是:</p>

<p>①尽管公司股票价格大大低于公司资产的真实 市场价值，但管理层宣布将发行超过总股本 10%的 股票，筹资进行多元化经营。</p>

<p>②公司出售下属一家分公司预期价格为 2000 万 美元，但实际出售价格却只有 1200 万美元。</p>

<p>③由于税率降低，在相当程度上减少了公司由 于亏损而产生的未来可抵减所得税费用的时间性差 异(tax—loss carryforward)。</p>

<p>④机构持股者持股比例从 5 年前的 25%增加到 现在的 60%，几家位于波士顿的共同基金集团是主 要的持股者。</p>

<h3 id="section-23">12 种关于股价的最愚蠢 且最危险的说法</h3>

<p>①股价已经下跌这么多了，不可能再跌了。</p>

<p>抄底买入，就像把鱼钩放到水底钓大鱼，是一 种最流行的投资娱乐活动，但往往被钓住的并不是 鱼而是渔夫。想要抄底买入一只下跌的股票，就如 同想要抓住一把下跌的刀子。通常来说一个更稳妥 的办法是，等刀落到地上后，扎进地里，晃来晃去 了一阵后停止不动了，这时再抓起这把刀子也不迟。 想要抓住一只迅速下跌的股票抄底买入，不但抄不 到底，可能连你的老底儿都会输个精光，因为你在 错以为是底部的价位买入，其实根本不是底部，离 真正的底部还远着呢，就像想抓住一把迅速下坠的 刀子，不但抓不住，反而会伤到手导致剧烈的疼痛， 因为你抓错了地方。</p>

<p>但是即使投资者已经研究得非常清楚，也难以在最低价抄底买入。通常股价在重新上涨之前都会 振荡整理，一般来说这个振荡整理期会长达 2~3 年，有时候时间甚至会更长。</p>

<p>②股价已经这么高了，怎么可能再涨呢</p>

<p>关键是一只股票能够上涨多高并没有什么人为 武断的上限。如果一家公司的发展前景良好，投资 收益会继续增长，基本面也没有什么改变，仅仅因 为“股价不可能再涨”就放弃持有这家公司的股票 实在是太糟糕了。那些建议客户当投资上涨 1 倍时 就自动卖出股票的投资专家们应该为此感到耻辱和 羞愧，因为如果投资者按照他们的建议操作的话， 永远也没有机会抓住一只上涨 10 倍的大牛股。</p>

<p>坦白地讲，我也根本无法预测哪只股票能上涨 10 倍或者 5 倍，只要公司继续保持良好的发展前景， 我就会坚决继续持有这只股票，希望它最终能给我 带来令人高兴的意外惊喜。这种意外惊喜并不是公 司本身经营的成功，而往往是公司股票带来的高回 报。我记得我当初购买 Stop&amp;Shop 股票是因为这是 一只经营保守谨慎且支付股息的公司股票，后来公 司基本面不断改善，我才认识到我手里持有的原来 是一只快速增长型公司的大牛股。</p>

<p>我在投资管理这一行干了 20 年，总算明白了这 个道理:无论一只股票股价是 50 美元还是 1 美元， 当这只股票股价下跌到零时，对于你来说都是老本 亏了个精光，亏损都是 100%。一位投资者以每股 50 美元买入后亏损掉了 99%的投资，另一位投资者 以每股 3 美元的价格买入后亏损掉了 83%的投资， 买入低价股的有什么理由嘲笑买入高价股的呢?不 过是五十步笑百步而已，二者的亏损程度其实差别不大。</p>

<p>③股价只有 3 美元，我能亏多少呢</p>

<p>④最终股价会涨回来的</p>

<p>⑤黎明前总是最黑暗的</p>

<p>人们有一种心理倾向会这样认为:既然事情已 经变得这么糟糕了，那么将来不可能变得更糟糕了。</p>

<p>⑥等到股价反弹到 10 美元时我才会卖出</p>

<p>根据我个人的经验，从来没有一只严重套牢的 股票会如你所愿地反弹到你设定的卖出心理价位。</p>

<p>事实上，就在你说“等股票反弹到 10 美元我才会卖 出”的那一刻，就可能已经注定你将会面临这样的悲惨结局:这只股票在 9.75 美元以下的价位上上 下下振荡几年之后，然后直线下跌到 4 美元，最终 一路大跌到只有 1 美元的股票面值。整个痛苦的过 程可能要持续十年之久，在此期间你得一直忍受着 这只你并不喜欢的股票一路下跌对你的心理折磨， 而所有这一切仅仅是因为你的内心深处有一个声音 告诉自己:我要等到这只股票反弹到 10 美元才卖出。</p>

<p>每当我陷入这种心理误区时，我都会提醒自己， 除非我对这家公司有着足够的信心，在股价下跌时 愿意追加买入更多的股票，否则我就应该立刻卖出 这家公司的股票。</p>

<p>⑦我有什么可担心的，保守型股票不会波 动太大。</p>

<p>公司发展是动态的，公司发展前景是变化的， 根本没有任何一只你可以不管不问只需一直持有的 股票。</p>

<p>⑧等的时间太长了，不可能上涨了</p>

<p>投资者肯定碰到过这种情况:你一直等待一家 公司股价上涨，但等了很久却一直也没有上涨，于 是你实在等得不耐烦了就放弃了这只股票，可是就 在你卖出这只股票的第二天，你梦寐以求很久的上涨就发生了，我称这种情况为“不卖不涨，一卖就涨”。</p>

<p>持有一家你非常喜欢而所有其他人都毫无兴趣 不予理睬的公司股票，的确需要非同寻常的耐心。 也许股价一直一动不动会让你开始想是不是别人是 对的而我是错的，但是只要公司的基本面表明公司发展前景很好，那么你的耐心通常会得到很高的回报。</p>

<p>⑨看看我损失了多少钱，我竟然没买这只大牛股</p>

<p>他们一边仔细看着“纽 约股票交易所十只涨幅最大的股票”，一边想着他们由于没有买入这些大牛股而少赚了多么巨大的一笔钱。</p>

<p>在股票市场投资中，认为别人在股市赚的钱就 是我们自己赔的钱并非一种有益的态度。事实上， 这种态度只会让人完全疯狂。你知道的股票越多， 你发现你错过的大牛股也就越多，很快你就会责备 自己损失了数十亿甚至数万亿美元。</p>

<p>这种想法最糟糕的地方是会导致人们为了追逐最高的回报而盲目购买他们本来不应该购买的股票， 他们这样做只是为了避免像以前一样由于错过大牛 股而“亏损”掉一大笔钱。这样盲目投资经常会让 他们发生真正的亏损，而不仅仅是由于错过大牛股 而产生心理上的亏损。</p>

<p>⑩我错过了这只大牛股，我得抓住下一只 这样的大牛股</p>

<p>股价上涨，所以我选的股票一定是对的; 股价下跌，所以我选的股票一定是错的。</p>

<p>短期内，你选择的股票上涨或下跌，既不代表你的 选股是正确的，也不代表你的选股是错误的。</p>

<p>当你购买了一只股票后，短期内股价上涨或者 下跌只能说明有人愿意支付更多或更少的价钱去购 买同一只股票而已。</p>

<p>在我整个投资生涯中，我从未购买过一次期权， 也没有购买过一次期货，我现在仍然根本不想购买 期权和期货。要想从一般的股票投资上赚钱本身就 已经十分困难了，要想在这些如同赌博一样的期货 或期权交易上赚钱更上难上加难。 据我所知，除非是一个专业的期权或期货交易者，否则想从中赚钱几乎是不可能的。</p>

<p>期权投资最糟糕的地方是持有期权与持有公司 的股份毫不相关。当公司业绩增长非常繁荣兴旺时， 所有持有股份的股东都会受益，但期权投资却是一 个零和游戏，期权交易中一方获得任何1美元的赢 利，相应交易的另一方都会发生1美元的亏损，只 有极少数的期权投资者能够保持一直盈利。</p>

<p>沃伦·巴菲特认为应该将股票期货和期权交易 确定为违法行为，我完全赞成他的观点。</p>

<p>在我们持有的一只股票价格下跌时，我们中的 任何一个人都难免会感到内心惊慌，但是这种惊慌 是有一定限度的，因为我们知道一只股票的股价再 跌也不可能跌到零以下。如果你卖空的某一只股票 价格上涨了，你就会开始意识到没有什么能够阻止 股价的上涨，因为股票的涨幅是没有任何限制的， 因此卖空的亏损也是无限的。</p>

<p>股票市场 整体上像一只个股一样短期波动会和基本面变化 完全背道而驰。</p>

<h4 id="section-24">如果你从本书最后这一部分学到了一些东西的 话，我希望你能够记住以下投资原则:</h4>

<p>未来 1 个月、1 年或者 3 年的某一天，股市 将会突然大跌。</p>

<p>股市下跌是个极好的机会，买入你喜爱的股票。股价修正——华尔街对股价大幅下跌的定义— —使十分优秀的公司股票变得十分廉价。</p>

<p>不要妄想预测 1 年或 2 年后的市场走势，那是根本不可能的。</p>

<p>你并不需要一直正确，甚至不需要经常正确， 照样能够取得高人一筹的投资业绩。</p>

<p>那些让我赚到大钱的大牛股往往出乎我的意 料之外，公司收购而大涨的股票更是出乎我的意料 之外，但要获得很高的投资回报需要耐心持有股票 好几年而不是只持有几个月。</p>

<p>不同类型的股票有着不同的风险和回报。</p>

<p>连续投资一系列的稳定增长型股票，尽管每 次只有 20%~30%的投资收益率，但由于复利的作 用累积下来会让你赚到一大笔钱。</p>

<p>短期股价走势经常与基本面相反，但长期股 价走势最终取决于公司盈利成长性及其可持续性。</p>

<p>一个公司目前经营得十分糟糕，并不代表这家公司将来经营得不会更加糟糕。</p>

<p>只是根据股价上涨，并不能说明你是对的。 ·只是根据股价下跌，并不能说明你是错的。 ·机构投资者重仓持有且华尔街十分关注的稳定增长型股票在跑赢市场且股价高估之后必然面临 停滞或下跌。</p>

<p>仅仅因为股价便宜就买入一只发展前景普通的公司股票是一种肯定失败的投资之道。</p>

<p>因为股价似乎略为高估就卖出一只杰出的快 速增长型公司股票是一种肯定失败的投资之道。</p>

<p>公司盈利不会无缘无故地增长，快速增长型 公司也不可能永远保持快速增长。</p>

<p>没有买入一只好股票并不会让你损失一分钱， 即使是一只 10 倍股。</p>

<p>一只股票本身并不知道你持有它。</p>

<p>不要过度迷恋你手中的大牛股，因为股价大 涨而洋洋自得，不再关注公司的基本面变化。</p>

<p>如果 一只股票价格跌到零，你的亏损是 100%，让你输 个精光、血本无归，不管你的买入价格是 50 美元、 25 美元、5 美元还是 2 美元。</p>

<p>根据公司基本面认真分析后，清除部分股票 把资金配置到其他更好的股票上，能够进一步改善 你的投资组合业绩。当股价高估以致与公司的真实 表现相脱节，而且更好的投资选择出现时，卖掉高 估的股票转向其他更好的股票。</p>

<p>公司出现利好，如同玩梭哈时翻出好牌，此时应该加大赌注，反之应该减少赌注。</p>

<p>卖出盈利股票却死抱着亏损股票不放，如同拔掉鲜花却浇灌野草，根本不可能因此改善投资业 绩。</p>

<p>如果你认为自己不能战胜市场，那么买入一 只共同基金，这样会省去你自己投资需要花费的大 量精力和金钱。</p>

<p>总会有让人担心的事情发生，不要庸人自扰。</p>

<p>打开你的心灵之门，接纳所有创新的想法。</p>

<p>你并不需要“亲吻所有的女孩”。我也曾错过许多 10倍股，但这并不妨碍我仍然能够战胜市场。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《涛动周期论》]]></title>
    <link href="http://kobe1941.github.io/blog/compo.html"/>
    <updated>2020-07-19T09:55:36+08:00</updated>
    <id>http://kobe1941.github.io/blog/compo</id>
    <content type="html"><![CDATA[<p>整体上还是值得读的一本书，只看新闻中对周金涛理论的总结是不够的，书中有更详细的补充和说明，某种程度上可以完善相关的知识点。本书算是比较全面的介绍了各种金融资产和康波周期之间的关联，不过因为兴趣原因，黄金和大宗商品就都略过了。</p>

<p>需要注意的是，康波是西方经济学对过去经济发展历史研究的理论总结和经验提炼，很大程度上也是有道理的，拿来预测未来也无可厚非，但是由于某种神秘的东方力量的存在，且该力量在不断地壮大的过程中，对世界经济的影响力也越来越大，所以康波理论也需要一定程度的修正，政府的宏观调控是可以改变市场的，西方市场经济学也需要跟社会主义经济学相结合才行。</p>

<!--more-->

<p>周金涛先生，中信建投首席经济学家，中国康德拉季耶夫周期理论研究的开拓者。作为大师级的策略分析师，从2008年次贷危机到2016年大宗商品年度反弹，先生对于大级别周期运行脉络的把握可谓千古独步，被人们誉为“周期天王”。</p>

<p>本书的主体是以时间为线索将先生的重要报告和研究成果编撰成册，将其以经济周期有俺就和结构主义为核心的独特的逻辑框架和思维体系全面而完整的展示给读者。书中的内容几乎覆盖了包括股票、商品、美元、黄金以及房地产等在内的所有大类资产类别。依靠扎实的理论功底、翔实的数据论证以及严密的逻辑推演带领读者领略周期理论、结构主义与大类资产配置的完美契合。</p>

<h2 id="section">第一部分 涛动周期论</h2>

<p>涛动周期论——经济周期决定人生财富命运</p>

<p>人生发财靠康波，这句话的意思就是说我们每个人的财富积累一定不要以为是你多有本事，财富积累完全来源于经济周期运动的阶段给你带来的机会。</p>

<p>一个人的一生中，你能够获得的机会，理论上来讲只有三次，如果每一个机会都没有抓到，肯定你一生的财富就没有了。如果抓住其中一个机会，你就能够至少成为中产阶级。</p>

<p>我们在做人生财富规划的时候一定要知道每个人都是在社会的大系统中运行，社会大系统给你时间机会你就有时间机会。这个大系统没给你机会，你在这方面再努力也是没有用的。</p>

<p>房地产周期20年轮回一次，一个人当中可以碰到两次房地产周期。为什么呢？一个人的一生作为群体来讲会两次买房，第一次是结婚的时候，平均27岁。第二次是二次置业，为改善性需求，是在42岁左右。一个人的消费高峰，最高峰出现在46岁的时候，46岁之后这个人的消费就往下走，你的消费逐渐由房子这些变成医疗养老。</p>

<p>从日本等国家工业化转型期内企业重组的特征来看，可以从以下角度来观察重组中企业的行为。</p>

<p>其一，在消化过剩产能的过程中，存在着横向的并购重组，但这种重组可能只存在一次性的机会。</p>

<p>其二，纵向重组，这是企业降低成本的一种考虑，如果能够降低成本，这在经济调整期就是有效的。</p>

<p>其三，企业的规模经济问题，要探讨重组所带来的规模经济是否是有价值的。历史的情况是，在工业化的转型期，相当多的产业还没到大规模集中的程度，所谓龙头企业的价值是十分有限的。</p>

<p>其四，在技术模仿与产业升级中中小企业的作用。</p>

<p>其五，全国市场的形成中渠道并购的产生。</p>

<p>其六，资本在并购重组中的作用，即虚拟经济的作用。</p>

<p>经过十几年的工业化发展，国民的财富积累已经达到一个新的水平，从绝对量来看，2004年中国的居民储蓄总额已经接近12万亿元，而同期股市的总市值只有4000多亿元，这充分说明从国民财富的角度，股票的购买力是没有问题的，市场缺少的并不是资金，而是好的投资品种。</p>

<p>从前面的分析可以看出，中国与日本的相似之处甚多，日本在股市真正走向繁荣以前，是经过一系列制度建设和产品创新，最后才造就了股市的大繁荣。中国的证券市场从成立至今，不出20年，各种制度也存在需要革新之处，尤其是股权分置，这些都制约着证券市场的长期走势。</p>

<p><img src="http://kobe1941.github.io/images/2020/07/1.png" alt="" /></p>

<p>注——这个图里，唯一不能控制的就是对外贸易，别的国家可以不买你的东西，参考贸易战。</p>

<p>与日本不同的是，中国工业化正逐步迈向成熟阶段，而全球长波周期已经陷入了衰退时期。中国的工业化升级将是在全球经济长波周期衰退阶段进行的，中国工业化成熟阶段的发展挑战要大于日本。从本质上讲，长波衰退是一个总需求下降的过程，而工业化升级是一个新产能不断被创造的过程，即是总供给扩大的过程 。为此，如果中国内部对总供给的吸收能力不能扩大，那中国经济将进一步受长波统治；如果中国能够创造出新的有效需求，那工业化的上升浪将盖过全球衰退的下跌力量，中国还可以保持较高增长。也就是说，工业化升级是中国面临外需萎缩下的根本性的内需拉动战略。</p>

<p>但是需求转变不等于消费将在经济增长中占有主要的地位。一方面，中国的工业化阶段决定了投资仍是未来经济波动的主要推动力，而消费作为稳定的增长部分，从不可能支撑超过6%的增长速度。因此，中国的结构转型从方向上虽然可以总结为由投资向消费的转换，但从未来十年的方向上来看，固定资产投资依然是工业化走向成熟阶段的主导力量。所以，未来资本市场投资仍不会是一个抛弃投资品的年代。2010年之后的高投资将是中国工业化转型的一个必然趋势，中国继续维持较高的投资率和投资增长水平，这是工业化中结构的继承性。</p>

<p><img src="http://kobe1941.github.io/images/2020/07/2.png" alt="" /></p>

<p>值得特别注意的是，中国工业化进程走完起飞阶段之后，中国经济内部的要素发生了悄然的实质性变化。在人力、资本和技术的分析框架下，前两项的负面效应已经开始显现，并且其冲击可能越来越大，归结起来，实际上是两个重大的问题：一是中国的人口结构，即所谓的刘易斯拐点，这是生产要素的本质变化；二是中国的过度刺激政策，即泡沫经济问题。而这两个问题将可能实质性改变中国结构转换的节奏和方向。</p>

<p>过去三十年里，在实现经济增长和参与国际分工的过程中，中国对丰富且廉价的劳动力高度依赖。按照前文的划分，目前的中国和20世纪60年代中期的日本、80年代初期的韩国非常相似，都处于走向成熟的转型关键期。然而特殊的计划生育政策使中国比这两国提前约5～12年遭遇了刘易斯拐点；如果再考虑全球经济长波的影响，则当下的中国正在遭遇的，是三重负面因素的共振。是落入中等收入陷阱，还是继续变革以通往发达之路中国正站在历史的岔道口上。</p>

<p>为了指导投资，我们详细描绘了刘易斯拐点到来之后的经济和社会景象：</p>

<p>（1）三驾马车中将有两驾半受到负面冲击，因此增长的中枢可能下移约1～2个百分点，不过中国并会不缺钱；</p>

<p>（2）由于工资可能全面上调、农产品价格上涨的压力巨大，成本推动下CPI的中枢可能会上移约1个百分点，通胀的问题中期化；</p>

<p>（3）贫富分化的扩大和社会矛盾的积累，使社会问题的集中爆发成为刘易斯拐点到来之后的社会新常态。此时劳方会要求议价权力、以期重分蛋糕，资方会重视提高效率、以期做大蛋糕，于是问题逐步泛政治化这就是我们前面描述的社会景象。</p>

<p>实际上随着劳动力价格的上升及其刚性的存在，劳动力在增长中所分蛋糕的增大，必然带来中国资本收益率的中期下降趋势，净资产收益率的下降可能是一个必可避免的过程，这是一个对市场具有长期影响的问题，值得深入的研究。</p>

<p>中长期，不良贷款集中爆发存在较大可能，中国已经初步展示出泡沫经济的特征。而加息面临两难困境：如果很快进入加息通道，则风险将提前和较大规模暴露；如果不加息，则泡沫可能继续扩大，廉价信贷劣化配置，廉价货币无序流动。即使尽量拖延加息步伐，并采取多种措施遏制和弱化泡沫，也无法回避泡沫经济的成本。结构调整和体制改革的压力和紧迫性，都增大了泡沫经济处置的难度、复杂性和不确定性。</p>

<p>根据熊彼特的理论，中周期的启动，是由企业家的更新改造和提高效率行为所决定的，所以，这与是不是出现技术的创新没有必然联系，而在以往的美国经济周期的观察中，只有装备业和房地产是中周期启动的先导行业，这是一个纯粹的周期中的结构变化问题，但也很难说不涉及经济的大结构变化问题。</p>

<p>熊彼特将引起经济波动的因素分为三类：外部因素、增长因素和创新。外部因素主要指的是革命、战争、灾害、制度变迁、经济政策变化、银行和货币管理、支付习惯以至黄金生产变化等。熊彼特认为，外部因素变化是导致经济波动的一个明显的重要根源，但仅仅从外部因素去探索经济周期的原因是远远不够的。增长因素指人口增长这类不会引起经济波动或周期的因素。</p>

<p>熊彼特强调分析周期问题时应该排除这类非周期因素，但即便排除非周期因素，经济仍呈现周期现象，之所以如此，是因为存在创新活动。</p>

<p>熊彼特将创新一词定义为新的生产函数的建立，即企业家对生产要素的新的组合。按照熊彼特的解释，创新并不是单纯的技术概念，而是经济生产中出现的新事物，也就是说，把一种从来没有过的关于生产要素和生产条件的新组合引入生产体系。包括：</p>

<p>（1）引进新产品或提供某种产品的新质量；</p>

<p>（2）采用新的生产方法；</p>

<p>（3）开辟新的市场；</p>

<p>（4）发掘原料与半成品的新供应渠道；</p>

<p>（5）建立新的企业组织形式，如建立垄断地位或打破垄断地位。</p>

<p>所以，创新与技术上的发明并不是一码事，一般的企业经理不是企业家，只有那些富有冒险精神、勇于率先把创新活动付诸实践的创新者才是在竞争市场中的企业家。在熊彼特看来，作为资本主义灵魂的企业家的职能就是实现创新、引进新组合。所谓经济发展，就是指整个资本主义社会不断实现这种新组合，熊彼特将这种所谓不断地从内部革新经济结构，即不断地破坏旧的、不断地创造新的结构这一过程，称为产业突变，是一种创造性的破坏过程。</p>

<p>创新非连续性和扩散性，才是经济体系内本质的、引起经济周期波动的根源。</p>

<p>创新活动的不连续性使得经济呈现周期波动而非持续繁荣。</p>

<p>如果没有创新带来的繁荣，也就不会衰退，均衡体系也保持原来的状态。这一模型可以简单归纳为：</p>

<p>（1）创新活动使企业家获得利润，创新引起模仿并打破垄断，创新浪潮的出现引起经济繁荣。</p>

<p>（2）而当创新扩展到较多企业，赢利机会趋于消失之后，就面临经济危机。</p>

<p>资本主义经济本质上处于繁荣与危机两个阶段的循环交替之中，一次创新造成的下降不能被下一次创新造成的上升所抵消，于是经济生活就呈现出周期波动。</p>

<p>熊彼特两阶段经济周期模式只有繁荣和衰退，没有复苏和萧条，揭示在创新作用于均衡体系下的一般原理。然而，现实经济体系中，远比这一模型要复杂：外部因素导致经济的非正常波动，但必然会回归均衡，但除了外部因素、增长因素和创新外，还存在许多投机行为，经济波动穿越其长期均衡也是必然，所以，熊彼特提出了四阶段模型：</p>

<p>繁荣→衰退→萧条→复苏，构成了一个完整的、现实的经济周期波动图景。</p>

<p><img src="http://kobe1941.github.io/images/2020/07/3.png" alt="" /></p>

<p>熊彼特认为，经济发展和经济波动的原动力是创新。这种创新期长短是不定的，创新是不连续的、不稳定的和不均匀的，同时又具有多样性，因此对经济发展的影响有所不同，从而形成了不同长度的周期。所以，现实就不可能只存在一种周期形式，不同的周期时长、影响均有不同，因此为了更加形象有效地说明经济周期的规律，熊彼特提出了三周期模型：</p>

<p>第一种是长达50多年的经济长周期，称为长波，因它由俄国经济学家康德拉季耶夫于1926年首先提出，故又称为康德拉季耶夫周期。</p>

<p>第二个周期是9～10年的中周期，称为中波。因其1862年由法国医生、经济学家克里门特·朱格拉在《论法国、英国和美国的商业危机以及发生周期》一书中首次提出。</p>

<p>第三种周期是平均40个月的短周期，称为短波。1923年英国的约瑟夫·基钦从厂商生产过多时，就会形成存货，就会减少生产的现象出发而提出的周期现象，基钦在《经济因素中的周期与倾向》中把这种2到4年的短期调整称之为存货周期，熊彼特将这一周期现象称为基钦周期。</p>

<p>熊彼特认为，一个康德拉季耶夫周期大约包括6个朱格拉中周期和18个基钦短周期；1个中周期中包含约3个短周期。长周期是对中周期起制约作用的因素，并影响着中周期借以发生的背景。中周期的繁荣和萧条的程度，受到长周期的特定阶段的影响。中周期与短周期之间也有类似的关系。</p>

<p>三种周期中的任何一种都与一定的创新活动相联系。尤其是长周期，与重大创新集群有相当密切的关系。而根据雅各布·范杜因的研究结论与熊彼特相呼应，范杜因指出，在长波的不同阶段，创新的倾向是不同的。根据经济学家罗伯逊的研究成果，中周期也与一些特殊工业和特殊创新相联系。至于短周期，虽然从理论上讲也是创新活动的结果，但难以将某个特定的短周期与某项特定的创新活动联系起来。</p>

<p><img src="http://kobe1941.github.io/images/2020/07/4.png" alt="" /></p>

<p>康德拉季耶夫提出观察长波的三个实证模式：</p>

<p>（1）在上升波开始之后和之前，社会经济生活经历着相当大的变化；</p>

<p>（2）与下降波相比，上升波期间伴随着更大量的社会动乱和激烈的变化；</p>

<p>（3）下降波期间伴随着较长和较严重的农业衰退。</p>

<p>至于长波发生的原因，康德拉季耶夫本人并没有做出回答，他只是认为长波是资本主义体系的一个有机的部分，资本主义危机是自我修正的，并且持续的循环，因而是重复的。</p>

<p>基础设施生命周期理论研究者荷兰学者范·杜因认为，基本的创新引起新的工业部门的产生，新的部门需要它们自己的基础设施。但库存的过度积累将会发生。与此同时，在有创新投入的部门中，需求的稳定使资本的过度扩张更为明显。这两种力量结合起来促成了长波中的低迷。而从整体发展来看，这种演变的类型可以用一个五阶段产品生命周期来表示。即革新，成长，成熟，饱和，衰退。长波恰恰是这五个阶段的循环往复。</p>

<p>资本寿命理论：美国经济和管理学家福雷斯特建立了一个精细的美国经济的15个部门系统动态模型，在其中呈现出50年的长波：包括30年的投资，10年的市场饱和，10年的衰退。福雷斯特认为，每一次主要的扩张，围绕着高度一体化和相互支撑的技术合作而进行，特别是运输和能源技术。在发展顺利的时候，拒绝进行创新。这个过程在债务过度和投资过度中达到顶点，随后出现衰退。在衰退中，原有资本被淘汰，也得到充分的更新。而无力偿还贷款和破产也解除了过度的债务负担。在这之后。是下一个重新建立的新时代的来临。</p>

<p>熊彼特将引致经济繁荣归根于企业家的创新活动，而经济过热则归因于由创新扩散的投机活动即所谓的从属波，萧条则是从属波退潮的必然结果。从这一点上，与奥地利学派主张的低利率下不正当投资的兴起和清算带来经济的繁荣与萧条异曲同工。但相较而言，熊彼特更进一步：即便没有从属波，经济也能繁荣，这是奥地利学派所不能解释的。熊彼特承认银行信贷在创新和经济周期中的作用，但因忽略时间偏好而被奥地利学派所诟病（见默里·罗斯巴德《美国大萧条》，P85），熊彼特也并不认同凯恩斯的边际递减率和乘数加速器。货币同样不是经济周期的实质，但作为外生因素，是经济周期的重要根源。</p>

<p>罗斯托的主导产业理论就解释了创新推动经济繁荣的先决条件：</p>

<p>（1）发生在非主导产业的创新活动，并不能带来经济的繁荣。</p>

<p>（2）发生在主导产业的创新活动，才能使得经济脱离长期趋势，迈向繁荣。</p>

<p>（3）有一些创新领域，开始时影响甚微，但有可能会逐渐形成主导产业，称为繁荣的基石，也成为长波的基础。</p>

<p>在范·杜因看来，主要的创新创造了主导产业，而主导产业是处于增长阶段的主要创新生命周期。繁荣阶段是由一个或多个主导产业的强有力增长所支撑的，同样，主导产业也可以挽救经济于萧条阶段，并在下一个上升阶段再次扩张，因此，一个主导产业的生命周期有可能横跨经济的长波周期。通过长波演化和技术创新，我们就能把握主导产业的更替规律。纵观资本主义世界的经济的发展历程，我们不难发现主导产业部门的形成是一种市场的力量，是创新与长波周期运行的必然结果。</p>

<p><img src="http://kobe1941.github.io/images/2020/07/5.png" alt="" /></p>

<p><img src="http://kobe1941.github.io/images/2020/07/6.png" alt="" /></p>

<p><img src="http://kobe1941.github.io/images/2020/07/7.png" alt="" /></p>

<p>长波回升阶段对替代投资不断增大的需求将使萧条阶段的悲观主义转为更为令人乐观的经济前景，进入创新活跃期，产品创新频繁，产生新产业部门的创新出现的概率更大，节约成本的工序创新并不迫切。</p>

<p>长波繁荣期，由于需求扩张，往往是技术大规模产业化的阶段。长波繁荣时，没什么动力能够促使企业进行冒险的产品创新活动，降低成本、增强竞争力的工序创新占主导。基础部门的创新通常是在对最终需求增大所做出的反应，在生产货物部门由需求导致的创新将主要在长波扩张阶段被采用。</p>

<p>在长波衰退，新技术已变成成熟产业，产品逐渐趋向于饱和，对经济的积极影响逐渐削弱。总体而言，是四个长波阶段中是最不活跃的，尤其是产品创新最不活跃。</p>

<p>而长波萧条期，产品过剩，销售下降，经济面临着沉重打击，创新生命周期亦随之进入下降阶段。对现有产品需求出现饱和，出现了除进行技术创新和创造新的部门外，根本无法解决所谓门斯的技术僵局。只有创新才能克服萧条，创新主要发生在现有工业部门的产品和工序创新上。</p>

<p>对当前而言（指2009年左右），全球处于长波衰退（2007年以后进入长波衰退阶段）阶段，根据范·杜因创新生命周期规律，是创新最不活跃的阶段。最主要的创新是以提升效率的工序创新（管理创新），革命性的产品创新仍处于孕育或萌芽阶段，未来的主导产业仍然朦胧而不可捉摸。</p>

<p>罗斯托在学术上最重要的研究成果是提出经济成长阶段的理论。他试图用经济理论解释经济历史的进程，把社会发展分为必须依次经过的6个阶段：传统社会阶段、起飞准备阶段、起飞进入自我持续增长的阶段、成熟阶段、高额群众消费阶段和追求生活质量阶段。他用这种理论代替马克思对人类社会历史发展阶段的划分。他确信他的理论解释了西方各国已经历过的工业化过程，提示了一个国家在经济成长过程中所要遇到的一系列战略决策问题。</p>

<p>范*杜因以熊彼特技术长波论为基础，提出了用创新生命周期解释长期波动的长波理论。认为任何一次基础技术创新都要经历四个阶段。</p>

<p>第一阶段是基础技术创新的介绍阶段。这一阶段的特征：对旧产品、旧技术的投资日益减少，新产品和新技术已出现，但还未被公认。</p>

<p>第二阶段是扩散阶段。特征：新产品，新技术得到广泛承认，投资有丰厚的利润，风靡一时，逐步形成新的产业部门。</p>

<p>第三阶段是基础创新的成熟阶段。特征：新产业的发展达到顶峰，基础技术创新日趋成熟。</p>

<p>第四阶段是衰落阶段。特征：新兴产业已饱和，生产能力和产品出现过剩，投资萎缩，原来的新产品、新技术变得过时。</p>

<p>范·杜因认为，由于中观经济层次的创新生命周期有四个阶段，影响宏观经济层次的长期波动也出现相应的四个阶段，即复苏、繁荣、衰退、危机。繁荣和衰退在一起形成长波的上升阶段，危机和复苏一起构成长波的下降阶段。一般大的基础技术创新的成长阶段约为20年，扩散阶段约20年，生命周期约半个世纪或稍长。</p>

<p>二战后日本主导产业的选择：电力→重化工业→耐用消费品→信息技术</p>

<p>中国主导产业的历史选择：纺织→电气→通信计算机、汽车→信息技术</p>

<p>早在2008年我们就曾经指出，中国经济和社会将进入制度变革期，而这种制度变革是由投资模式不可维系所推动的。但我们认为，这种制度变革的核心是分配问题，迄今为止，我们并没有看到此问题有实质性的进展，反而主导原有分配模式的旧的增长方式还在不断地膨胀中。改革必然需要经济波动的推动，创造性毁灭是经济周期运动的根本动力，2015年之后的中国经济和改革，就是不破不立。</p>

<p>康波的长度其实是一个甲子。而对于一个人的一生来讲，其出生在康波的那个时点，就注定了人一生的经济轨迹。某种意义上看，人生的财富由康波注定，因为康波的本质表现是价格的波动，而人生的财富积累根本还是来源于资产价格的投资或投机，人生发财必然是靠康波，康波就是人生的财富规划。</p>

<p><img src="http://kobe1941.github.io/images/2020/07/8.png" alt="" /></p>

<p>在康波的繁荣阶段，往往是高速增长与低通胀伴随，这可以解释为新的技术提高了效率，高增长并没有引发资源约束。</p>

<p>从康波的形态来看，最复杂的就是衰退阶段，一般来讲，衰退阶段首先都会出现一个标志性的经济危机，比如第四波康波的19711973年布雷顿森林货币体系崩溃，2008年美国的次贷危机，事实上都确认了康波进入衰退阶段。</p>

<p>长鞭效应其基本含义是：当供应链上的各节点企业只根据来自其相邻的下级企业的需求信息进行生产或者供应决策时，需求信息的不真实性会沿着供应链逆流而上，产生逐级放大的现象。当信息达到最源头的供应商时，其所获得的需求信息和实际消费市场中的顾客需求信息发生了很大的偏差。由于这种需求放大效应的影响，供应方往往维持比需求方更高的库存水平或者说是生产准备计划。</p>

<p>全球化分工并不改变周期的秩序，自英国工业化以来，就不断有新的国家和人口被纳入资本主义体系，但这并不改变周期波动的本质，从康波意义上讲，更多的人口加入资本主义体系之后，波动不是减小了，反而是放大了。</p>

<p><img src="http://kobe1941.github.io/images/2020/07/9.png" alt="" /></p>

<h2 id="section-1">第二部分  大类资产配置</h2>

<p>在金融投资全球化的时代，如果不考虑汇率问题而直接照搬美林投资时钟，就好比在用一个没有经过时区调整的进口表来直接指导自己的工作作息，出现节奏错乱势成必然。</p>

<p>商品价格既取决于全球周期趋势，更取决于主要经济体周期节奏之差。</p>

<p><img src="http://kobe1941.github.io/images/2020/07/10.png" alt="" /></p>

<p>以我们看来，美林时钟理论可以作为大类资产配置的基础，但必须进行改造，从而建立一套完善的全球大类资产配置的方法。在这方面，我们认为至少有几件事情可以做。其一，加入全球因素，加入全球因素的第一步，是加入美元，而美元主要是研究欧美相对强弱问题。其二，加入全球因素的第二步，是加入中国，中国与欧美的关系是基于房地产周期反身性的关系。第三，加入康波因素，将时间钟置于不同康波阶段进行分别配置。第四，分清中周期和库存周期对大类资产配置的不同影响，从道落实到术。本篇报告先做第一步，即加入美元因素。</p>

<p>从历史上看，每次美元大幅升值都要影响一些国家。19801985年的升值伤害了拉美，20世纪90年代的升值拖累了日本。我国有大量的外汇储备，在正常条件下，美元短时间、低幅度的升值对于我国经济冲击不大。但如果我国本身处于增长中枢下移的去泡沫过程中，美元长时间、较大幅度的升值可能引发共振，加速我国经济中泡沫的破灭。</p>

<p>资本的本质是增值，货币是资本的一种形态。如果世界各地都没有好的投资机会，货币不会形成方向性流动。以前，虽然我国经济中存在的风险相对较高，但较高的收益率还是留住了很多资本。但当我国去泡沫，经济不景气之时，美元的持续升值，必然吸引资本向美国流动。这就会导致资产价格下降，加速去泡沫的过程。</p>

<p>即使那时人民币采取跟随美元走势的策略，但因为投资美国的风险明显小于中国，海外资金也会选择流向美国而不来中国。而原来待在中国的，也会有部分资金选择去美国。所以，如果美元升值与中国去泡沫过程共振，中国经济在未来两年内的情况会非常不乐观。</p>

<p>我一直认为，对大部分工业化人口群体而言，人生的财富由康波所决定，而在大宗商品、黄金、地产、艺术品和股票四类资产中，大宗商品的价格波动最具有长周期的意义，而且是最为暴利的资产。所以，对大宗商品底部的研究，具有战略意义。</p>

<p><img src="http://kobe1941.github.io/images/2020/07/11.png" alt="" /></p>

<h3 id="section-2">拓展阅读：</h3>

<ol>
  <li><a href="https://m.gelonghui.com/p/330433">周金涛的“2019大预言”，为何落空了？</a>——格隆汇</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《聪明的投资者》]]></title>
    <link href="http://kobe1941.github.io/blog/the-intelligent-investor.html"/>
    <updated>2020-06-21T09:40:49+08:00</updated>
    <id>http://kobe1941.github.io/blog/the-intelligent-investor</id>
    <content type="html"><![CDATA[<p>整体上非常棒的一本书，对证券投资的各种方式和利弊进行了系统性的介绍，还针对不同风格的人群，比如防御型或积极型投资者，给出了不同的建议。对市场波动，安全边际的讲解非常有价值。</p>

<!--more-->

<h3 id="section">解读巴菲特序言  刘建位</h3>

<p>格雷厄姆建议防御型投资者要遵守四大选股原则：适当分散投资10到30只股票；选股票要选大型惬意、杰出企业、融资保守的企业；股息持续发放20年以上；市盈率不超过25倍。</p>

<p>事实上对于业务投资者来说，这样操作还是有些复杂。1976年，指数基金问世，一切都简单了。</p>

<p>巴菲特从不推荐买入任何股票，过去20年却10次推荐指数基金。</p>

<p>进攻型（积极型、进取型）投资者的最核心特征是，愿意花费大量时间和精力，选择比一般证券更加稳健可靠而且潜在回报更有吸引力的证券。</p>

<p>格雷厄姆根据自己超过50年的证券投资经验，加上自己走的很多研究，向进攻型投资者推荐以下三种投资策略：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class=""><span class="line">第一种策略是购买相对不受市场追捧的大公司股票；
</span><span class="line">
</span><span class="line">第二种策略是买进被严重低估的便宜货股票；
</span><span class="line">
</span><span class="line">第三种策略是特殊情况或者破产债务重组股票套利。
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>三种策略彼此有很大不同，每一种策略都要求实践者具备不同类型的知识背景和情绪性格。</p>

<p>格雷厄姆本人是买便宜货股票为主，特殊情况套利为辅。巴菲特早期完全模仿格雷厄姆，但是后来他发现，非常低估的便宜货股票后来变得很少，于是转向第一种策略，购买相对不受市场追捧的大公司股票。</p>

<p>巴菲特后来总结自己的选股之道是寻找超级明星股：“我们始终在寻找那些业务清晰易懂、业绩持续优异、由能力非凡并且为股东着想的管理层来经营的大公司。”。</p>

<p>基于安全边际进行价值投资，用巴菲特的话来说就是：“用4毛钱的价格去购买价值1元钱的股票”。</p>

<p>其实价值投资就是逆向投资，在股市过于低估时买入，而在股市过于高估、安全边际太小甚至消失时卖出。这正符合格雷厄姆所说的，做些与众不同有新意的趣事。</p>

<p>一句话概括，要想投资成功，一要智商，二要情商。智商不是聪明，而是正确的思考框架；情商不是战胜别惹，而是战胜自己。要一生投资成功，只需要两个因素——有一个正确合理的思考框架让你能够做出正确的投资决策；有一种能力让你控制住自己的情绪以避免情绪破坏这个思考框架。</p>

<p>建议投资者学习格雷厄姆，做好三件事：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class=""><span class="line">1.做些傻事，防御型做分散投资，定期定额投资指数基金；
</span><span class="line">
</span><span class="line">2.做些趣事，进攻型做价值投资，强调安全边际；
</span><span class="line">
</span><span class="line">3.做些好事，帮助别人，成就自己，利人利己。
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="section-1">第四版序  巴菲特</h3>

<p>要想在一生中获得投资成功，并不需要顶级的智商、超凡的商业头脑或内幕消息，而是需要一个稳妥的知识体系作为决策基础，并且有能力控制自己的情绪，十七不会对这种体系造成侵蚀。本书能够准确和清晰的提供这种知识体系，但对情绪的约束是你自己必须做到的。</p>

<p>如果你遵从格雷厄姆所倡导的行为和商业准则（而且如果你重点关注第8张和第20章给出的极为宝贵的建议），那么，你将会获得不错的投资结果。</p>

<h3 id="section-2">格雷厄姆生平简介</h3>

<p>格雷厄姆的这本《聪明的投资者》，则是有史以来第一本面向个人投资者并为其提供投资成功所需的情绪框架和分析工具的专业书籍。</p>

<p><strong>格雷厄姆建立的核心原则：</strong></p>

<p>1.股票并非仅仅是一个交易代码或电子信号，而是表明拥有一个实实在在的企业的所有权；企业的内在价值并不依赖于其股票价格；</p>

<p>2.市场就像一只钟摆，永远在短命的乐观和不合理的悲观之间摆动。聪明的投资者是现实主义者，他们向乐观主义者卖出股票，并从悲观主义者手中买进股票；</p>

<p>3.每一笔投资的未来价值是其现在价格的函数。你付出的价格越高，你的回报就越少；</p>

<p>4.无论如何谨慎，每个投资者都免不了会犯错误。只有坚持格雷厄姆的所谓安全性原则——无论一笔投资看起来多么令人神往，永远都不要支付过高的价格——你才能使犯错误的几率最小化；</p>

<p>5.投资成功的秘诀在于你的内心。如果你在思考问题时持批判态度，不相信华尔街的所谓事实，并且以持久的信心进行投资，你就会获得稳定的收益，即便在熊市亦如此。通过培养自己的约束力和勇气，你就不会让他人的情绪波动来左右你的投资目标。说到底，你的投资方式远不如你的行为方式重要。</p>

<h3 id="section-3">导言  本书的目的</h3>

<p>本书的目的，是为普通人在投资策略的选择和执行方面提供相应指导。相比较而言，本书很少谈论证券分析的技巧，而将注意力更多的集中于投资的原理和投资者的态度方面。</p>

<p>这并不是一本教人“如何成为百万富翁”的书。在华尔街，就像在其他任何地方一样，并没有一条可靠和简单的致富之路。</p>

<p>防御型（被动型）投资者的首要目的是避免重大错误或损失；其次则是不必付出太多的努力、承受太大的烦恼去经常性的作出投资决策。</p>

<p>进取型（积极型或激进型）投资者的主要特点是，他们愿意为挑选合理且更具吸引力的股票而付出时间和经历，以获取超出平均水准的回报。</p>

<p>长期以来，有一种流传甚广的观点认为：成功的投资技巧首先在于找出未来最有可能增长的行业，然后再找出其中最有前途的公司。但是：</p>

<p>1.某一行业显而易见的业务增长前景，并不一定会为投资者带来显而易见的利润。</p>

<p>2.即使是专家，也没有什么可靠的方法，能使其挑出前景光明的行业中最有前途的公司，并将大量的资金投入该股票。</p>

<p>在笔者的基金经理生涯中，从未遵循过这种方法，因此，我不能向那些企图尝试此种方法的人士，提供任何具体的建议或鼓励他们这样做。</p>

<p>本书的宗旨在于，指导读者避免陷入严重的错误，并建立一套令其感到安全放心的投资策略。我们将以较大的篇幅讨论投资者的心理问题。因为，实际上，投资者的最大问题甚至是最可怕的敌人，很可能就是他们自己。</p>

<p>我们力图使读者在其投资决策方面，形成一种恰当的心智和情绪。我们已经看到，那些情绪适合于投资活动的“普通人”，比那些缺乏恰当情绪的人，更能够转去钱财，也更能够留住钱财，尽管后者拥有更多的金融、会计和股票市场知识。</p>

<p>投资艺术具有一种并不广为人知的性质。普通投资者只需付出很小的努力和具备很小的能力，就可以取得一种可靠（即便并不壮观）的成果；但是，要想提高这一可轻易获得的成果，却需要付出大量的努力和非同小可的智慧。</p>

<p>深思熟虑的投资方法，是稳固建立在安全边际原则基础上的，这种方法能够为我们带来可观的收益。</p>

<p>读者须知，本书针对的不是储蓄者和投资者所面临的总体财务策略，它只针对那些准备投入交易证券的资金，即投入债券和股票的资金。本书中的现在，指的是1971年年底或者1972年年初。</p>

<p>要想成为一个聪明的投资者，重要的是性格而不是智力。</p>

<h3 id="section-4">第 1 章 投资与投机：聪明投资者的预期收益</h3>

<p>投资操作是以深入分析为基础，确保本金的安全，并获得适当的回报；不满足这些要求的操作就是投机。</p>

<p>防御型投资者只应购买那些长期具有盈利记录和强有力的财务状况的重要公司的股票。</p>

<p>激进型投资者必须首先搞清楚，什么样的行动方针能提供合理的成功机会，什么样的行动方针是无法成功的。</p>

<p>要想能够持续并合理的获得优于平均业绩的机会，投资者必须遵循以下两种策略：</p>

<p>1.具有内在稳健性和成功希望的策略；</p>

<p>2.在华尔街并不流行的策略。</p>

<p>要想通过买入一只受到忽略因而被低估的股票赚钱，通常需要长期的等待和忍耐。</p>

<p>人类所有的不快乐，均来自一个原因：不知道如何安静的待在家里。——布莱斯*帕斯卡尔</p>

<p>投资操作是建立在透彻分析的基础之上的，目的是要保证本金的安全并获得适当的回报：</p>

<p>1.在你买进一只股票之前，要对该公司及其基础业务的稳妥性进行彻底分析；</p>

<p>2.你必须细心的保护自己，以免遭受重大损失；</p>

<p>3.你只能期望获得适当的业绩，不要期望过高。</p>

<p>在进行投机时，你必须像有经验的赌徒走进赌场时的那样：</p>

<p>1.投机就是投机，千万不要以为自己是在投资；</p>

<p>2.如果把投机看得太认真，它就会变得十分危险；</p>

<p>3.你必须严格限定你的赌注。无论如何，永远不要使投入赌资账户的资产超出10%。</p>

<h3 id="section-5">第 2 章 投资者与通货膨胀</h3>

<p>根据历史数据，通货膨胀率的高低对公司每股收益并没有任何直接影响。确凿的数据表明个，过去20年道琼斯成分股所有大幅增长的利润，都来自于利润再投资所形成的投资资本的大幅增长。</p>

<p>股票市场认为，公用事业公司是通货膨胀的最大牺牲者。一方面，其债务成本大幅上升；另一方面，由于价格管制的存在，其服务价格很难提高。但这里应该说明的是，电力、天然气和电信服务的单位成本的增长，要远低于同期价格指数的增长，从而使这些公司在未来处于很强的战略地位。</p>

<p>购买并持有黄金，是世界各地通话膨胀保值的标准策略。</p>

<p>我们只能对投资者提出以下忠告：“在介入之前，首先要确定自己是熟悉这一领域的”。</p>

<h3 id="section-6">第 3 章 一个世纪的股市历史：1972年年初的股价水平</h3>

<p>试图对当前股市水平做出完整和敏锐的判断是很困难的。</p>

<p>聪明的投资者决不能只靠过去的推测来预测未来，这是格雷厄姆的一个核心观点。</p>

<p>格雷厄姆的答案，总是来自于逻辑分析和常识判断。任何投资的价值都是而且必定永远依存于你的买入价格。既然公司能够挣到的利润是有限的，投资者为其支付的价格就应当适可而止。</p>

<p>格雷厄姆在本章中给出的警示十分健民：“根据物极必反的规则”，投资者越看好股票市场的长期走势，他们短线出错的可能性就越高。</p>

<p>股票市场的走势依赖于以下三个要素：</p>

<p>1.实际的增长（公司利润和股息的增加）；</p>

<p>2.通货膨胀的增长（物价的总体上涨）；</p>

<p>3.投机活动的增长或下降（投资大众对股票兴趣的上升或下降）。</p>

<p>历史告诉我们的唯一无可争议的真理，就是未来总会出乎我们的意料，永远是这样。</p>

<h3 id="section-7">第4章 防御型投资者的投资组合策略</h3>

<p>如果你不能承受风险，就应当满足于较低的投资回报——这是一个由来已久，且听起来十分合理的原则。由此可以得出这样的结论：投资者能够期望的回报，在一定程度上是与其承担的风险成正比的。对此，我们不能苟同，投资者的目标收益率，更多的是由他们乐于且能够为其投资付出的智慧所决定的：图省事且注重安全性的消极投资者，理应得到最低的报酬，而那些精明且富有经验的投资者，由于他们付出了最大的智慧和技能，则理应得到更大的回报。</p>

<p>积极和被动的投资方式同样明智，无论采取何种方式均可取得成功。但前提是，你必须对自己有深入的了解，从而采用适合自己的方式，并在自己的整个投资生涯中坚持下去，而且善于控制自己的投资成本和情绪。</p>

<p>格雷厄姆对主动投资和被动投资的区分再次提醒我们，财务风险并非只存在于大多数人所关注的地方（经济形势和投资品种），而且也存在于我们的内心。</p>

<p>防御型投资者应当怎样入手呢？首先，而且是最基本的决策是，确定股票投资与债券和现金的分配比例。</p>

<p>无论你多么年轻，你都可能会突然需要一大笔钱——不是在40年以后，而是在40分钟以后。在毫无先兆的情况下，你可能会失业、离婚、疾病等等意外。这些意外会突袭人和人，不管其年龄几何。每个人都应当将其资产的一部分，以现金的形式存放在无风险的安全地方。</p>

<p><img src="http://kobe1941.github.io/images/2020/06/1.png" alt="" /></p>

<p>一旦你确定了资产配置的最终比例，就不要轻易改动，除非你的生活状态出现了重大变化。既不要因为股市的上涨而加大其投资比例，也不要因为其下跌而更多的卖出。用约束取代猜想，这正是格雷厄姆投资法的精髓。</p>

<p><img src="http://kobe1941.github.io/images/2020/06/2.png" alt="" /></p>

<p>债券基金可以方便、廉价的提供分散化的好处；而且可以每月拿到利息收入，然后按照现行利率将其再投入该基金，且不收手续费。对于一般投资者来说，债券基金显然要优于直接购买单个债券。</p>

<p>如果某只年金会给卖方带来丰厚的佣金，它就不可能给买方带来好的收益。</p>

<p>优先股是身兼两种缺点的投资。一是安全性不如债券，如果公司破产，其偿还权排在债权人之后。二是获利潜力低于普通股，因为如果利率下降或公司信用级别改善，发型公司通常会“赎回”或强行回购这些优先股。问问你自己：如果这样的公司足够健康、值得我们投资，它为什么要发型优先股，为之支付高额的红利，而不发型债券并享受其带来的减税好处呢？其答案很可能是，该公司的财务状况不够健康，市场对其债券没有胃口。</p>

<p>一个聪明的投资者，不论多么渴望获得股息，都不会只为了股息而购买一只股票；标的公司及其业务必须足够坚实强劲，其股价必须足够合理。即便是最保守的投资者，也应该意识到，在全部持有债券或以债券为主的投资组合中，有选择的加入一些股票，会增加其收益率，并提升整个组合的潜在回报。</p>

<h3 id="section-8">第 5 章 防御型投资者与普通股</h3>

<p>普通股的两个优点：</p>

<p>①股票很大程度上使投资者得以免受通货膨胀的损失，而债券却完全不能提供这种保护；</p>

<p>②它可为投资者提供较高的多年平均回报；这不仅来自其较优质债券利息更高的平均红利水平，也来自因未分配利润的再投资而产生的市场价值上扬的长期趋势。</p>

<p>对于防御型投资者而言，挑选普通股是一件相对容易的事情。在此我们给出四项可遵循的规则：</p>

<p>①适当但不要过分的分散化，你的持股数应限制在最少10只，最多20只不同的股票之间。</p>

<p>②你挑选的每一家公司应该是大型的、知名的，在财务上是稳健的。这些形容词必然会有一定的含糊性。但其基本意义是十分清楚的。关于这一问题的进一步讨论见本章的结尾部分。</p>

<p>③每一家公司都应具有长期连续支付股息的历史。</p>

<p>④投资者因将其买入股票的价格限制在一定的市盈率范围，其参照的每股收益，应取过去7年的平均数。我们认为，针对这一平均数，其市盈率应控制在25倍以内；如果是过去12个月的利润，则应控制在20倍以内。但这一限制会把所有最强势且最受欢迎的股票，排除在我们的投资组合之外。实际上，这将把几乎所有的“成长股”都排除在外，而这些股票正是过去若干年来股市的最爱，无论是投机者还是投资者均对其趋之若鹜。为此，我们必须对这种彻底的排除给出理由。</p>

<p>所谓成长股，是指那些在过去每股收益增长显著超过所有股票的平均水平，并且预计未来仍将如此持续下去的股票。</p>

<p>对于防御型投资者来说，成长股的不确定性过高、风险性过大。当然，如果股票选对了，买入的价格适当，并且在巨大的上涨之后，可能的下跌出现之前将其卖出，则会出现奇迹。但是对于一般投资者而言，这种事情是可遇不可求的。</p>

<p>对于一个年轻的投资者来说，及早开始自己的投资教育和实践是很有利的。如果他以进取型投资者的方式进行操作，肯定会犯一些错误，并遭受某种程度的损失。年轻可以承受这些失败，并从中获益。我们奉劝那些初学者：不要把自己的精力和金钱浪费在试图战胜市场上。他们应当对证券的价值加以研究，并以尽可能小额的资金，对自己在价格和价值方面的判断进行尝试性校验。</p>

<p>就真正的投资者而言，单是市场价格的下跌，并不会导致他的亏损。</p>

<p>你应该有多大的防御型，这并不取决于你对风险的容忍程度，而是取决于你愿意在自己投资组合方面花多少时间和精力。</p>

<p>你是否应继续拥有股票，与几年前拥有的股票给你带来了多大的损失并无关系。如果股票的价格已经变得相当合理，足以使你的财富今后得以增值，那你就应当购买它们，而不论其是否曾令你在不久前亏损过。</p>

<p>防御型投资者是靠冷静和耐心成为最后赢家的。</p>

<p>最为理想的美元成本平均法（相当于定投）是投资于一组指数基金，从而将所有具有投资价值的股票和债券都一网打尽。</p>

<h3 id="section-9">第6章 积极型投资者的证券组合策略：被动的方法</h3>

<p>进攻型或积极型投资者首先要遵循的策略，应该与防御型投资者基本相同，即以合理的价格，将其资金分别投入高等级债券和高等级普通股。</p>

<p>仅仅为了每年多得到1%或2%的利息收益，而承受本金损失的做法，显然是一个糟糕的商业决定。如果你愿意承担一定的风险，你必须确定能够在票面价值上获得实实在在的收益——如果经济走势不错的话。</p>

<p>短线交易，即持有股票的时间在几小时左右，是有史以来人类发明的最佳自杀武器。你的某些交易会赚钱，你的大多数交易会赔钱，但你的经纪人却永远会从中获利。</p>

<p>不要急于操作，耐心等待即可。所有人都要认识到，所谓“长期投资者”是一个啰嗦的说法。只有长期投资者才是真正的投资者。持股时间连几个月都达不到的人，最终不可能成为获胜者，而将成为牺牲品。</p>

<p>只有当你可以廉价的拥有一家理想的企业时，才能买进那只股票，无论有多少其他人想购买这只股票。</p>

<h3 id="section-10">第 7 章 积极型投资者的证券组合策略：主动的方法</h3>

<p>根据定义，积极型投资者将花相当多的注意力和精力，来获得比普通投资更好的结果。</p>

<p>成长股的定义是：不仅过去的业绩超过了平均水平，而且预计将来也会如此。</p>

<p>根本没有理由使人相信，一个智力一般的投资者（即使投入了大量的精力）购买成长股的结果，会好于专门在这一领域投资的基金公司。显然这些机构可以利用更多的智慧和更好的研究手段。因此，我们不赞成积极投资者通常所从事的成长股投资。在这种投资领域，极好的未来前景已经完全被市场发现了，而且已经通过当期较高的市盈率得到的反映。</p>

<p>成长股这一类股票的一个显著特点，就是其市场价格的波动幅度一般较大。</p>

<p>为了在长时间内获得比一般投资更好的结果，一种选择或操作策略必须具备两项优势：</p>

<p>1.它必须能达到基本稳健所要求的客观或合理标准；</p>

<p>2.它必须有别于大多数投资者或投机者采用的策略。</p>

<p>与其他公司相比，大公司有两个优势。首先，它们可以借助于资本和人力资源来度过难关，并重新获得令人满意的利润。其次，市场有可能对公司表现出的任何改善做出较为迅速的反应。</p>

<p>如果能按较好的价格购买到某家大公司的股票，那么这种暂时性的不受欢迎可以给你带来持久的财富。</p>

<h3 id="section-11">第8章 投资者与市场波动</h3>

<p>如果你想投机的话，请睁大自己的双眼，知道最终有可能亏本，请确保将风险额度控制在一定范围内，并将投机与你的投资计划完全分开。</p>

<p>如果投资者以预测为基础强调择时交易，那么他最终将成为一个投机者，并要面对投机所带来的财务结果。</p>

<p>“聪明的投资者”的传统定义是，那些在熊市（其他的人都在卖出时）买入，在牛市（其他的人都在买入时）卖出的人。</p>

<p>几乎所有的牛市都明显具备一些共同点，比如：价格水平达到历史最高；市盈率很高；与债券收益相比，股息收益较低；大量的保证金投机交易；有许多质量较差的新普通股的发行。</p>

<p>一位真正的投资者不太可能相信，股市每日或每月的波动会使自己更富有或更贫穷。但是，长期的和大幅度的波动会怎样呢？在此会产生一些现实问题，也有可能产生一些更复杂的心理问题。市场的大幅上升，会立即给人们带来适当的满足感以及谨慎的担忧，同时也会使人产生强烈的不谨慎冲动。</p>

<p>正是出于对人性的考虑（而不是出于对财务损益的考虑），我们才主张在投资者的证券组合中采用某种机械的方法，调整债券与股票之间的比重。这种方法的主要好处就在于，它使得投资者有事可做。这些交易活动将提供某种通道，以释放投资者有可能不断累积的能量。作为一名真正的投资者，他还能从下列想法中获得满足感：自己的业务操作与普通大众的正好相反。</p>

<p>从根本上讲，价格波动对真正的投资者只有一个重要意义，即当价格大幅下跌后，给投资者买入的机会，反之亦然。在除此之外的其他时间里，投资者最好忘记股市的存在，更多的关注自己的股息回报和企业的经营结果。</p>

<p>投资者和投机者之间最现实的区别，在于它们对待股市变化的态度。投机者的主要兴趣在于预测市场波动，并从中获利；投资者的主要兴趣在于按合适的价格购买并持有合适的证券。</p>

<p>我们并不认为，投资者非要等到市场价格最低时才去购买，因为这可能要等很长时间，很有可能造成收入损失，并且也有可能错失投资机会。总体上讲，投资者较好的办法是，只要有钱投资于股票，就不要推迟购买——除非整体市场水平太高，而不符合长期以来所使用的价值标准。</p>

<p>股东会根据所获股息以及市场平均价格的长期趋势，判断自己的投资是否成功。这一标准应该同样可以用来检验企业管理层的效果，以及企业管理层对企业所有者的态度是否恰当。好的管理层会带来好的市场平均价格，差的管理层会带来不好的市场平均价格。</p>

<p>投资的全部意义并不在于所赚取的钱比一般人要多，而在于所赚取的钱足以满足自己的需要。衡量自己的投资是否成功的最好办法，不是看你是否胜过了市场，而是看你是否拥有一个有可能是自己达到目标的财务计划和行为规范。最终，重要的不在于你比他人提前到达终点，而在于确保自己能够达到终点。</p>

<p>神经科学领域新的突破性研究表明，我们的大脑天生会去感知趋势，即使趋势并不存在。只要一件事连续发生两三次，人类大脑就会自动的预感它会再次发生。如果的确再次发生，一种名叫多巴胺的天然化学成分就会释放出来，从而使你的大脑充斥着一定程度的快感。</p>

<p>心理学家已经证明，资金亏损所带来的痛苦程度，是等额盈利所带来的快感程度的两倍。</p>

<p>无论如何，对想要做长期投资的人来说，股价的不断下跌是好消息，并不是坏消息，因为这使得它们可以花较少的钱，买到更多的股票。股价下降的时间越长、幅度越大，而且你在它们下降时不断的买入，那么最终你赚的钱就会更多——如果你能够一直坚持到最后。不要害怕熊市，而应该欢迎熊市。</p>

<h3 id="section-12">第 9 章 基金投资</h3>

<p>投资基金的经历在寻求更好的业绩时，会涉及一些特殊风险。迄今为止，所有的金融经历都表明，管理稳妥的大基金几年之内至多能获得稍微高于平均水平的业绩。如果不对它们加以稳妥管理，就会产生这样的情况：暂时获得惊人的虚幻利润，随后必然遭遇灾难性的损失。</p>

<p>几乎所欲的共同基金或开放式基金（其持有者有权按资产组合每天的估价来兑现其股份），都有相应的新股发售机制。这就意味着它们的规模大多都会随着时间的延长而扩大。封闭式基金公司有固定的资本结构，因此按美元衡量的相对比重在下降。</p>

<p>金融专家对共同基金的研究持续了至少半个世纪，而且他们几乎一致赞同如下几点：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class=""><span class="line">1.一般的基金，不可能通过承担研究和交易成本来挑选好的股票；
</span><span class="line">
</span><span class="line">2.基金的费用越高，其回报越低；
</span><span class="line">
</span><span class="line">3.基金股份交易越频繁，其赚钱的机会越小；
</span><span class="line">
</span><span class="line">4.高度不稳定的基金（比平均水平上升和下降幅度更大），有可能长期处于不稳定状态；
</span><span class="line">
</span><span class="line">5.过去回报很高的基金，今后不可能长时间称为赢家。
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>根据以往的回报挑选出未来的最优秀基金的机会非常之小。</p>

<p>为什么许多获胜的基金不能继续保持下去？</p>

<p>基金经理跳槽；资产过度膨胀；高超的技巧不复存在；费用上升；羊群行为。</p>

<p>一旦某只基金获得成功，基金经理就习惯于变得胆小和模仿他人。随着基金的扩大，其费用收益会更加客观，从而使得经理们安于现状。</p>

<p>从长远看，指数基金将胜过大多数基金。指数基金极地的管理费用使其具有不可比拟的优势。指数基金只有一个显著的缺陷：比较令人乏味。你将无法在野餐桌上向人们吹嘘，自己如何拥有全国最好的基金。</p>

<p>在自己的晚年，格雷厄姆称赞指数基金为个人投资者的最佳选择。</p>

<p>一些战胜指数基金的基金的共同特点：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class=""><span class="line">1.它们的经理都是一些最大的股东。当基金经理为基金股份的最大所有者时，基金经理与基金投资者之间的利益最大化冲突就能得到缓解。
</span><span class="line">
</span><span class="line">2.它们费用低廉。
</span><span class="line">
</span><span class="line">3.它们敢于与众不同。
</span><span class="line">
</span><span class="line">4.它们不接纳新的投资者。最佳的基金经常会拒绝接纳新的投资者，而只允许已有的股东购买更多的股份。这就阻止了新的基金购买者蜂拥而入，以免基金承受资产膨胀之痛。
</span><span class="line">
</span><span class="line">5.它们不做广告宣传。最佳的基金经理，通常是那些似乎不想赚你钱的人。
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>对于基金来说，正如我们所看到的，昨天的赢家往往会成为明天的暑假。但是研究者已经证明，有一点是几乎肯定的：昨天的暑假几乎从未成为明天的赢家。因此，不要购买以往业绩一直都很差的基金，尤其是当它们的年费高于平均水平时。</p>

<p>什么时候应该出售基金呢？</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class=""><span class="line">
</span><span class="line">1.交易策略突然发生急剧改变。
</span><span class="line">
</span><span class="line">2.费用上升，这说明基金经理正在肥自己的腰包。
</span><span class="line">
</span><span class="line">3.过度交易导致经常出现大量税单。
</span><span class="line">
</span><span class="line">4.突然产生异常回报，比如当以前的稳健基金遭受巨大亏损时（或者甚至出现惊人的回报时）。
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>正如投资顾问查尔斯*埃利斯所说的：“如果你不准备呆在婚姻里，就不应该去结婚。”基金投资也是一样的。如果你不准备经受基金所带来的至少3年的亏损，你首先就不应该购买基金。耐心是基金投资者唯一重要的伙伴。</p>

<h3 id="section-13">第 10 章 投资者与投资顾问</h3>

<p>投资建议可以从多种渠道获得。它们包括：拥有证券方面知识的亲属或朋友；当地的商业银行家；经纪公司或投资银行；金融服务机构或金融期刊；投资顾问。这一系列繁杂的来源表明，在投资者的心目中，目前还没有一个逻辑化的或系统化的方法。</p>

<p>真正专业的投资顾问（收取较高年费的著名投资咨询公司），在其承诺和建议方面都是相当保守的。</p>

<p>主要的投资顾问公司并不声称自己比别人英明，它们引以为豪的地方在于细心、稳健和称职。它们的主要目标是，在较长时间内保留住主要的价值，并获得较为稳健的收入增长率。除此之外的其他任何成就（它们的确也在尽力达到更好的目标），都被视为额外的服务。或许，它们对客户的主要作用在于防止客户出现惨痛的失误，它们提供的是防御型投资者有权从服务于公众的咨询师哪儿获取的东西。</p>

<p>投资者可以通过证券公司的两类雇员来获取建议与信息。现在这两类人的正式称呼为“客户经纪人”和金融分析师（证券分析师）。</p>

<p>投资银行这一术语指的是，主要从事新的股票和债券的设计、承销和分销的公司。（承销指的是向发行公司或其他发行人保证，证券将完全被销售出去）</p>

<p>聪明的投资者要关注投资银行，尤其是那些信誉卓越的投资银行提供的意见和建议。但是，也一定要对这些建议作出恰当独立的判断——自己进行判断，或通过其他类别的投资顾问来进行判断。</p>

<h3 id="section-14">第11章 普通投资者证券分析的一般方法</h3>

<p>我们可以这样来看：证券分析主要局限于对股票和债券的考擦和评估，而金融分析除此之外，还包括投资政策的指定（证券组合选择），以及大量的一般经济分析。</p>

<p>证券分析师会设计和使用一些安全标准。根据这些标准，我们可以判断某种债券或优先股是否足够稳健而值得投资购买。这些标准主要涉及过去的平均收益状况，同时也涉及资本结构、营运资本、资产价值和其他方面。</p>

<p>优质股最优说服力的一个标准，就是多年来连续的股息支付记录。我们认为，20年及以上的股息连续支付记录，是反映公司股票质量的一个非常重要的有利因素。事实上，防御型投资者可以只购买符合这一标准的股票。</p>

<p>我们要给出如下忠告：如果我们希望高成长股的增长率实际得以实现的话，那么预期增长率的估价必须相对保守。事实上，根据算术，如果假设一个企业将来可以按8%或更高的速度无限期增长的话，那么其价值将趋于无穷大，且其股价无论多高也不过分。在这些情况，估价者实际的行为是在其计算中引入安全边际这一概念。基于这种情况，即便实际的增长率结果大大低于预测结果，购买股票也能达到自己的目标。</p>

<p>应该指出的是，基于未来预期结果的“科学的”（或者说至少合理可靠的）股票估价，都必须考虑到未来的利率状况。如果所假设的利率更高一些，那么既定的预期收益或股息的现值就会小一些。</p>

<p>需要注意的问题包括：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class=""><span class="line">1.企业是一个“连环并购者”。平均一年内有2-3起以上的并购，则预示着有可能出现麻烦。毕竟，如果某企业自身都认为应该购买其他企业的股份，而不愿从事自己的投资，那么你为何不根据这一线索，也去观察一下其他企业？
</span><span class="line">
</span><span class="line">2.企业是一位OPM（Other People’s Money）成瘾者，通过借债或出售股份来抬升他人资金的总量。这些资金使得一家有问题的企业似乎正在成长，即使其基础业务并不能带来足够的现金。
</span><span class="line">
</span><span class="line">3.企业不太灵活，其大多数的收入都来自于某一个或某几个客户。
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>有利的迹象包括如下几项：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class=""><span class="line">1.企业有宽广的“防御工事”或竞争优势。
</span><span class="line">
</span><span class="line">2.企业是一位长跑运动员，而不是一位短跑运动员。从长远看，10%的税前或7%的税后利润增长是可持续的。
</span><span class="line">
</span><span class="line">3.企业勤于播种和收获。无论企业的产品有多好，品牌有多强大，它都必须花一部分资金来拓展新的业务。尽管研发支出并不是当前增长的源泉，但很有可能是今后增长的源泉。
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>管理层的品质和行为。企业的高管应该言行一致。查阅以往的年度报告，核实管理者做出过哪些预测，以及他们是否达到了目标。管理者应该诚恳承认自己的失误，并承担相应的责任，而不是应该拿“总体经济”、“不确定因素”和“需求不足”等通用的理由作为替罪羊。</p>

<p>1.他们是否在为自己谋求最大利益？</p>

<p>2.企业高管是管理者还是推销员？企业高管应该将大部分时间用于管理企业的内部事务，而不应该向公众投资者推销自己的企业。</p>

<p>财务实力和资本结构。对优良企业最基本的定义是：所获取的资金要多于所消耗的资金。优秀的管理者不断的寻找各种方法，以将这些资金投入生产生活。</p>

<p>不断进行股票分割的企业是把投资者当成了傻瓜。价格为50美元的两份股票，并不比价格为100美元的一份股票更值钱。</p>

<p>企业应该在股价便宜时回购其股份，而不应该在股价处于或接近于最高位时回购股份。</p>

<h3 id="section-15">第 12 章  对每股收益的思考</h3>

<p>第一条建议：不要过于看重某一年的收益。第二条建议：如果你确实关注短期收益，请当心每股收益数据中存在的陷阱。如果我们严格遵守第一条告诫，那么第二条告诫就没有必要存在。</p>

<p>给投资者的几点忠告：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class=""><span class="line">1.当你研究某企业的财务报告时，从最后一页开始，慢慢的往前阅读。凡是惬意不愿意你看到的东西都放在后面。
</span><span class="line">
</span><span class="line">2.查看说明。在未阅读年度财务报告的有关说明之前，决不能去购买股票。
</span><span class="line">
</span><span class="line">3.阅读更多的内容。如果你是一个积极投资者，愿意在证券组合中花大量的时间和精力，那么你就应该更多的了解财务报告的内容。
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="section-16">第 13 章 对四家上市公司的比较</h3>

<p>真正重要的是持续不断的股息支付记录。</p>

<h3 id="section-17">第 14 章 防御型投资者的股票选择</h3>

<p>采纳我们建议的防御型投资者，只会购买高等级的债券以及多样化的优质普通股。</p>

<p>针对防御型投资者的需求和特征给出的适合的企业的要求：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
</pre></td><td class="code"><pre><code class=""><span class="line">1.适当的企业规模。就工业企业而言，年销售额不低于1亿美元；就公用事业企业而言，总资产不低于5000万美元。
</span><span class="line">
</span><span class="line">2.足够强劲的财务状况。就工业企业而言，流动资产至少应该是流动负债的两倍。同时，长期债务不应该超过流动资产净额，即营运资本。就共用事业企业而言，负债不应该超过股权的两倍。
</span><span class="line">
</span><span class="line">3.利润的稳定性。过去10年中，普通股每年都有一定的利润。
</span><span class="line">
</span><span class="line">4.股息记录。至少有20年连续支付股息的记录。
</span><span class="line">
</span><span class="line">5.过去10年内，每股收益的增长至少要达到三分之一。
</span><span class="line">
</span><span class="line">6.适度的市盈率。当期股价不应该高于过去3年平均利润的15倍。
</span><span class="line">
</span><span class="line">7.适度的股价资产比。当期股价不应该超过最后报告的资产账面值的1.5倍。然而，当市盈率低于15倍时，资产乘数可以相应的更高一些。
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>获取确定收益的人，很难变得非常富有；完全投资于风险业务的人，经常会因为失败而陷入贫穷。因此，较好的办法事，在从事风险业务时，要注意防范必然会导致的损失。</p>

<p>格雷厄姆建议，防御型投资者可以“直截了当”购买道琼斯工业平均指数中的每一种股票。如今，防御型投资者能够做得更好：购买整个股票市场指数基金，该基金实际上持有每一种值得拥有的股票。低成本的指数基金，是专门针对小额股票投资的最佳工具。任何想获得更优结果的行为，都将要付出更多的劳动（并且会导致更大的风险和更高的成本），而这对真正的防御型投资者来说是不恰当的。</p>

<p>自己通过研究而挑选股票是不必要的。对大多数人而言，这甚至是不明智的。</p>

<p>无论你是怎样的一位防御型投资者，都必须要完成两个步骤：</p>

<p>1.完成日常工作，利用数据库，可以立即获得公司的年度和季度报告，以及披露公司经理的薪酬、所有权和潜在利益冲突的代理报告。至少要查阅5年的报告。</p>

<p>2.弄清楚周围的情况。通过某些网站，可以方便的查阅各个机构持有公司股票的权重。</p>

<h3 id="section-18">第 15 章 积极型投资者的股票选择</h3>

<p>只要能达到一定程度的分散化，防御型投资者就可以根据自身或投资顾问的偏好，从这些类别的证券中自由构建证券组合。我们在证券选择方面主要强调如何进行各种排除，一方面，建议人们不要去购买质量明显较差的股票；另一方面，建议人们不要去购买价格太高，以致投机风险太大的高等级股票。</p>

<p>Mutual Service基金的创始人马克斯*海涅喜欢这样一句爱：“通往耶路撒冷的路不止一条”。这位股票大师的意思是，他自己以价值为核心的股票挑选方法，并非是成功的投资者唯一可使用的方法。</p>

<p>第 16 章 可转换证券及认股权证</p>

<p>第 17 章 四个非常有启发的案例</p>

<p>第 18 章 对八组公司的比较</p>

<h3 id="section-19">第 19 章 股东与管理层：股息政策</h3>

<p>可以说，在绝大多数情况下，较差的管理层不会因为“股东大众”的行为而改变，只会因为某一个人或少数几个人获得控制权而改变。</p>

<p>在监控公司管理者的行为方面，投资者永远都不会感兴趣。</p>

<p>格雷厄姆想要你认识到一个基本但却十分深刻的事实：当你购买 了某公司的股票时，你就称为该公司的所有者。包括CEO在内，公司的所有管理者都是在为你工作。公司的董事会必须对你的问题做出回答；公司的现金属于你；公司的业务是你的财产。如果你不喜欢公司的管理方式，你有权要求解雇管理者，更换董事，或者是将公司财产出售。</p>

<p>如今，投资者已经忘记了格雷厄姆的忠告。他们在购买股票上花费大量的精力，在出售股票上花费很少的精力，然而，在拥有股票上却没有花任何精力。“毫无疑问”，格雷厄姆提醒我们，“无论是即将成为股东，还是已经成为股东，都需要有细致的判断。”</p>

<p>理解并对代理报告进行投票，是对信息进行跟踪的聪明投资者的基本行为，而且，根据自己的良心投票是一个好公民应有的行为。</p>

<p>公司的管理层有可能把业务经营得很好，但却不能给外部股东带来理想的结果，因为公司的效率取决于业务活动，不一定反映了资本的最有效利用。有效经营的目标是以最低的成本进行生产，并且出售最赚钱的东西。有效融资要求股东资金的使用最符合他们的利益。这是目前的管理层不感兴趣的问题。实际上，公司管理层总是想尽可能从所有者那里获得资本，以尽量减少自己的财务问题。</p>

<p>如果股价便宜，将闲置资金用于回购股票，是利用公司资本的一个很好的方法。</p>

<p>薪酬中股票期权占很大比重的高管，从自身利益出发，必然会赞成股票回购，二不赞成股票派发。为什么？从技术上讲，期权的价值会随着股价波动幅度的增加而增加。但是股息会抑制股价的波动性。所以，如果管理者增加股息，就会降低自己拥有的股票期权的价值。</p>

<p>难怪CEO们更愿意回购股票（回购后给高管发期权）而不愿意支付股息了。不管股价如何波动和高估，也不管这会浪费外部股东多少资金。</p>

<p>几乎所有的管理者都会在行驶期权后，立即将所获股票出售。一下子出售上百万分股票以获取眼前的利润，这种行为怎么可能与忠实于公司的长期股东的利益是一致的？</p>

<h3 id="section-20">第20章 作为投资中心思想的“安全边际”</h3>

<p>当我们需要总结出稳健投资的秘密时，可以用安全边际这一座右铭来代表。这是一条主线，它贯穿于前面所有关于投资策略的论述之中，有时被明确表达出来，而有时则表达得不太直接。</p>

<p>安全边际——一旦公司未来的净收益下降，它可以防止投资者遭受损失或失败。</p>

<p>安全边际这一概念与分散化原则有着密切的逻辑联系，两者是相互关联的。投资者即使有一定的安全边际，个别证券还是有可能出现不好的结果。因为安全边际只能保证盈利的机会大于亏损的机会，并不能保证不会出现亏损。</p>

<p>分散化是保守的投资者长期坚守的信条。</p>

<p>公认的商业准则：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class=""><span class="line">1.知道自己在干什么，即通晓自己的业务。对投资者而言，这就意味着，不要试图通过证券来获得商业利润（超过正常利息和股息收益的回报），除非你足够了解证券的价值，正如你在准备生产和经营时了解相关商品的价值一样。
</span><span class="line">
</span><span class="line">2.不要让其他任何人来管理你的业务，除非你能够足够细致的监控并理解他的行为；或者你在内心中有很强的理由相信他的品格和能力。对投资者而言，这条准则决定了什么情况下可以让别人来为自己做出投资决策。
</span><span class="line">
</span><span class="line">3.如果没有可靠的计算表明某项业务（产品的制造或交易）获得合理利润的机会较大就不要涉足这项业务。尤其要远离那些利益不大，亏损确很严重的业务。
</span><span class="line">
</span><span class="line">4.有勇气相信自己的知识和经验。如果你根据事实得出了结论，而且你知道自己的判断是可靠的，那么就照此行事，即使其他人会迟疑或反对。同样，在证券领域，一旦获得了足够的知识并得出了经过验证的判断之后，勇气就称为最重要的品德。
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>幸运的是，对一般的投资者而言，他的成功并非必然要求其投资计划具备这些品质——如果他根据自己的能力行事，并将其业务活动局限于标准的防御型投资所具有的严格的安全范围之内。获得令人满意的投资结果，比大多数人想象的要简单，获得非常好的结果，比人们所想象的要难。</p>

<p>投资必然会出现一定的亏损，这是无法避免的。可是为了成为一位聪明的投资者，你必须确保自己永远不会使全部或大多数资金出现亏损。</p>

<p>对聪明的投资者而言，格雷厄姆的安全边际起着相同的作用：通过拒绝购买价格过高的证券，你就能降低财富消失或突然毁灭的机会。</p>

<p>风险不在于我们的股票，而在于我们自身。如果你高估自己对投资的真正理解，或者夸大自己在应对价格临时下降时的能力，那么无论你买什么股票，或者无论市场如何，都没有关系。最终金融风险不在于你从事了何种投资，而在于你是何种投资者。</p>

<p>你应该始终记住，风险来自于两种等同的要素——可能性和后果。投资之前，必须确保切实评估自己判断正确的可能性，以及错误发生时将对后果做出怎样的反应。</p>

<p>在不确定条件下做决定时，后果比可能性要重要得多。我们永远无法知道未来的情况。所以，正如格雷厄姆在本书的每一章都提醒过的，聪明的投资者一定不能只关注分析的正确性，还必须防止分析结果最终出现错误时的损失——因为即使是最好的分析，最终也有可能出错。</p>

<p>只要你始终进行分散化投资，并拒绝花大量的资金去追逐市场上的新宠，你就能保证错误所带来的后果永远不会是灾难性的。</p>

<h3 id="section-21">后记</h3>

<p>一些冷酷的经验告诉他们，最好做到安全和细致，而不要企图把全世界所有的钱都赚完。</p>

<p>一次幸运的机会，或者说一次极其英明的决策所获得的结果，有可能超过一个熟悉业务的人一辈子的努力。可是，在幸运或者关键决策的背后，一般都必须存在着有准备和具备专业能力等条件。人们必须在打下足够的基础并获得足够的认可之后，这些机会之门才会向其敞开。人们必须具备一定的手段、判断力和勇气，才能去利用这些机会。</p>

<p>金融领域的确存在着大量有趣的可能，因此，积极投资者在这个大型的热闹场面中，应该能够同时寻找到快乐和利润。兴奋是肯定能找到的。</p>

<p>投资的成功在于管理风险，而不在于回避风险。</p>

<p>投资者从未喜欢过不确定性，然而，不确定性是投资领域最基本和无法摆脱的条件。</p>

<p>投资也是一种冒险的事业，金融领域的未来始终是没有航标的世界。以格雷厄姆为向导，你终身的投资航程将既有惊险，也有安全保障。</p>

<p>附带说明一下，让我感到非常奇怪的是，人们要么会瞬间接受以4-每份买进1美元的东西这一理念，要么永远也不会接受这一理念。我从来没见过什么人是在10年间逐渐接受这一理念的。——巴菲特</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《穷查理宝典》]]></title>
    <link href="http://kobe1941.github.io/blog/charles-munger.html"/>
    <updated>2020-05-17T14:23:26+08:00</updated>
    <id>http://kobe1941.github.io/blog/charles-munger</id>
    <content type="html"><![CDATA[<p>整体上感觉一般，并不值得五颗星推荐，可以给3.5颗星吧，豆瓣上有过誉之嫌。</p>

<p>个人感觉最有价值的内容时序言和第一章，算是比较系统的介绍了下芒格个人的经历和一些经典的投资理念。后面的书单和演讲内容感觉拼凑章节的意义更大，而心理学部门又感觉对投资没有太大的指导意义。另外本书有不少重复的内容，前面章节介绍过的，后面的演讲部分又重复来一遍。芒格推荐的书籍可以配合芒格的评语一起看看。</p>

<!--more-->

<p>在价值投资者看来，投资股市最大的风险其实并不是价格的上下起伏，而是你的投资未来会不会出现永久性的亏损。单纯的股价下跌不仅不是风险，其实还是机会。不然哪里去找便宜的股票呢？</p>

<p>比如说，查理思考问题总是从逆向开始。如果要明白人生如何得到幸福，查理首先是研究人生如何才能变得痛苦；要研究企业如何做强做大，查理首先研究企业是如何衰败的；大部分人更关心如何在股市投资上成功，查理最关心的是为什么在股市投资上大部分人都失败了。他的这种思考方法来源于下面这句农夫谚语中所蕴含的哲理：我只想知道将来我会死在什么地方，这样我就不去那儿了。</p>

<p>查理一辈子研究人类灾难性的错误，对于由于人类心理倾向引起的灾难性错误尤其情有独钟。最具贡献的是他预测金融衍生产品的泛滥和会计审计制度的漏洞即将给人类带来的灾难。</p>

<p>查理一生研究人类失败的原因，所以对人性的弱点有着深刻的理解。基于此，他认为人对自己要严格要求，一生不断提高修养，以克服人性本身的弱点。这种生活方式对查理而言是一种道德要求。在外人看来，查理可能像个苦行僧，但在查理看来，这个过程却是既理性又愉快，能够让人过上成功、幸福的人生。</p>

<p>找到好配偶的最佳方法是什么呢？惟一的最佳方法是你首先必须值得拥有好配偶，因为从定义上来说，好配偶可绝不是傻瓜。</p>

<p>在整个阅读与思考的过程中，我自己愈发地觉得，中国文明的灵魂其实就是士大夫文明，士大夫的价值观所体现的就是一个如何提高自我修养、自我超越的过程。《大学》曰：正心，修身，齐家，治国，平天下。这套价值系统在之后的儒家各派中都得到了广泛的阐述。这应该说是中国文明最核心的灵魂价值所在。士大夫文明的载体是科举制度。科举制度不仅帮助儒家的追随者塑造自身的人格，而且还提供了他们发挥才能的平台，使得他们能够通过科举考试进入到政府为官，乃至社会的最上层，从而学有所用，实现自我价值。</p>

<p>而科举制度结束后，在过去的上百年里，士大夫精神失去了具体的现实依托，变得无所适从，尤其到了今天商业高度发展的社会，具有士大夫情怀的中国读书人，对于自身的存在及其价值理想往往更加困惑。在一个传统尽失的商业社会，士大夫的精神是否仍然适用呢？</p>

<p>晚明时期，资本主义开始在中国萌芽，当时的商人曾经提出过“商才士魂”以彰显其理想。在全球化的今天，“治国”与“平天下”的当代解读早已远远超出政府的范畴，市场与科技已经成为社会的主导，为怀有士大夫情怀的读书人提供了前所未有的舞台。</p>

<p>查理可以说是一个“商才士魂”的最好典范。首先，查理在商业领域极为成功，他和巴菲特所取得的成就可以说是前无古人，后无来者。然而在与查理的深度接触中，我却发现查理的灵魂本质是一个道德哲学家，一个学者。他阅读广泛，知识渊博，真正关注的是自身道德的修养与社会的终极关怀。与孔子一样，查理的价值系统是内渗而外，倡导通过自身的修行以达到圣人的境界，从而帮助他人。</p>

<p>查理是一个完全凭借智慧取得成功的人，这对于中国的读书人来讲无疑是一个令人振奋的例子。他的成功完全靠投资，而投资的成功又完全靠自我修养和学习，这与我们在当今社会上所看到的权钱交易、潜规则、商业欺诈、造假等毫无关系。作为一个正直善良的人，他用最干净的方法，充分运用自己的智慧，取得了这个商业社会中的巨大成功。在市场经济下的今天，满怀士大夫情怀的中国读书人是否也可以通过学习与自身修养的锻炼同样取得世俗社会的成功并实现自身的价值及帮助他人的理想呢？</p>

<p>我一辈子想要的就是融入生活，而不希望自己被孤立。</p>

<p>我这辈子遇到的聪明人没有不每天阅读的——一个都没有。我的孩子们都笑话我。他们觉得我是一本长了两条腿的书。通过阅读和“已逝的伟人”交朋友，这听起来很好玩，但如果你确实在生活中与“已逝的伟人”成为朋友，那么我认为你会过上更好的生活，得到更好的教育。</p>

<p>如果你想获得你要的东西，那就让自己配得上它。信任、成功和钦佩都是靠努力获得的。</p>

<p>真正重要的思想占了每个大学科的95%，所以，从大学科中获得思想，并把它们变为自我思考方式的一部分，非常重要。</p>

<p>每一次不幸都是良好表现的机会，每一次不幸都是学东西的机会，你的任务就是不要在自怜中淹没，而是以建设性的方式充分利用可怕的打击。</p>

<p>我认为不同人可以有不同的生活方式，但是考虑到生活是多么的困难，对大多数人而言，结婚是最好的选择。</p>

<p>躲开那些不恰当的激励制度。激励的作用是非常强大的，是人类认知和行为的控制器。只关涉到工作时间，无关于工作量和成果的工作机制，这很容易让人失去努力思考找出解决方案的动力。</p>

<p>人生在不同阶段会遇到不同的难题，非常棘手的难题。为了应付这些困难要让自己置身于朋友和家人的爱之中，同时期望别太高，还应该拥有幽默感。最重要的是，要适应生活的变化。如果世界没有改变，我现在身上仍然会有12个缺陷。</p>

<p>合伙人最好能够独立工作。你可以当一名指挥型的合伙人、服从型的合伙人，或者一名总是平等协作的合伙人。总是会有人在某些方面比你优秀。你必须先成为下属，然后才能成为领导。人们应该学会扮演各种角色。</p>

<p>投资之所以困难，是因为人们很容易看出来有些公司的业务比其他公司要好。但它们股票的价格升得太高了，所以突然之间，到底应该购买哪只股票这个问题变得很难回答。</p>

<p>在98％的时间里，我们对股市的态度是：接受自己的无知。赚钱，靠的是记住浅显的，而不是掌握深奥的。</p>

<p>当好项目出现时，我们必须能够认出来，因为好项目并不会经常出现。机会只眷顾有准备的人。要把钱集中投在少数几个项目上，耐心等待一记好球，这在我看来是很好的主意。</p>

<p>学会爱和仰慕那些值得爱和仰慕的人，不管是在世的或者已经离世的。正确的爱应该以仰慕为基础。</p>

<p>西塞罗并不认为财富能够使那些道德水平低下而又缺乏信仰的人避开悲惨的遭遇。在西塞罗看来，富人如果缺乏良心和信仰，那一定会遭受痛苦。</p>

<p>如果你的生活方式是正确的，那么你到了晚年只会比年轻时更加幸福。</p>

<p>所有时代的人都会发现，他的处方中那味叫作责任的药最难以下咽。</p>

<p>如果某个人的思维模式在生活中给他带来好处，那么这种模式往往会变成他最坚定不移的信念。</p>

<p>把工作做好的自豪感是非常有建设性的。它能够激发年轻时的斗志，当年老时，你回想起来也会感到更加快乐。</p>

<p>西塞罗虽然知识渊博，但他还是认为，只要一息尚存，就应该不断学习，自我提高。</p>

<p>西塞罗指出，试图解决基本问题的哲学研究是一种理想活动，适合所有年纪的人，哪怕是行将就木的老年人。</p>

<p>我们再怎么仰慕哲学的出色都是不够的，人们只要献身于哲学，就永远不会在任何人生阶段或境况中迷失自我。</p>

<p>在西塞罗看来，老年人不应该只追求生前的享受。他认为有价值的生活方式是努力为后人造福，哪怕自己可能看不到这种努力的结果。</p>

<p>西塞罗一贯反对抱怨，他认为抱怨变老是很愚蠢的。</p>

<p>西塞罗也从反面说明了这个道理。西塞罗说，如果一个人正直而又勤奋，那么他就算最终得到贫困潦倒的结果，也跟那些获得巨大成功的人一样值得尊敬；但他也承认，太过贫穷会让晚年的生活变得很艰难。</p>

<p>《论老年》最著名的段落当数下面这段了不起的总结：“晚年的最佳保护铠甲是一段在它之前被悉心度过的生活，一段被用于追求有益的知识、光荣的功绩和高尚的举止的生活。过着这种生活的人从青年时代就致力于提升他自己，而且将会在晚年收获它们产生的最幸福的果实。这不仅是因为有益的知识、光荣的功绩和高尚的举止将会陪伴他终生，甚至直到他生命的最后一刻，也会因为见证了正直的人生的良心和对过往美好功绩的回忆而给灵魂带来无上的安慰。”</p>

<p>他教导我说：“查理，你要是借了别人的车，别忘了加满油再还给人家。”</p>

<p>爸爸无论什么事情都做得公平和周到。所以那天我不仅学到了如何交朋友，还学到了如何维护友谊。</p>

<p>成为可信赖的人。不可靠会抵消其他的美德。所以，做那些你能抱有忠实信念的事情吧，你要避免懒惰和不可靠。</p>

<p>我和一个眼光极准的传奇人物合作了许多年，我总是很惊讶地发现，原来人们只要掌握和不停地应用所有明显而且容易学习的原理，就能够精通许许多多的领域。</p>

<p>我们从来不去试图成为非常聪明的人，而是持续地试图别变成蠢货。</p>

<p>在你应该做的事情和就算你做了也不会受到法律制裁的事情之间应该有一条巨大的鸿沟。</p>

<p>如果你在生活中唯一的成功就是通过买股票发财，那么这是一种失败的生活。生活不仅仅是精明地积累财富。 生活和生意上的大多数成功来自你知道应该避免哪些事情：过早死亡、糟糕的婚姻等等。 避免染上艾滋病、在路口和火车抢道，以及吸毒。培养良好的心理习惯。 避免邪恶之人，尤其是那些性感诱人的异性。 如果因为你的特立独行而在周围人中不受欢迎……那你就随他们去吧。</p>

<p>我这辈子遇到的聪明人（来自各行各业的聪明人）没有不每天阅读的——没有，一个都没有。沃伦读书之多，我读书之多，可能会让你感到吃惊。我的孩子们都笑话我。他们觉得我是一本长了两条腿的书。</p>

<p>我们看很多书。我认识的聪明人没有不看很多书的。但光看书还不够：你必须拥有一种能够掌握思想和做合理事情的性格。大多数人无法掌握正确的思想，或者不知道该怎么应用它们。</p>

<p>如果你担心通货膨胀，最好的预防手段之一就是在你的生活中别拥有大量愚蠢的需求——你不需要很多物质的商品。</p>

<p>你一旦走进负债的怪圈，就很难走出来。千万别欠信用卡的钱。你无法在支付18%的利息的情况下取得进展。</p>

<p>得到系统的常（非常）识——非常基础的知识——是一种威力巨大的工具。电脑带来的危险非常多。人们计算得太多，思考得太少。 拥有常识不但意味着有能力辨认智慧，也意味着有能力拒绝愚蠢。如果排除了许多事情，你就不会把自己搞得一团糟。</p>

<p>（成功投资的关键因素之一就是拥有良好的）性格——大多数人总是按捺不住，或者总是担心过度。成功意味着你要非常有耐心，然而又能够在你知道该采取行动时主动出击。你吸取教训的来源越广泛，而不是仅仅从你自己的糟糕经验中吸取教训，你就能变得越好。</p>

<p>我想说说怎样才能培养那种毫不焦躁地持有股票的性情。光靠性格是不行的。你需要在很长很长的时间内拥有大量的求知欲望。 你必须有浓厚的兴趣去弄明白正在发生的事情背后的原因。如果你能够长期保持这种心态，你关注现实的能力将会逐渐得到提高。如果你没有这种心态，那么即使你有很高的智商，也注定会失败。</p>

<p>我们的投资风格有一个名称——集中投资，这意味着我们投资的公司有10家，而不是100家或者400家。 我们的游戏是，当好项目出现时，我们必须能够认出来，因为好项目并不会经常出现。机会只眷顾有准备的人。 好的投资项目很难得，所以要把钱集中投在少数几个项目上，这在我看来是很好的主意。投资界有98%的人并不这么想。而我们一直以来都是那么做的，这给我们——也给你们——带来了许多好处。</p>

<p>Beta系数、现代组合投资理论等等——这些在我看来都没什么道理。我们想要做到的是，用低廉的价格，甚至是合理的价格，来购买那些拥有可持续竞争优势的企业。</p>

<p>认为投资应该越分散越好是一种发疯的观念。</p>

<p>我们并不认为分散程度很高的投资能够产生好结果。我们认为几乎所有好投资的分散程度都是相对较低的。</p>

<p>如果你把我们15个最好的决策剔除，我们的业绩将会非常平庸。你需要的不是大量的行动，而是极大的耐心。你必须坚持原则，等到机会来临，你就用力去抓住它们。</p>

<p>这些年来，伯克希尔就是通过把赌注押在有把握的事情上而赚钱的。</p>

<p>过去几十年来，我们经常这么做：如果某家我们喜欢的企业的股票下跌，我们会买进更多。有时候会出现一些情况，你意识到你错了，那么就退出好了。但如果你从自己的判断中发展出了正确的自信，那么就趁价格便宜多买一些吧。 诱人的机会总是转瞬即逝的。</p>

<p>真正好的投资机会不会经常有，也不会持续很长的时间，所以你必须做好行动的准备。要有随时行动的思想准备。</p>

<p>如果你打算成为一名投资者，那么总会有些投资领域不是你完全了解的。但如果你努力学习，不断进步，那么你就能够保证你的投资都会产生好的结果。关键是自律、勤奋和练习。那就像打高尔夫球——你必须努力练习。</p>

<p>如果你确有能力，你就会非常清楚你能力圈的边界在哪里。没有边界的能力根本不能称之为能力。</p>

<p>人们不是有点蠢，而是非常蠢。没有人愿意说出这一点。</p>

<p>也许没有人像我们这样，但我们对金融风险特别敏感。当金融机构想努力表现时，我们就会感到紧张。 我们尤其害怕那些大量举债的金融机构。如果他们开始说起风险管理有多么好，我们就会很紧张。</p>

<h2 id="section">芒格私人书单</h2>

<h3 id="section-1">《自然哲学的数学原理》</h3>

<p>作者牛顿如是说</p>

<p>“圆滑是一门表达观点而又不树敌的艺术。”</p>

<p>“如果说我曾发现什么有价值的原理，那应该归功于我的耐心观察，而非其他才能。”</p>

<p>“没有大胆的猜想，就没有伟大的发现。”</p>

<h3 id="section-2">《自私的基因》</h3>

<p>“成功基因的一个突出特性就是其无情的自私性。”</p>

<p>“由于文化的出现，我们的人生的终极任务，将不只是繁殖，还有文化的创造和传承。”</p>

<p>“就确定未来而言，没有比历史更好的老师……生物学上的原因能够帮助预测商业进化过程的结果，商业和生物进化有很多相似性。”</p>

<p>“一些研究显示，给住院的病人送花不仅是一种温暖的问候，它的确能改善患者的心情，缩短康复的时间。”</p>

<p>“父母对孩子最重要的影响在受孕的那一刻就已经完成，孩子是在和同龄人的交往互动中习得文化、发展个性的。”</p>

<h3 id="section-3">贾雷德·戴蒙德《枪炮、病菌与钢铁》</h3>

<p>作为一本关于人类发展史的书，它讨论了一个很诱人的问题：为什么在近代把美洲人、亚洲人、澳洲人挨个入侵一遍的是欧洲人，而不是澳大利亚土著，不是印第安人，不是新几内亚人，也不是非洲人，甚至也不是在工业革命前在世界占主导地位的中国呢？从这个问题开始，作者试着从人类走出非洲开始，从走向每片大陆的时间切入，把农业的兴起、大型食草哺乳动物的驯服、发明和技术的传播速度作为主要讨论对象，对这个问题进行了阐释。</p>

<p>贾雷德·戴蒙德作为演化生物学家，解释了事实上有助于形成历史最广泛模式的环境因素，以震撼人心的力量摧毁了以种族主义为基础的人类史理论。</p>

<p>“不同民族的历史遵循不同的道路前进，其原因是民族环境的差异，而不是民族自身在生物学上的差异。”</p>

<p>芒格在“专业人士需要更多的跨学科技能”的演讲中谈道： 我很早就学过基本物理学和数学，我花了很多精力，掌握了硬科学的基本治学精神与方法，我用这种方法去学习各种软科学，增加我的跨学科普世智慧。因而，我的生活无意间成了一种教育实验：一个很好地掌握了自己专业的人在非常广阔的学术领域试验这种几本治学精神与方法的可行性和有效性。</p>

<p>“悲观主义者会注意到中国存在大量危险，其一是对经济增长的重视程度高于环境保护和可持续发展；其二，大众的环境保护意识低下，这部分是因为教育投入不够多，中国的教育经费占国民生产总值的比重不及第一世界国家的一半。中国的人口总数占世界人口的20%，但教育经费只是全世界教育经费的1%。”</p>

<p>杰出生态哲学家哈丁指出，因为人类的自私，如果不遏制人口增长，地球的资源将会被过度消耗。</p>

<p>“你必须知道重要学科的重要理论，并经常使用它们——要全部都用上，而不是只用几种。大多数人都只使用学过的一个学科的思维模型，比如说经济学，试图用一种方法来解决所有问题。你知道谚语是怎么说的：‘在手里拿着铁锤的人看来，世界就像一颗钉子。’这是处理问题的一种笨办法。”</p>

<p>而关于如何投资，芒格坦陈自己很认同菲利普·A.费舍在《怎样选择成长股》中的观点，即选择那些能够“增长，增长，再增长”的高品质公司的股票。费舍是关注成长股的先驱，这种思想是价值投资的一个变种和分支。</p>

<p>“投资人‘五不’原则： 1. 不买处于创业阶段的公司。 2. 不要因为一只好股票在‘店头市场’交易，就弃之不顾。 3. 不要因为你喜欢某公司年报的‘格调’，就去买该公司的股票。 4. 不要以为一公司的本益比高，便表示未来的盈余成长已大致反映在价格上。 5. 不要锱铢必较。”</p>

<p>“投资的时候，保持简单的头脑，做显而易见符合常理的事情。巴菲特的建议是：难易程度并不决定你投资的成功与否，找一家能干得久的、有一定发展规律可循的、并且你知道他们是干什么的公司，按照你的常理投资。”</p>

<p>“畏首畏尾而‘不把鸡蛋放在一个篮子’里的人，确实很安全。但是如果你认定了一个公司有着很好的发展前景，为什么不变得有攻击性一些呢？巴菲特的建议：你的股票最好不要超过十只，避免资金过度分散；在投资的战场上，要有勇气。”</p>

<p>“事实往往是，那些只做几个数量不多的决策的人最终结果，却比那些以忙碌为名作出很多决定的人要好得多。”</p>

<p>“在赛马场上或股市上最明智的做法是按兵不动，耐心等待，直到那匹好马出现在有很大获胜机会的位置上才出击。”</p>

<p>“我想我自己不是受到良好教育的典范，我是自己学会通过阅读而获取自己想要的信息的。我一生中常常如此。我经常是更喜欢已经作古的杰出导师。和已逝的伟人交朋友，这听起来很好玩，但如果你总是和那些有远见卓识的故人交友的话，你的生活将变得更好，更丰富。”</p>

<p>“人的童年过得十分缓慢，好像满载的货车；老年的岁月转瞬即逝，犹如夜空的流星。”</p>

<p>在手里拿着铁锤的人看来，这个世界看上去就像一颗钉子。</p>

<p>“你若想在任何领域拥有竞争力，就必须熟练地掌握该领域的方方面面，不管你是否喜欢这么做，这是人类大脑的深层结构决定的。”</p>

<p>芒格在“专业人士需要更多的跨学科技能”的演讲中，鼓励大家多多使用跨学科方法，多多实行“拿来主义”。因为在软科学界研究发现，有一种研究方法非常好，就是“拿来主义”法，不论看中其他学科什么知识，只管拿过来用，以免在单一学科中故步自封。</p>

<h3 id="section-4">《谈判力》</h3>

<p>在日常生活中，每个人都不可避免会成为一个谈判者。虽然每天要与谈判相伴，但并不是每个人都能谈出好的结果。在常见的谈判策略中，人们使用的大多属于温和或强硬的方式。温和的方式总是尽量避免摩擦和冲突，为达成共识，往往很快让步；而强硬的方式则以战胜对方为目标，坚守立场，但常会两败俱伤。</p>

<p>在这本书里，作者基于“哈佛大学谈判项目”提出了第三种谈判方式，即“原则谈判方式”。这种方式根据事情本身的是非曲直寻求解决方案，强调把人和事分开，着眼于利益而非立场，当双方利益发生冲突时，让谈判结果基于某些公平的标准，而不是以某一方意志为转移。</p>

<p>“谈判的任何办法都可以通过三方面的标准来衡量：如果有达成共识的可能，就应该达成明智的协议；谈判必须有效率；增进或至少不损害双方的关系（明智的协议是指协议尽可能保障双方的合法利益，公平解决双方的利益冲突，协议持久性强，并考虑了社会效益）。”</p>

<h3 id="section-5">《影响力》</h3>

<p>心理学家罗伯特·西奥迪尼博士在这本书中为我们解释了说服的奥秘。隐藏在影响力背后的有八大心理秘籍。那些劝说高手，总是熟练地运用它们，让我们就范。这八大秘籍是：对比；互惠；相互退让；承诺和一致；社会认同；喜好；权威；短缺。这些就是影响力的构成要素，此书内容的核心。</p>

<p>“互惠原理认为，我们应该尽量以相同的方式来回报他人为我们所作的一切。接受往往和偿还联系在一起。”</p>

<p>“影响力，说到底是一个心理学的问题。技巧是多样的，关键是懂得要散发影响力，需要让对象置于何种心理下。”</p>

<p>“诚实、勇敢、正直会有最大的影响力。”</p>

<p>“内心须追求并维护优秀的品质，因为人类与其他动物的最大不同，在于它是一个有‘心’的物种，换句话说，之所以为人，乃是有‘心’。”</p>

<p>韦尔奇的代表作就是《赢：韦尔奇一生的管理智慧》，他将自己在工作与生活中如何才能“赢”的智慧倾囊相授。但同时芒格提醒人们，有些人总是很自信地回答他们其实并不了解的问题，就像乱跳舞的蜜蜂，会把整个蜂窝搞得乱哄哄，那是一种巨大的错误。没有人期望你什么都懂。自然，这也是韦尔奇的态度。</p>

<p>杰克韦尔奇谈好的工作和糟糕的工作：</p>

<ol>
  <li>
    <p>人：你需要找与自己志趣相投的人，在职业生涯中应该越早越好。</p>
  </li>
  <li>
    <p>机遇：任何新工作都应该让自己感觉有所发展，而不是刚刚够用。</p>
  </li>
  <li>
    <p>未来：到某些公司工作，就像赢取奥运会的奖牌一样，它将使你在今后的职业生涯中总是与成就和荣誉联系起来（公司声誉）；你所从事的每种职业都是一场赌博，它有可能开拓你未来的发展空间，也有可能缩小你的选择范围（所处产业）。</p>
  </li>
  <li>
    <p>主导权：在职业生涯中，我们对工作的选择往往都是为了实现其他人的理想。所以在处理工作主导型问题时，唯一的方法就是要对自己诚实，要明白自己是在为哪些人工作。</p>
  </li>
  <li>
    <p>工作内容：如果一份工作不能让你兴奋——只是由于工作内容乏味——那你就没必要再沉浸其中了。”</p>
  </li>
</ol>

<p>芒格在南加州大学GOULD法学院毕业典礼上的演讲中，谈到一个他认为很重要的道理，那就是：将不平等最大化通常能收到奇效。这句话是什么意思呢？芒格是这样说的：</p>

<p>伍登曾经是世界上最优秀的篮球教练。他对五个水平较低的球员说：“你们不会得到上场的时间——你们是陪练。”比赛几乎都是那七个水平较高的球员在打的。嗯，这七个水平高的球员学到了更多——别忘了学习机器的重要性——因为他们独享了所有的比赛时间。在他采用非平等主义的方法时，伍登比从前赢得了更多的比赛。我认为生活就像比赛，也充满了竞争，我们要让那些最有能力和最愿意成为学习机器的人发挥最大的作用。</p>

<p>“以客户需求为导向，以客户的根本利益为出发点，短期内企业可能会承受巨大的经营压力，但一旦能熬过去，企业收获的将是无坚不摧的战斗力、坚实的口碑和滚滚财源。”——《只有偏执狂才能生存》</p>

<p>在西塞罗看来，抱怨年纪是无益的，尤其是年轻人不要未老先死，如果你的生活方式是正确的，那么到了晚年会更幸福。芒格经常引用西塞罗的下面这段话：</p>

<p>晚年的最佳保护铠甲是一段在它之前被悉心度过的生活，一段被用于追求有益的知识、光荣的功绩和高尚的举止的生活；过着这种生活的人从青年时代就致力于提升他自己，而且将会在晚年收获它们产生的最幸福的果实；这不仅是因为有益的知识、光荣的功绩和高尚的举止将会陪伴他终生，甚至直到他生命的最后一刻，也会因为见证了正直的人生的良心和过往美好功绩的回忆将会给灵魂带来无上的安慰。</p>

<h2 id="section-6">芒格的演讲</h2>

<p>微观经济学的伟大意义在于让人能够辨别什么时候技术将会帮助你，什么时候它将会摧毁你。大多数人并没有想通这个问题。但像巴菲特这样的家伙就想通了。</p>

<p>我们起初是格雷厄姆的信徒，也取得了不错的成绩，但慢慢地，我们培养起了更好的眼光。我们发现，有的股票虽然价格是其账面价值的两三倍，但仍然是非常便宜的，因为该公司的市场地位隐含着成长惯性，它的某个管理人员可能非常优秀，或者整个管理体系非常出色等等。</p>

<p>长远来看，股票的回报率很难比发行该股票的企业的年均利润高很多。如果某家企业40年来的资本回报率是6%，你在这40年间持有它的股票，那么你得到的回报率不会跟6%有太大的差别——即使你最早购买时该股票的价格比其账面价值低很多。相反地，如果一家企业在过去二三十年间的资本回报率是18%，那么即使你当时花了很大的价钱去买它的股票，你最终得到的回报也将会非常可观。 所以窍门就在于买进那些优质企业。这也就买进了你可以设想其惯性成长效应的规模优势。</p>

<p>在成长股票模式中，有这样一个子模式：在你们的一生当中，你们能够找到少数几家企业，它们的管理者仅通过提高价格就能极大地提升利润——然而他们还没有这么做。所以他们拥有尚未利用的提价能力。人们不用动脑筋也知道这是好股票。</p>

<p>迪士尼就是这样的。带你们的孙子去迪士尼乐园玩是非常独特的体验。你们不会经常去。全国有许许多多的人口。迪士尼发现它可以把门票的价格提高很多，而游客的人数依然会稳定增长。</p>

<p>在生活中维持许多好习惯，避免或者戒除许多坏习惯，这样的生活才是明智的。能够帮助人们过上明智生活的伟大原则同样来自富兰克林的《穷理查年鉴》：“一盎司的预防比一磅的治疗更值钱。”富兰克林这句话的部分含义是，由于避免不一致性倾向的存在，防止一种习惯的养成要比改变它容易得多。</p>

<p>长久以来，我坚信存在某个系统——几乎所有聪明人都能掌握的系统，它比绝大多数人用的系统管用。你需要的是在你的头脑里形成一种思维模型的复式框架。有了那个系统之后，你就能逐渐提高对事物的认识。 然而，我这种特殊的方法似乎很少得到认可，甚至对那些非常有才能的人来说也是如此。人们要是觉得一件事情“太难”，往往就会放弃去做它。</p>

<p>有性格的人才能拿着现金坐在那里什么事也不做。我能有今天，靠的是不去追逐平庸的机会。</p>

<p>如果你确有能力，你就会非常清楚能力圈的边界在哪里。如果你问起（你是否超出了能力圈），那就意味着你已经在圈子之外了。</p>

<p>本杰明·格雷厄姆曾经教我只买便宜的股票，查理让我改变了这种做法。这是查理对我真正的影响。要让我从格雷厄姆的局限理论中走出来，需要一股强大的力量。查理的思想就是那股力量，他扩大了我的视野。——巴菲特</p>

<p>股价公道的伟大企业比股价超低的普通企业好。</p>

<p>你必须有浓厚的兴趣去弄明白正在发生的事情背后的原因。如果你能够长期保持这种心态，你关注现实的能力将会逐渐得到提高。如果你没有这种心态，那么即使你有很高的智商，也注定会失败。</p>

<p>我和一个眼光极准的传奇人物合作了许多年，我总是很惊讶地发现，原来人们只要掌握和不停地应用所有明显而且容易学习的原理，就能够精通许许多多的领域。</p>

<p>但无论你们选择了哪种生活方式，我认为你们应该尽量去吸收基本的普世智慧，否则就是犯了大错，因为世俗智慧可以让你更好地服务别人，可以让你更好地服务自己，可以给生活带来更多的乐趣。所以如果你们有能力去掌握它却不去掌握，我认为那是很荒唐的。如果你们掌握了普世智慧，你们的生活将会变得很丰富——不仅是金钱方面，其他方面也将会变得很丰富。</p>

<p>一切重要的图书都应该立即重读。</p>

<p>关于这种背道而驰的历史，我想说我同意彼得·德鲁克的观点：跟其他利益相比以及跟大多数其他国家相比，美国的文化和法律制度特别照顾股东的利益。实际上，在许多国家，股东权益并没有得到很好的保护，有许多东西比股东权益更重要。我想许多投资机构低估了这个因素的重要性，也许是因为人们很难用现代的金融工具来对它进行定量分析。但有些因素并不会因为“专家”无法很好地理解而失去它们的重要性。总的来说，相对于对国外的企业进行直接投资，我倾向于伯克希尔通过投资类似可口可乐和吉列那样的公司来参与全球经济。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《投资最重要的事》]]></title>
    <link href="http://kobe1941.github.io/blog/invest-most-important-thing.html"/>
    <updated>2020-05-03T20:34:51+08:00</updated>
    <id>http://kobe1941.github.io/blog/invest-most-important-thing</id>
    <content type="html"><![CDATA[<p>巴菲特最初主要是投资股票，后来更多是收购和经营企业，而霍华德·马克斯完全是证券投资，而且主要是股票投资。所以说从这一点来看，霍华德·马克斯的这本书相当于专门解读自己的股票投资想法、操作方法和心法，他和巴菲特的投资基本原则完全相同，但他讲的比巴菲特更加专注于股票投资，更加详细，更加具有操作性，所以这本书对于以股票为主的投资者更有实践上的借鉴意义。</p>

<p>霍华德·马克斯这本书的中心思想非常明确：如何取得超越市场平均水平的投资业绩？</p>

<!--more-->

<p>格雷厄姆给出的答案非常精辟：“要想在证券市场上取得投资成功，第一要正确思考，第二要独立思考。”</p>

<p>巴菲特强调投资成功必须将用脑和用心相结合：“要想在一生中获得投资的成功，并不需要顶级的智商、超凡的商业头脑或秘密的信息，而是需要一个稳妥的思考框架作为决策的基础，并且有能力控制自己的情绪，使其不会对这种思考框架造成侵蚀。格雷厄姆的书能够准确和清晰地提供这种思考框架，但对情绪的约束是你自己必须做到的。”</p>

<p>这本书的核心归纳为一句话：逆向思考并逆向投资。</p>

<p>而这正是巴菲特一再重复的他一生最基本的投资原则：在别人恐惧时贪婪，在别人贪婪时恐惧。</p>

<p>年近70的霍华德·马克斯从他自己逆向思考并逆向投资的40多年投资经验中，总结提炼出18件投资最重要的事，也是他认为的18种最重要的卓越投资技术，而这些正是巴菲特和霍华德·马克斯这些价值投资大师取得长期战胜市场的优秀业绩的关键，所以我称之为价值投资者的“降龙十八掌”秘籍。</p>

<p>我简要概括如下：</p>

<p>1.最重要的不是盲目相信股市总是有效或者总是无效，而是清醒认识股市相当高效而且相当难以击败，只有真正的高手才能长期战胜市场。</p>

<p>2.最重要的投资决策不是以价格为本，而是以价值为本。</p>

<p>3.最重要的不是买好的，而是买得好。</p>

<p>4.最重要的不是波动性风险，而是永久损失的可能性风险。</p>

<p>5.最重要的巨大风险不在人人恐惧时，而在人人都觉得风险很小时。</p>

<p>6.最重要的不是追求高风险高收益，而是追求低风险高收益。</p>

<p>7.最重要的不是趋势，而是周期。</p>

<p>8.最重要的不是市场心理钟摆的中点，而是终点的反转。</p>

<p>9.最重要的不是顺势而为，而是逆势而为。</p>

<p>10.最重要的不是想到逆向投资，而是做到逆向投资。</p>

<p>11.最重要的不是价格也不是价值，而是相对的性价比，即安全边际。</p>

<p>12.最重要的不是主动寻找机会，而是耐心等待机会上门。</p>

<p>13.最重要的不是预测未来，而是认识到未来无法预测但可以先作好准备。</p>

<p>14.最重要的不是关注未来，而是关注现在。</p>

<p>15.最重要的是认识到短期业绩靠运气，而长期业绩靠技术。</p>

<p>16.最重要的不是进攻，而是防守。</p>

<p>17.最重要的不是追求伟大成功，而是避免重大错误。</p>

<p>18.最重要的不是牛市跑赢市场，而是熊市跑赢市场。</p>

<p>巴菲特建议投资初学者最好的学习方法是模仿大师：“我一直认为，对于刚开始起步的投资人来说，应该寻找已经被证明长期成功有效的投资方法，然后依葫芦画瓢照着做就行了。令人吃惊的是，这样做的人实在少之又少。”</p>

<p>接受是我的重要主旨之一：接受周期与变化的必然性，接受事物的随机性，从而接受未来的不可预知性与不可控性。接受能够带来平静，在其他投资者失去冷静的时候，这是一笔伟大的财富。接受的结果便是在投资中拥有行之有效的耐性：对新投资策略的引入与新客户关系的巩固所需的时间保持耐性，也对正确的投资策略得到证实的时间保持耐性。接受、平静与耐性，都是令我深受触动的中国思想的精髓。</p>

<p>最有价值的经验是在困难时期学到的。</p>

<p>投资艺术有一个特点不为大众所知。门外汉只需些微努力与能力，便可以取得令人尊敬（即使并不可观）的结果。但是如果想在这个容易获取的标准上更进一步，则需要更多的实践和智慧。</p>

<p>人人都想赚钱。一切经济学都建立在相信利润动机普遍性的基础之上。资本主义亦是如此，利润动机促使人们更加努力地工作并以资本相搏。对利润的追逐创造了这个世界的大多数物质进步。</p>

<p>如果你的行为是常规性的，你很可能就会得到常规性的结果—无论好坏。只有当你的行为是非常规性的时，你的表现才有可能是非常规性的，而只有当你的判断高人一等时，你的表现才会高于平均表现。</p>

<p>但是证明市场价格永远正确是不可能的。事实上，如果你仔细想想刚刚列出的4个假设，就会发现其中有一点特别脆弱：客观性。人类不是冰冷的计算机器。相反，大多数人都会受贪婪、恐惧、妒忌及其他破坏客观性、导致重大失误的情绪驱动。</p>

<p>我们认为无效性是存在的。单单这一点并不是优秀业绩的充分条件，它只表示价格并不总是公平的，错误是会发生的：某些资产定价过低，某些资产又定价过高。你必须具有比其他人更深刻的洞察力，才能更多地买到前者而不是后者。任何时候都会有许多好的便宜货被埋没在其他投资者不能或不愿去发现的东西里。</p>

<p>因为有效市场的概念是相对的，所以我将精力放在相对无效的市场上，在那里，只要付出辛勤的工作并掌握技术，就能获得最好的回报。我投资管理生涯的关键转折点是在得到这个结论时出现的。</p>

<p>简而言之，我认为有效市场理论应提供信息辅助我们决策而不是控制决策。如果完全无视理论，那么我们可能会犯下大错。</p>

<p>在价值投资和成长型投资之间没有明确的界限，二者均要求我们应对未来。价值投资者将企业的潜力视为增长，“以合理价格增长”的成长型投资则明确表达了对价值的敬意—只是一个程度问题。无论如何，我认为完全可以这样说：成长型投资关心未来，而价值投资强调当前，但不可避免地要面对未来。</p>

<p>总而言之，如果判断正确，那么成长型投资的上涨潜力更富戏剧性，而价值投资的上涨潜力更有持续性。我选择的是价值投资法。在我的书里，持续性比戏剧性更重要。</p>

<p>估价正确却不坚定地持有，用处不大。估价错误却坚定地持有，后果更糟。这句话表明恰到好处是多么困难。</p>

<p>当价值投资者买进定价过低的资产、不停地向下摊平并且分析正确的时候，就能获得最大收益。因此，在一个下跌的市场中获利有两个基本要素：你必须了解内在价值；同时你必须足够自信，坚定地持股并不断买进，即使价格已经跌到似乎在暗示你做错了的时候。哦，对了，还有第三个基本要素：你必须是正确的。</p>

<p>成功的投资不在于“买好的”，而在于“买得好”。</p>

<p>对于价值投资者来说，必须以价格为根本出发点。事实屡次证明，无论多好的资产，如果买进价格过高，都会变成失败的投资。同时，很少有资产会差到以足够低的价格买进都不能转化为成功投资的地步。</p>

<p>在橡树资本管理公司我们说，“好的买进是成功卖出的一半”，意思是说，我们不花太多时间去考虑股票的卖出价格、卖出时机、卖出对象或卖出途径。如果你买得足够便宜，那么最终这些问题的答案是不言而喻的。</p>

<p>相信我，再没有比在崩盘期间从不顾价格必须卖出的人手中买进更好的事了。我们许多最好的交易都是在这种时候完成的。不过我还要补充两点意见：</p>

<p>你不能以从强制卖家手中买进或把证券卖给强制买家为生；强制卖家和强制买家不是任何时候都有的，他们只在罕见的极端危机和泡沫时期才会出现。</p>

<p>既然从强制卖家手中买进是世界上最美妙的事，那么成为强制卖家就是世界上最悲惨的事。所以，把自己的事情安排好，保证自己能够在最艰难的时期坚持住（不卖出）是非常重要的。要做到这一点，既需要长期资本，又需要强大的心理素质。</p>

<p>投资是一场人气竞赛，在人气最旺的时候买进是最危险的。在那个时候，一切利好因素和观点都已经被计入价格中，而且再也不会有新的买家出现。</p>

<p>最安全、获利潜力最大的投资，是在没人喜欢的时候买进。假以时日，一旦证券受到欢迎，那么它的价格只可能向一个方向变化：上涨。</p>

<p>某种东西价格上涨时，人们的喜爱程度本应下降，但在投资中，他们的喜爱程度往往会加深。</p>

<p>以低于价值的价格买进。在我看来，这才是投资的真谛—最可靠的赚钱方法。以低于内在价值的价格买进然后等待资产价格向价值靠拢并不需要多么特殊的才能，只需市场参与者清醒过来面对现实即可。当市场运作正常的时候，价值就会使价格强势拉升。</p>

<p>在所有可能的投资获利途径中，低价买进显然是最可靠的一种。不过即使这样也未必一定奏效。你可能错误估计了当前价值。或者可能会出现降低价值的事件。或者你的态度与市场的冷淡导致证券以更低的价格出售。或者价格与内在价值达到一致所需的时间比你可以等待的时间要长，正如凯恩斯指出的，“市场延续非理性状态的时间比你撑住没破产的时间要长”。</p>

<p>低于价值买进并非万无一失，但它是我们最好的机会。</p>

<p>投资只关乎一件事：应对未来。没有人能够确切地预知未来，所以风险是不可避免的。因此，应对风险是投资中一个必不可少的（我认为是根本的）要素。找到将上涨的投资并不难。如果你能找到足够多，那么你可能已经在朝着正确的方向前进。但是，如果不能正确地应对风险，那么你的成功是不可能长久的。第一步是理解风险。第二步是识别风险。最后的关键性一步，是控制风险。</p>

<p><img src="http://kobe1941.github.io/images/2020/05/03/1.png" alt="" /></p>

<p>理解风险的关键是：风险很大程度上是一个见仁见智的问题。即使是在事件发生之后，也难以对风险有明确的认识。</p>

<p>平心而论，我认为投资表现是一系列事件—地缘政治的、宏观经济的、公司层面的、技术的、心理的—与当前投资组合相碰撞的结果。迪姆森的话可以解释为：未来有多种可能性，但结果却只有一个。你得到的结果对你的投资组合可能有益，也可能有害，这可能取决于你的远见、谨慎或者运气。你的投资组合在一种情况下的表现与它在其他可能发生的“未然历史”下的表现毫不相干。</p>

<p>投资风险很大程度上事先是观察不到的—除了那些有非凡洞察力的人—甚至在投资退出之后也一样。正因如此，我们见到过的许多金融大灾难都没能被成功地预测，人们也没能很好地管理风险。原因有几个：</p>

<p>风险只存在于未来，而未来会怎样是不可能确定的……而当我们回顾过去时，是不存在不确定性的，但是这种确定性并不表示产生结果的过程是确定而可靠的。在过去的每种情况下，都存在发生许多事件的概率，最终只有一个事件发生的事实低估了实际存在变化的可能性。</p>

<p>承担风险与否的决策建立在常态再现的期望之上。在大多数情况下，确实如此。但是，异常事件时有发生……不可能的事件也偶有发生。</p>

<p>预测倾向于围绕历史常态聚集，仅容许微小的变化……关键是，人们通常会预测未来与过去相似，而对潜在变化估计不足。</p>

<p>风险不是一成不变的。</p>

<p>我们常听说“最坏情况”预测，但是结果往往显示预测的程度还不够坏。</p>

<p>最后，也是最重要的一点，大多数人将风险承担视为一种赚钱途径。承担更高的风险通常会产生更高的收益。市场必须设法证明实际情况似乎就是这样，否则人们就不会进行高风险投资。但是市场不可能永远以这样的方式运作，否则高风险投资的风险也就不复存在了。一旦风险承担不起作用，它就会完全不起作用，直到这时人们才会想起风险究竟是怎么回事。</p>

<p>风险意味着即将发生的结果的不确定，以及不利结果发生时损失概率的不确定。</p>

<p>普遍相信没有风险本身就是最大的风险，因为只有当投资者适当规避风险时，预期收益中才会包含风险溢价。</p>

<p>总而言之，关于风险控制的神话很少有成真的。风险是不能被消除的，它只能被转移和分散。</p>

<p>投资风险主要源自过高的价格，过高的价格往往源自过度乐观、怀疑不足以及风险规避不足。</p>

<p>事实上，大众误解风险至少像他们误解收益一样频繁。认为某种东西过热而无法应对的共识几乎总是错的，事实通常是它的对立面。</p>

<p>在所有人都相信某种东西有风险的时候，他们不愿购买的意愿通常会把价格降低到完全没有风险的地步。广泛的否定意见可以将风险最小化，因为价格里所有的乐观因素都被消除了。</p>

<p>当然，正如漂亮50投资者的经历所证明的，当人人都相信某种东西没有风险的时候，价格通常会被哄抬至蕴涵巨大风险的地步。没有风险担忧，因此也就不提供或不要求风险承担的回报—“风险溢价”。这可能会使受人们推崇的最好资产成为风险最高的资产。</p>

<p>归根结底，投资者的工作是以营利为目的聪明地承担风险。能够出色地做到这一点，是最好的投资者与其他投资者之间的区别。</p>

<p>在我看来，杰出投资者之所以杰出，是因为他们拥有与创造收益的能力同样杰出的风险控制能力。</p>

<p>杰出投资者是那些承担着与其赚到的收益不相称的低风险的人。他们或以低风险赚到中等收益，或以中等风险赚到高收益。</p>

<p>无论风险控制取得怎样的成绩，在繁荣时期是永远也表现不出来的，因为风险是隐蔽的，是不可见的。风险—发生损失的可能性—是观察不到的，能观察到的是损失，而损失通常只在风险与负面事件相碰撞时才会发生。</p>

<p>我认为从根本上降低风险是投资取得巨大成功的基础，所以我认为这一概念应得到更多的重视。在牛市充分盈利，同时也要在熊市取得良好业绩，你觉得这种想法怎么样？在取得牛市收益的同时承担低于市场的风险……绝非易事。</p>

<p>以较低风险实现与其他风险承担者相同的收益是一项杰出成就。</p>

<p>归根结底，投资者的工作是以盈利为目的聪明地承担风险。能够出色地做到这一点，是最好的投资者与其他投资者之间的区别。</p>

<p>多年来我一直在说，高风险资产如果足够便宜，就能成为好的投资。关键在于知道何时会出现这样的结果。很简单：以营利为目的聪明地承担风险，长期反复成功的记录就是最好的验证。</p>

<p>贯穿长期投资成功之路的，是风险控制而不是冒进。在整个投资生涯中，大多数投资者取得的结果将更多地取决于致败投资的数量及程度，而不是制胜投资的伟大。良好的风险控制是优秀投资者的标志。</p>

<p>我认为，牢记万物皆有周期是至关重要的。我敢肯定的东西不多，但以下这些话千真万确：周期永远胜在最后。任何东西都不可能朝同一个方向永远发展下去。树木不会长到天上。很少有东西归零。坚持以今天的事件推测未来是对投资者健康最大的危害。</p>

<p>当形势良好、价格高企时，投资者迫不及待地买进，把所有谨慎忘在脑后。随后，当四周一片混乱、资产廉价待沽时，他们又完全丧失了承担风险的意愿，迫不及待地卖出。永远如此。</p>

<p>在我的职业生涯之初，一位经验丰富的投资者告诉过我，牛市有三个阶段。在此和读者分享。</p>

<p>第一阶段，少数有远见的人开始相信一切会更好。</p>

<p>第二阶段，大多数投资者意识到进步的确已经发生。</p>

<p>第三阶段，人人断言一切永远会更好。</p>

<p>在我初次了解牛市三阶段的35年之后，在次贷的缺陷已经暴露、人们担心危机将会蔓延全球之后，我总结出了它的对立面—熊市的三个阶段：</p>

<p>①少数善于思考的投资者意识到，尽管形势一片大好，但不可能永远称心如意。</p>

<p>②大多数投资者意识到势态的恶化。</p>

<p>③人人相信形势只会更糟。</p>

<p>我们能够肯定的事情之一是，极端市场行为会发生逆转。相信钟摆将朝着一个方向永远摆动—或永远停留在端点的人，最终将损失惨重；了解钟摆行为的人则将受益无穷。</p>

<p>避免在泡沫中赔钱的关键是，当贪婪和人为错误导致积极因素被高估、消极因素被忽视时，拒绝跟风。做到这一点并不容易，因此弃权的人并不多。同理，对在暴跌中恐惧过度的投资者来说，关键是避免卖出—也许更恰当的做法是买进。（这一点提醒了我。需要指出的是，泡沫可以自行产生，不一定是崩溃的必然结果，但崩溃一定是泡沫的必然结果。）</p>

<p>对于大多数人来说，在科技泡沫时，抵制买进的诱惑很难；在信贷危机全面展开时，抵制卖出的欲望更难—此时买进的难度还要更胜一筹。</p>

<p>那你该用什么样的武器提高自己的胜算呢？以下是在橡树资本管理公司行之有效的方法：</p>

<p>①对内在价值有坚定的认识。</p>

<p>②当价格偏离价值时，坚持做该做的事。</p>

<p>③足够了解以往的周期—先从阅读和与经验丰富的投资者交谈开始，之后通过经验积累—从而了解市场过度膨胀或过度萎缩最终得到的是惩罚而不是奖励。</p>

<p>④透彻理解市场对极端市场投资过程的潜在影响。</p>

<p>⑤一定要记住，当事情看起来“好到不像真的”时，它们通常不是真的。</p>

<p>⑥当市场错误估价的程度越来越深（始终如此）以致自己貌似错误的时候，愿意承受这样的结果。</p>

<p>⑦与志趣相投的朋友或同事相互支持。</p>

<p>在别人沮丧地抛售时买进、在别人兴奋地买进时抛售需要最大的勇气，但它能带来最大的收益。</p>

<p>因此，投资成功的关键在于逆势而行：不从众。那些意识到他人错误的人可以通过逆向投资而获利丰厚。</p>

<p>接受逆向投资概念是一回事，把它应用到实际中则是另一回事。</p>

<p>首先，我们永远不知道市场的钟摆能摆多远，也不知道它在发生逆转的时候会向反方向摆多远。</p>

<p>其次，我们可以肯定的是，一旦市场达到极端，它最终会摆回（或超过）中点。认为市场会沿着同一方向永远摆动或者到达端点时便停留在那里的投资者必定会失望。</p>

<p>最后，由于影响市场的各种因素的易变性，没有任何工具（包括逆向投资）是完全靠得住的。</p>

<p>逆向投资并不是一种让你永远稳赚不赔的方法。在大多数情况下，没有值得下注的过度市场。</p>

<p>最后，仅仅做与大众相反的投资是不够的。考虑到刚刚提到的逆向投资的各种困难，你必须在推理和分析的基础上，辨别如何脱离群体思维才能获利。你必须保证自己在进行逆向投资的时候，不仅知道它们与大众的做法相反，还知道大众错在哪里。只有这样你才能坚持自己的观点，在立场貌似错误或损失远高于收益的时候，才有买进更多的可能。</p>

<p>作为逆向投资者，我们的任务就是尽可能谨慎熟练地接住下落的刀子。这也是内在价值的概念如此重要的原因。如果我们对价值的认识能够让我们在别人都在卖出的时候买进—并且如果我们的观点事后被证明是正确的—那么这就是以最低风险获取最高回报的途径。</p>

<p>并不是总有伟大的事情等着我们去做，有时我们可以通过敏锐的洞察和相对消极的行动将成果最大化。耐心等待机会—等待便宜货—往往是最好的策略。</p>

<p>所以在这里我要提醒你：等待投资机会到来而不是追逐投资机会，你会做得更好。在卖家积极卖出的东西中挑选，而不是固守想要什么才买什么的观念，你的交易往往会更为划算。</p>

<p>买进的绝佳机会出现在资产持有者被迫卖出的时候，在经济危机中这样的人比比皆是。资产持有者出于以下原因，一次又一次地成为强制卖家：</p>

<p>①他们管理的基金被撤销。</p>

<p>②投资组合不符合投资规定，例如不满足最低信用评级或最高仓位限制。</p>

<p>③因为资产价值低于与出借方在合约中约定的金额而收到追加保证金通知。</p>

<p>在危机中关键要做到远离强制卖出的力量，并把自己定位为买家。为达到这一标准，投资者需要做到以下几点：坚信价值，少用或不用杠杆，有长期资本和顽强的意志力。在逆向投资态度和强大资产负债表支撑下，耐心地等待机会，便能在灾难中收获惊人的收益。</p>

<p>我坚定地相信了解宏观未来很难，很少人拥有可转化为投资优势的知识。不过我要补充两点：</p>

<p>①对细节关注越多，越有可能获得知识优势。通过勤奋的工作和专业的技术，我们能比旁人知道更多关于个别公司和证券的信息，但想要在对于整个市场和经济的认知上做到这一点就很难。</p>

<p>②投资者应尽量弄清自己在周期和钟摆中所处的阶段。这不会令未来变得可知，但它能帮助人们为可能的发展作好准备。</p>

<p>也许马克·吐温说得最好：“人类不是被一无所知的事所累，而是被深信不疑的事所累。”</p>

<p>如果能够成功预测钟摆的摆动并采取正确的行动该多好，但这无疑是一个不切实际的愿望。我认为以下做法更为合适：</p>

<p>第一，当市场已经到达极端的时候，保持警惕；</p>

<p>第二，相应地调整我们的行为；</p>

<p>第三，最重要的是，拒绝向导致无数投资者在市场顶部或底部犯下致命错误的群体行为看齐。</p>

<p>投 资领域并不是一个未来可以预见、特定行为总能产生特定结果的有秩序有逻辑的地方。事实上，投资很大程度上受运气支配。有些人喜欢把它叫做“偶然性”或“随机性”，这些词听起来的确比“运气”更加高深。但归根结底它们都是同一件事：我们作为投资者所取得的成功深受偶然因素的影响。</p>

<p>短期来看，很多投资之所以成功，只是因为在对的时间做了对的事情。我一直在说，成功的关键在于进取精神、时机和技能，而某些在对的时间有足够进取精神的人不需要太多技能。</p>

<p>考虑到我们不能确切地预知未来，我们必须通过坚定持股、分析性认识持股、在时机不佳时减少买入等途径来保持我们的价值优势。</p>

<p>为了提高成功机会，我们必须在市场极端情况下采取与群体相反的行动：在市场低迷时积极进取，在市场繁荣时小心谨慎。</p>

<p>与世界不确定的认识相伴而行的其他表现为：适度尊重风险，知道未来不能预知，明白未来是概率分布的并相应地进行投资，坚持防御性投资，强调避免错误的重要性。在我看来，这就是有关聪明投资的一切。</p>

<p>随机性（或者运气）对结果起着巨大的作用，应区别对待随机事件与非随机事件带来的结果。</p>

<p>防御型投资有两大要素。第一要素是排除投资组合中的致败因素，最好的实现方法是：广泛尽职调查、提高入选标准、要求低价和高错误边际（见本章后文），不要轻易下注在没有把握的持续繁荣、乐观预测和发展上。</p>

<p>第二要素是避开衰退期，特别要避免暴露在崩溃危机下。除了前面提到的要排除投资组合中的致败投资外，防守还需要投资组合多元化、限制总风险承担并以整体安全为重。</p>

<p>集中化（多元化的反义词）和杠杆是进攻的表现。它们起效时会扩大收益，反之会增加损失；积极进取策略会导致投资结果比高点更高或比低点更低。不过，如果过度使用积极进取策略，在形势恶化时它们可能会危害投资生存。相反，防守能够提高你渡过难关的可能性，你会有足够长的时间来享受聪明的投资带来的最终回报。</p>

<p>这里还有一种阐述错误边际的方法。你发现一些你认为会值100美元的东西。如果用90美元买进，你就得到一个获利的好机会，同时，如果你的推断过于乐观，也会有一定的损失概率。但是如果你用70美元而不是90美元买进，你的损失概率就会减少。减少的这20美元为失误提供了额外的空间，同时仍然有很好的获利机会。低价是错误边际的源泉。</p>

<p>关键是平衡。投资者除了防守外，还需要进攻，但这并不意味着他们无须重视二者的比重。投资者如果想获取更高收益，通常要承担更多的不确定性—更多的风险。投资者如果想得到高于债券收益的收益，他们就不可能单纯靠规避损失来达到目的。一定的进攻是需要的，随之而来的就是不确定性的提高。选择怎样的投资方式，需要谨慎而明智地做出决策。</p>

<p>相反，在橡树资本管理公司，我们坚定地认为“避免致败投资，制胜投资自然会来”。这是我们最初的也是永远的信条。我们追求安打率，而不是“本垒打”。我们知道其他人会因为巨大的胜利和辉煌的赛季而占据头条，但是我们希望自己能以令客户满意的持之以恒的良好表现坚持到最后。</p>

<p>因此大多数投资者是根据既往—尤其是近期发生的事—推断未来。为什么是近期？第一，许多重要金融现象的周期较长，意味着在下一轮周期重现之前，那些经历过极端事件的人往往已经退休或死亡。第二，正如约翰·肯尼斯·加尔布雷思所说，金融记忆往往极其短暂。第三，所有曾经的记忆往往都会被最新热门投资轻松赚钱的承诺抹除。</p>

<p>投资者往往意识不到贯穿投资组合的共同线索。人人都知道，如果一家汽车制造商的股票下跌，共同因素将会导致所有的汽车股同时下跌。很少有人知道令所有美股（或所有发达国家股票，或全世界所有股票，或所有股票和债券等）下跌的共同因素是什么。</p>

<p>杠杆会放大收益，但不会增加价值。利用杠杆大力投资高承诺收益或高风险溢价的特价资产是很有意义的。但是利用杠杆买进过多低收益或低风险价差的资产—换句话说，已经被完全定价或过高定价的资产—可能是非常危险的。企图利用杠杆把低收益转化为高收益的尝试是毫无意义的。</p>

<p>尽管得不到优异的表现，但在衰退的市场中，人类的天性令防御型投资者及其客户因损失比别人少而得到安慰。这会产生两个重要影响。第一，令他们保持镇定，抵抗往往导致人们在低点抛售的心理压力。第二，令他们维持更好的心态与财务状况，更有能力逢低买进，在杀戮中获利。因此，他们通常在复苏期做得更好。</p>

<p><img src="http://kobe1941.github.io/images/2020/05/03/2.png" alt="" /></p>

<p>这一矩阵的关键是收益的对称性或不对称性。缺乏技术的投资者赚到的收益仅仅是市场收益以及他们风格使然。没有技术的激进型投资者会朝两个方向大幅波动，防御型投资者则朝两个方向小幅波动。这些投资者在他们的风格之外没有任何贡献。当他们的风格受欢迎时会表现良好，反之则表现不佳。</p>

<p>在投资中，一切都有利有弊并且是对称的，只有卓越技术除外。只有依靠技术才能保证在有利环境中的收益高于在不利环境中的损失。这就是我们寻找的投资不对称性。卓越技术是获得不对称投资的先决条件。</p>

<p>成功的投资或成功的投资生涯的基础，是价值。你必须清楚地认识到你想买进的东西的价值。价值包括很多方面，并且有多种考察方法。简单来说，就是账面现金和有形资产价值，公司或资产产生现金流的能力，以及所有这些东西的增值潜力。</p>

<p>你必须以可靠的事实和分析为基础，建立并坚持自己的价值观。只有这样，你才能知道买进和卖出的时机。只有拥有良好的价值感，你才能培养在资产价格高涨并且人人认为会永远上涨的时候获利的纪律，或在危机时甚至价格日益下跌时持仓，并以低于平均价格买进的勇气。当然，为达到在这些情况下获利的目的，你对价值的估计必须准确。</p>

<p>价格和价值的关系是成功投资的关键。低于价值买进是最可靠的盈利途径，高于价值买进则很少奏效。</p>

<p>在价值坚挺、价格低于价值以及普遍消极心理的基础上买入，很有可能会取得最好的投资结果。然而，即使这样，在形势按照我们的预期发展之前，也可能会有很长一段时间对我们不利。“定价过低”绝不等同于“很快上涨”。这就是我第二句重要的格言：“过于超前与犯错没有区别。”在证明我们的正确性之前，我们需要足够的耐心与毅力长期坚持我们的立场。</p>

<p>投资成功的基本要求之一，也是最伟大的投资者的必备心理之一，是认识到我们无法预知宏观未来。很少有人（如果有的话）对未来经济、利率、市场总量有超越群体共识的看法。因此，投资者的时间最好用在获取“可知”的知识优势上：行业、公司、证券的相关信息。你对微观越关注，你越有可能比别人了解得更多。</p>

<p>很多投资者认为自己知道经济和市场的未来走势（并采取相应的行动），实则不然。他们根据自己对未来的认识采取积极的行动，但很少能够取得理想的结果。建立在坚定但不正确的预测基础上的投资，是潜在损失的根源。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[巴菲特致股东的信]]></title>
    <link href="http://kobe1941.github.io/blog/letter-by-buffett.html"/>
    <updated>2020-04-11T20:41:32+08:00</updated>
    <id>http://kobe1941.github.io/blog/letter-by-buffett</id>
    <content type="html"><![CDATA[<p>摘自巴菲特写给股东的信，截止到2020年，1973年到1976年的信因为没有译文没看所以未记录。</p>

<p>按巴菲特的说法，与教科书中的组织行为规则相反，为一家特定的公司环境指定一条抽象的命令链收效甚微。要紧的是选择能干、诚实而且勤勉的人。在团队中拥有一流的成员，远比设计等级制度、明确谁向谁汇报什么以及在什么时候汇报重要得多。</p>

<!--more-->

<p>如果你的假设是正确的，你掌握的事实是正确的，你的推论是正确的，那么经过许多 次的交易后，你将最终是正确的。</p>

<p>我们所尊崇的配置原则是:最优资产组合应由不同的投资选择的可获得性以及预期收 益所决定，同时还要考虑最终实现的资产组合所导致的业绩波动在可以承受的范围之内。 所选择的投资标的越多，投资业绩的结果和预期的年度波动就会越小，但与此同时所预期 的收益水平也会降低(假设不同的选择所对应的标的有着不同的预期收益)。</p>

<p>就我们的情况而言，也许我们的业绩在某一年会有较大的波动，但是我相信这个副作用的结果是:长期而言我们将获得超越市场平均水平的满意的回报率。</p>

<p>我们不会将我们持有的证券以一个被低估的价格抛售，即便某个星象学家声称市场将 会下降，而且总有些时候他们的预测是正确的。我们也不会以一个已经合理反映了公司股 票价值的价格买入任何股票，哪怕有专家声称市场将会上涨。有哪个人在购买私人公司的 时候是根据股市的上涨或是下降的趋势做出购买决定的呢?随着市场的上涨或下降，公司 的核心价值并未见得会有很大的改变，我们所要做到就是利用市场的非理性而获利。</p>

<p>所以如果真正要赚大钱，那么投资者除了要能做出正确的定性分析，就我的观点来说，可能更确定的利润仍来自于明确的定量决策 。</p>

<p>即对于个人动机的考虑。当我开始这项事业时我为自 己设定的目标是长期的年均复合收益率超越道琼斯指数 10 个百分点 。</p>

<p>具体而言，我们的长远目标是取得不超过 9%的年均回报率，或者取得不低于道琼斯指 数 5%的回报率。因此，如果未来 5 年道琼斯指数年均增长率为-2%，则我所期望获得的年 均增长率将为+3%。而如果道琼斯指数的年均增长率为 12%，则我期望的我们的年均增长率 将为 9%。这便是我对于目前的情况对我们未来的收益做出的期望。此外，我希望通过限制 投资的标的来限制我的工作量(至少我知道相反的情况必然是成立的)。 ——1967年</p>

<p>在 1967 年 10 月的信中我亦提到个人境遇的变化是我调整我们未来收益预期的最重要 的原因。</p>

<p>最后，优异的 管理人往往也只能取得略胜于市场平均水平的业绩。</p>

<p>在我整个的投资生涯中，我第一次感到对于一般的投资者而言，对于被动地投资债券 和投资有专业人士管理的股票，几乎没有太大的差别。</p>

<p>保险这行业虽然小错不断，但大致上还是可以获得不错的成果，就某些 方面而言，这情况与纺织业刚好完全相反，管理阶层相当优秀，但却只能获得微薄的利润， 各位的管理阶层所学到的一课，很不幸一再学到的就是，选择顺风而非逆风产业环境的重要 性。</p>

<p>我们投资股票的选择方式与买进整家企业的模式很相近，我们想要的企业必须是(1)我们 可以了解的行业(2)具有长期竞争力(3)由才德兼具的人士所经营(4)吸引人的价格 。我们从来 不试着去买进一些短期股价预期有所表现的股票，事实上，如果其企业的表现符合我们的预 期，我们反而希望他们的股价不要太高，如此我们才有机会以更理想的价格买进更多的股权。</p>

<p>纺织业的现况充分地说明了教科书中提到的，当资本密集但产品无重大差异化的生产 者注定将赚取微薄的报酬，除非供给吃紧或真正短缺，只要市场产能过剩，产品价格就会随 直接营运成本而非投入资金作变动，不幸的是这样的情况正是目前纺织业的常态，所以我们 只能期望获取稍微合理的投资报酬即可。</p>

<p>我们希望以后不要再介入这类产业面临困境的企业，但就像之前曾经提到的，只要(1) 该公司为当地非常重要的雇主(2)管理当局坦诚面对困境并努力解决问题(3)劳工体认现况并 极力配合(4)相对于投入的资金，尚能产生稳定现金收入。只要以上前提存在，我们也相信 一定会，我们就会继续支持纺织事业的营运，虽然这样将使得我们被迫放弃其它更有利的资 金运用管道。</p>

<p>我们判断一家公司经营好坏的主要依据，取决于其股东权益报酬率(排除不当的财务 杠杆或会计作帐)，而非每股盈余的成长与否 。</p>

<p>最后在经过多次惨痛的教训之后，我们得到的结论是，所谓有 “转机”(Turn-arounds) 的 公司，最后显少有成功的案例，所以与其把时间与精力花在购买廉价的烂公司上，还不如 以合理的价格投资一些体质好的企业。 ——说的是伯克希尔的纺织业务</p>

<p>一家公司往往会吸引同类型的人成为其股东，若公司注重的是短期的成果或 是股价的波动，则具有这种特色的投资人便会自动上门成为其股东，而若公司对其股东采 取轻蔑的态度，最后投资大众亦会以相同的态度回报之。</p>

<p>一家公司亦不可能同时迎合所有投资大众的口味，有的要高股利报酬、有的要长 期资本成长，有的又要短期股价爆炸性成长。</p>

<p>从个人的经验与观察得到一个结论，那就是一项优异的记录背后(从投资报酬率的角度 来衡量)你划的是一条怎样的船更胜于你怎样去划(虽然不管一家公司好或坏，努力与才能也 很重要) ，几年前我曾说当一个以管理著名的专家遇到一家不具前景的公司时，通常是后者 会占上风，如今我的看法一点也不变，当你遇到一艘总是会漏水的破船，与其不断白费力 气去补破洞，还不如把精力放在如何换条好船之上。</p>

<p>我们从葛拉罕那里学到成功投资的关键 是在买进好的公司股票在其股价相对于代表的实际价值被低估的时候。</p>

<p>事实上我们从来就不知道股市接下来到 底是会涨还是会跌，不过我们确知的是贪婪与恐惧这两种传染病在股市投资世界里，会不 断地发生上演，只是发生的时点很难准确预期，而市场波动程度与状况一样不可捉摸，所 以我们要做的事很简单，当众人都很贪心大作时，尽量试着让自己觉得害怕;反之当众人 感到害怕时，尽量让自己贪心一点。</p>

<p>股票的表现不可能永远超过公司本 身的获利表现，反倒是股票频繁的交易成本与投资管理费用，将使得投资人所获得的报酬 无可避免地远低于其所投资公司本身的获利</p>

<p>再次验证 Disraeli 的名言:「我们唯一从历史得到的教训就是我们从来无法 从历史得到教训!」</p>

<p>每当查理跟我为 Berkshire 旗下的保险公司买进股票(扣除套利交易，后面会再详述)，</p>

<p>我们采取的态度就好象是我们买下的是一家私人企业一样，我们着重于这家公司的经济前 景、经营阶层以及我们支付的价格，我们从来就没有考虑再把这些股份卖出，相反地只要 能够预期这家公司的价值能够稳定地增加，我们愿意无限期地持有这些股份，在投资时我 们从不把自己当作是市场的分析师、总体经济分析师或是证券分析师，而是企业的分析师。</p>

<p>追随格雷厄姆的教诲，查理跟我着眼的是投资组合本身的经营成果，以此来判断投资 是否成功，而不是他们每天或是每年的股价变化，短期间市场或许会忽略一家经营成功的 企业，但最后这些公司终将获得市场的肯定，就像格雷厄姆所说的:「短期而言，股票市 场是一个投票机，但长期来说，它却是一个体重机」一家成功的公司是否很快地就被发现 并不是重点，重要的是只要这家公司的内在价值能够以稳定地速度成长才是关键，事实上越晚被发现有时好处更多，因为我们就有更多的机会以便宜的价格买进它的股份。</p>

<p>我们的目标是以合理的价格买到绩优的企 业，而不是以便宜的价格买进平庸的公司，查理跟我发现买到货真价实的东西才是我们真 正应该做的。</p>

<p>必须特别注意的是，本人虽然以反应快速著称，不过却花了二十年才明白要买下好企 业的重要性，刚开始我努力寻找便宜的货色，不幸的是真的让我找到了一些，所得到的教训 是在农具机械、三流百货公司与新英格兰纺织工厂等经济形态上上了一课。</p>

<p>在为我们的保险事业选择有价证券投资之时，我们主要有五种选择(1)长期股票投资(2) 长期固定收益债券(3)中期固定收益债券(4)短期约当现金(5)短期套利交易 。对于这五种类型的交易，我们没有特别的偏好，我们只是持续不断地寻找最高的税后 报酬预计的数学期望值，且仅限于我们认为了解熟悉的投资，我们无意让与短期的帐面盈 余好看，我们的目标是让长期的净值极大化。</p>

<p>所谓的套利是指在不同的市场同时买卖相同的 有价证券或是外汇，目的是为了撷取两者之间微小的差距，例如阿姆斯特丹的荷兰币、英国 的英镑或是纽约的美元，有些人将此行为称之为剃头皮，但通常这一行的人惯用法国的字汇 -套利。</p>

<p>说了那么多，最后还是要提出一个警告，最近套利看起来相当容易，但它却不是永远都 保证有 20%报酬的投资活动，现在的市场比起过去来的有效率许多，除了我们过去 63 年所 真正掌握的套利活动之外，还有更多是因为价格合理而因此被舍弃掉的。</p>

<p>一个投资者很难只靠单一一种投资类别或投资风格而创造超人的利益，他只能靠着仔 细评估事实并持续地遵照原则才能赚取超额利润，就套利投资本身而言，并没有比选择利 用飞镖选股的策略好到哪里去。</p>

<p>不过到最后，炼金术，不管是冶金的或是财务上的，终究是会落空，一个烂公司不可 能只靠着会计或财务技巧而摇身一变成为好公司，那个宣称会炼金术的财务专业人士或许 会发大财，但他靠的却是容易上当的投资人而不是企业经营。</p>

<p>我可以给各位另外一个个人经验，以合理的价格买下一家好公司要比用便宜的价格买 下一家普通的公司来的好的多，像查理老早就明白这个道理，我的反应则比较慢，不过现在 当我们投资公司或股票时，我们不但选择最好的公司，同时这些公司还要有好的经理人。</p>

<p>从这里我们又学到了一课，好的马还要搭配好骑师才能有好成绩，像 Berkshire 纺织与 Hochschild, Kohn 也都有才能兼具的人在管理，很不幸的他们所面临的是流沙般的困境，若 能将这些人摆在体质更好的公司相信他们应该会有更好的成绩。</p>

<p>我们也相信投资人可以透过研究自己的透视盈余而受益，在算这个东西时，他们就会了 解到其个别投资组合所应分配到的真正盈余的合计数，所有投资人的目标，应该是要建立一 项投资组合可以让其透视盈余在从现在开始的十年内极大化。</p>

<p>这样的方式将会迫使投资人思考企业真正的长期远景而不是短期的股价表现，从而藉 此改善其投资绩效，当然无可否认就长期而言，投资决策的绩效还是要建立在股价表现之 上，但价格将取决于未来的获利能力，投资就像是打棒球一样，想要得分大家必须将注意 力集中到场上，而不是紧盯着计分板</p>

<p>浮存金-我们靠保险业所取得大量的资金，系指将所有的损失准备、损失费用调整准备 与未赚取保费加总后，再扣除应付佣金、预付购并成本及相关再保递延费用，至于浮存金 的成本则是以我们所发生的承保损失来衡量。</p>

<p>著名经济学家凯恩斯，他的投资绩效跟他的理论思想一样杰出，在 1934 年 8 月 15 日 他曾经写了一封信给生意伙伴 Scott 上面写到，随着时光的流逝，我越来越相信正确的投资 方式是将大部分的资金投入在自己认为了解且相信的事业之上，而不是将资金分散到自己 不懂且没有特别信心的一大堆公司，每个人的知识与经验一定有其限度，就我本身而言， 我很难同时有两三家以上的公司可以让我感到完全的放心。</p>

<p>就像是前几年向各位提过的，真正重要的是我们从保险业所取得的资金，其资金成本 到底是多少，套句专业术语，就是浮存金成本，浮存金-系指我们靠保险业所取得大量的资 金，系指将所有的损失准备、损失费用调整准备与未赚取保费加总后，再扣除应付佣金、预付购并成本及相关再保递延费用，至于浮存金的成本则是以我们所发生的承保损失来衡 量。</p>

<p>我们在股权投资的策略跟 15 年前 1977 年度报告的那套一样，并没有多大的变化，在 选择股票投资所采用的评估方式与买下一整家企业的情况没什么两样，我们希望投资的对 象(1)是我们所了解的(2)具有长期的远景(3)由才德兼具的人所经营(4)非常吸引人的合理价 格。但考量目前市场的情况与公司的资金规模，我们现在决定将”非常吸引人的价格”改成” 吸引人的价格”。</p>

<p>成长只有当企业将资金投入到可以增加更多报酬的活动上，投资人才有可能受惠，换 句话说，只有当每投入的一块钱可以在未来创造超过一块钱的价值时，成长才有意义，至 于那些需要资金但却只能创造出低报酬的公司，成长对于投资人来说反而是有害的。</p>

<p>在 John Burr Williams 50 年前所写的投资价值理论当中，老早便已提出计算价值的公 式。我把它浓缩列示如下:今天任何股票、债券或是企业的价值，都将取决于其未来年度 剩余年限的现金流入与流出，以一个适当的利率加以折现后所得的期望值，特别注意这个 公式对于股票与债券皆一体适用，不过这里有一点很重要但却很难克服差异的差异，那就 是债券有债票与到期日可以清楚的定义未来的现金流入，但是就股票而言，投资者必须自己 去分析未来可能得到的票息，更重要的是管理阶层的品质对于债券的影响相当有限，顶多因 为公司无能或是诚信明显不足而延迟债息的发放，但是对于股票投资者来说，管理阶层的能 力将大大影响未来票息发放的能力。</p>

<p>今天先不管价格多少，最值得拥有的企业是那种在一段长的期间可以将大笔的资金运 用在相当高报酬的投资上，最不值得拥有的企业是那种跟前面那个例子完全相反的，在一段长的期间将大笔的资金运用在相当低报酬的投资之上，不幸的是，第一类的企业可遇不 可求，大部分拥有高报酬的企业都不需要太多的资金，这类企业的股东通常会因为公司发放 大量的股利或是买回自家公司的股份而大大地受惠。</p>

<p>就投资而言，人们 应该注意的，不是他到底知道多少，而是应该注意自己到底有多少是不知道的，投资人不 需要花太多时间去做对的事，只要他能够尽量避免去犯重大的错误。</p>

<p>第二点一样很重要，那就是我们在买股票时，必须要坚持安全边际，若是我们所计算 出来的价值只比其价格高一点，我们不会考虑买进，我们相信恩师葛拉罕十分强调的安全 边际原则，是投资成功最关键的因素。</p>

<p>这宗小故事告诉我们必须负担税负的投资人从每年固定以一个比率成长的单一投资上， 可以获得比每年更换投资对象所得的多的多，即便是两者成长的幅度一样也是如此，不过 我怀疑许多 Berkshire 的股东老早就已经知道这个道理了。</p>

<p>我们认为投资人应该真正评估的风险是他们从一项投资在其预计持有的期间内所收到 的税后收入加总(也包含出售股份所得)，是否能够让他保有原来投资时拥有的购买力，再加 上合理的利率，虽然这样的风险无法做到像工程般的精确，但它至少可以做到足以做出有 效判断的的程度，在做评估时主要的因素有下列几点‥</p>

<p>1)这家公司长期竞争能力可以衡量的程度</p>

<p>2)这家公司管理阶层发挥公司潜能以及有效运用现金可以衡量的程度</p>

<p>3)这家公司管理阶层将企业获得的利益确实回报给股东而非中饱私囊可以衡量的程度</p>

<p>4)买进这家企业的价格</p>

<p>5)投资人的净购买力所得，须考虑税负与通货膨胀等因素必须从投资收益总额中扣除的部</p>

<p>份</p>

<p>当然，有些投资策略，例如我们从事多年的套利活动，就必须将风险分散，若是单一交 易的风险过高，就比须将资源分散到几个各自独立的个案之上，如此一来，虽然每个个案都 有可能导致损失或伤害，但只要你确信每个独立的个案经过机率的加权平均能够让你获致满 意的报酬就行了，许多创业投资者用的就是这种方法。</p>

<p>另外一种需要分散风险的特殊情况是，当投资人并没有对任何单一产业有特别的熟悉， 不过他却对美国整体产业前景有信心，则这类的投资人应该分散持有许多公司的股份，同时 将投入的时点拉长，例如，透过定期投资指数基金，一个什么都不懂的投资人通常都能打败 大部分的专业经理人，很奇怪的是，当愚昧的金钱了解到自己的极限之后，它就不再愚昧了。</p>

<p>事实上，我们通常都是利用某些历史事件发生，悲观气氛到达顶点时，找到最好的进 场机会，恐惧虽然是盲从者的敌人，但却是基本面信徒的好朋友。</p>

<p>就像我们在过去年报跟各位解释过的，保险事业最重要的关键，第一是保险浮存金的 数量，第二是它的成本，浮存金是我们持有并非我们所有，保险事业营运之所以能有浮存金 的原因在于大部分的保单都要求保户必须预付保险费，另外更重要的是保险公司在被知会并 真正理赔之前，通常都要经过好长的一段时间。</p>

<p>通常保险公司实际上收到的保费并不足以支应发生的损失与费用，所以大多会产生承保 的损失，而这就是浮存金的成本。</p>

<p>长期而言，保险公司的浮存金成本若能低于其它资金管道所需的成本就能获利，但是 要是其浮存金成本高于货币市场利率的话，其是否有存在的价值就有疑问。</p>

<p>我们的投资组合持续保持集中、简单的风格，真正重要的投资概念通常可以用简单的 话语来作说明，我们偏爱具有持续竞争力并且由才能兼具、以股东利益为导向的经理人所 经营的优良企业，只要它们确实拥有这些特质，而且我们能够以合理的价格买进，则要出 错的机率可说是微乎其微(这正是我们一直不断要克服的挑战)。</p>

<p>投资人必须谨记，你的投资成绩并非像奥运跳水比赛的方式评分，难度高低并不重要， 你正确地投资一家简单易懂而竞争力持续的公司所得到的回报，与你辛苦地分析一家变量 不断、复杂难懂的公司可以说是不相上下。</p>

<p>对于买进股份我们注意的只是价格而非时间，我们认为因为忧虑短期不可控制的经济 或是股市变量而放弃买进一家长期前景可合理的预期的好公司是一件很愚蠢的事，为什么 仅是因为短期不可知的猜测就放弃一个很明显的投资决策呢?</p>

<p>在寻找新的投资标的之前，我们选择先增加旧有投资的部位，如果一家企业曾经好到 让我们愿意买进，我想再重复一次这样的程序应该也是相当不错的。</p>

<p>零售业的经营相当不易，在我个人的投资生涯中，我看过许多零售业曾经拥有极高的 成长率与股东权益报酬率，但是到最后，突然间表现急速下滑，很多甚至被迫以倒闭关门 收场，比起一般制造业或服务业，这种剎那间的永恒在零售业履见不鲜，部份的原因是这 些零售业者必须时时保持聪明警戒，因为你的竞争对手随时准备复制你的做法，然后超越 你，同时消费者绝对不会吝于给予新加入业者尝试的机会，在零售业一但业绩下滑，注定 就会失败。</p>

<p>相对于这种必须时时保持警戒的产业，还有一种我称之为只要聪明一时的产业，举个例 子来说，如果你在很早以前就懂得睿智地买下一家地方电视台，你甚至可以把它交给懒惰又 差劲的亲人来经营，而这项事业却仍然可以好好地经营个几十年 。</p>

<p>任何一家公司的获利能力决定于(1)资产报酬率(2)负债的成本(3)财务杠杆的运用-也就 是其运用负债而非股东权益来支应资产取得的程度。</p>

<p>如果你是那种碰到股市崩盘，会恐慌性的 拋售手中股票的人，我建议你最好不要投资股票，听到坏消息而把手中的好股票卖掉通常 不会是一个明智的决定 。</p>

<p>身为一位投资人，大家其实只要以合理的价格买进一些很容易了解且其盈余在未来五到 十年内会大幅成长的企业的部份股权，当然一段时间下来，你会发现只有少数几家公司符 合这样的标准，所以要是你真的找到这样的公司，那就一定要买进足够份量的股权，在这 期间，你必须尽量避免自己受到外界诱惑而偏离这个准则，如果你不打算持有一家公司股 份十年以上，那最好连十分钟你都不要拥有它，在慢慢找到这样盈余加总能持续累积的投资组合后，你就会发现其市值也会跟着稳定增加。</p>

<p>如果说我们有什么能力，那就是我们深知要在具竞争优势的范围内，把事情尽量做好， 以及明了可能的极限在哪里，而要预测在变化快速产业中经营的公司，其长期的经营前景 如何，很明显的已超过我们的能力范围之外</p>

<p>目前查理跟我不仅不清楚明年我们旗下事业到底能够赚多少钱，我们甚至不知道下一 季的数字，所以我们相当怀疑那些常常声称知道未来会如何如何的人，而如果他们真的每 次都能达到盈余目标，我们反而更怀疑这其中有鬼，那些习惯保证能够达到数字目标的人， 总有一天会被迫去假造数字。</p>

<p>真正的独立，代表的是当企业发生错误或是愚昧的事情时，董事有勇于挑战强势总裁的 勇气，这是担任董事必须具备最重要的特质之一，可惜这种特质极其罕见，要找到这种特 质必须从品格高尚且利益着眼点与一般股东一致的人士，一定要相当一致的才行。</p>

<p>除了要维持独立性，董事们也必须具备丰富的商务经验、以股东利益为导向再加上在这 家公司拥有真正的利益，在这三样条件中，第一项尤为难得，如果缺乏这一项，其它两项 的作用就不大</p>

<p>我们的成绩之所以能够这么出色，只有一个原因，那就是我们拥有真正杰出的经理人，保 险公司贩售的是不具任何独特性的保单，任何人都可以仿制类似的产品，没有固定的基础、 重要的专利、不动产或任何自然资源来保护现有竞争优势，而通常品牌的重要性也不那么 明显。 因此真正关键的因素还在于管理者的智能、纪律以及品格。</p>

<p>你可能记得 2003 年的时候，硅谷很流行一个车贴:―神啊，求求你再给个泡沫吧‖。很不 幸，这个愿望很快就成真了:几乎所有的美国人都认为房价会永远上涨，这种坚信不疑令 借款人的收入和现金损益表对放贷机构无足轻重，他们大把大把的把钱借给别人，相信房 价上涨(HPA， house price appreciation)会解决所有问题。今天，我们国家里不断蔓延的 痛苦，正是源于这种错误的信心。随着房价的下跌，大量愚蠢的金融问题被曝光。对此你能 学到经验就是:只有在退潮的时候，你才能看出哪些人在裸泳。我们目睹那些最大金融机 构的现状，简直是―惨不忍睹。</p>

<p>查理和我要寻找的公司是 a)业务我们能理解;b)有持续发 展的潜质;c)有可信赖有能力的管理层;d)一个诱人的标价。我们倾向买下整个公司，或 者当管理层是我们的合伙伙伴时，至少买下 80%的股份 。——指并购</p>

<p>一家真正伟大的公司必须要有一道―护城河‖来保护投资获得很好的回报。但资本主义的 “动力学”使得，任何能赚去高额回报的生意“城堡”，都会受到竞争者重复不断的攻击。因 此，一道难以逾越的屏障，比如成为低成本提供者，象盖可保险(CEICO)或好事多超市 (Costco),或者拥有象可口可乐、吉利、美国运通这样晓誉世界的强大品牌，才是企业获 得持续成功的根本。</p>

<p>我们对―持续性‖的评判标准，使我们排除了许多处在发展迅速，且变化不断行业里的公司。 尽管资本主义的―创造性的破坏‖对社会发展很有利，但它排除了投资的确定性。一道需要不断重复开挖的“护城河”，最终根本就等于没有护城河。</p>

<p>但是如果一 个生意，依赖一个超级巨星才能产生好成效，那这个生意本身不会被认为是个好生意。</p>

<p>我们要寻找的生意，是在稳定行业中，具有长期竞争优势的公司。如果它的成长迅速， 更好。但是即使没有成长，那样的生意也是值得的。我们只需简单地把这些生意中获得的 可观收益，去购买别处类似的企业。这里没有什么规定说，钱是哪儿挣来的，你就必须花 在哪儿。事实上，这样的做法通常是一个错误:真正伟大的生意，不但能从有形资产中获 得巨大回报，而且在任何持续期内，不用拿出收益中的很大一部分再投资，以维持其高回报率。</p>

<p>我知道电视台也是象喜诗糖果 那样的生意，实际上不需要什么投资，就会获得可观的增长前景，它们很容易运营并且为 所有人带来滚滚财富。</p>

<p>84 岁的查理和 77 岁的我，拥有的幸运超过了我们的梦想。我们都出生在美国;都有非 常了不起的父母，让我们能获得良好的教育;都有美满的家庭和健康的身体;都有一些“商 业”基因，让我们取得了某种其他人未经历过的巨大成功，这些人对我们社会福利的贡献， 并不逊于我们，甚至比我们更多。而且，我们都热衷于做着我们热爱的工作，并有无数杰 出的和令人愉快的同事协助。对于我们，每天都是那样令人兴奋;所以不要惊讶，看到我 们跳着踢踏舞(tap-dance)去上班。不过对我们，没有比在伯克希尔每年的股东大会上， 与我们的持股合伙人欢聚一堂，更让人兴奋的了。 ——2007年</p>

<p>巨大 的机会是很少发生的。当天上掉金子的时候，应该拿桶去接，而不是管子。</p>

<p>恐慌的氛围是投 资最好的朋友。</p>

<p>世界末日的语言家们忽略了一个最重要的因素，这也 是一个确定的因素:人类的潜能是取之不尽用之不竭的，用来释放这种潜能的 美国制度永葆活力和高效(这种美国制度在两个多世纪里一直在创造奇迹，尽管由于经济衰退甚至美国内战而经常中断)。</p>

<p>对冲基金见证了普通合伙人的可怕行 径，他们在上涨时获得利润，在下跌时让有限合伙人丧失此前的收益。有些普通合伙人会 立即开设另一个对冲基金，套取预期利润，而不顾及过去的损失。把资金托付给这种经理 人的投资者实际上成了替罪羊，而不是合伙人。</p>

<p>毫无疑问，有些人通过借钱投资成为巨富，但此类操作同样可能使你一贫如洗。杠杆 操作成功的时候，收益就成倍放大，配偶觉得你很聪明，邻居也艳羡不已。但它会使人上 瘾，一旦你从中获益，就很难回到谨慎行事的老路上去。而我们在三年级(有些人在 2008 年金融危机中)都学到，不管多大的数字一旦乘以 0 都会化为乌有。历史表明，无论操作者 多么聪明，金融杠杆都很可能带来”0”。</p>

<p>对企业来说，金融杠杆也可能是致命的。许多负债累累的公司认为债务到期时可以靠继 续融资解决，这种假定通常是正常的。可一旦企业本身或者全球信用出现危机，到期债务就 必须如约清偿，届时只有现金才靠得住。</p>

<p>信贷就像氧气，供应充沛时，人们甚至不会加以注意。而一旦氧气或信贷紧缺，那就 成了头等危机。即使短暂的信贷危机也可能使企业崩溃，事实上，2008 年 9 月一夜之间席 卷多个经济部门的信贷危机使整个美国都濒临崩溃。</p>

<p>由于我们对利用金融杠杆持谨慎态度，我们的回报率略受影响，但拥有大量现金使我们 得以安枕无忧。在偶尔爆发的经济危机中，其他公司都为生存而挣扎，而我们拥有充沛资金 和精神准备去发动攻势。2008 年雷曼兄弟破产后市场一片恐慌，而我们得以在 25 天内投资 了 156 亿美元。</p>

<p>投资行为被形容这样一个过程:在今天投出资金，预期未来能收回更多的钱。在伯克 希尔，我们对此要求更高，我们将投资定义为将今天的购买力转移给他人而预期在未来收 到合理的购买力(扣除对名义收益的税收)。更简洁的说法是，投资是放弃今天的消费， 为了在以后的日子里能够有能力更多的消费。</p>

<p>第二类投资包括的资产是指那些实际不产生任何收益，但买家在认为其他人未来会为 此支付更高的价格的期望下所购买的资产，这些买家也清楚这些资产永远不具有生产性。 17 世纪的郁金香就是此类买家的最爱。</p>

<p>然而黄金有两个显著的缺点，用途不广且不具有生产性。 确实，黄金有一些工业和装饰的用途，但此类用途的需求优先，且不足以吸收新的产量。同时，如果你一直持有一盎司黄金，到最后你将仍然只拥有一盎司。</p>

<p>我自己最青睐的——你知道，就要讲到了——是我们的第三类资产:投资于有生产力的 资产，无论是企业、农场，还是房地产。在理想的情况下，这些资产应该能在通胀时期让 产出保持自身的购买力价值，同时只需要尽可能最少的新增资本投入。</p>

<p>在伯克希尔，我们更希望拥有一家好公司的部分非控制性股权，而不是拥有一家二流公司100%的股权。宁选“碎玉”，不要“全瓦”。</p>

<p>一个稳健的保险公司需要遵守四大规则：它必须（1）理解所有会让保单发生损失的风险；（2）谨慎的评估风险发生的可能性以及其可能造成的损失；（3）设定保费。平均而言，保费需要高于可能发生的损失以及运营费用的总和；（4）愿意在无法获得合适保费的情况下放手。</p>

<p>许多保险公司都遵守前三条规则，却忽视了第四条。他们无法拒绝竞争对手正在积极争取的业务。</p>

<p>2014年，我们的子公司总计在生产设备上投入了创纪录的150亿美元，超过折旧费用两倍多。其中大约有90%的资金是用在了美国国内。<strong>尽管我们会开展海外投资，但公司发展机遇的主矿脉还是绵延在美国。我们深信，与依然潜藏在地下的宝藏规模相比，目前所开采的宝藏仅为沧海一粟。苍天垂青，我和查理生来就是美国公民，我们对此如天赐之福般的“美国人优势”永怀感念。</strong></p>

<p><strong>我们市场经济的动力机制仍将继续发挥它的魔力。要收获总要经历挫折，不可能一帆风顺。人们会时不时抱怨政府。但确定无疑的是，美国的明天会更好。</strong></p>

<p>在这种有利形势下，查理和我希望通过以下途径提升伯克希尔的每股内在价值：(1)持续改善我们众多子公司的基本盈利能力；(2)通过补强型收购进一步提升它们的盈利；(3)从我们投资对象的增长中获益；(4)当伯克希尔股价大幅低于内在价值时进行股份回购；(5)偶尔进行大规模收购。我们还会尝试通过增发伯克希尔股份让你的收益最大化，不过这种做法就算有也是偶尔为之。</p>

<p>我们都知道，搭积木关键在于基础稳固。<strong>一个世纪之后，BNSF和伯克希尔哈萨维能源公司仍将继续在美国经济中扮演重要角色。住房和汽车仍将是大部分家庭生活的中心。保险无论对企业还是个人都将依然不可或缺。</strong>展望未来，查理和我看到伯克希尔仍将大有用武之地。我们对受托管理伯克希尔深感荣幸。</p>

<p>获取满意的投资回报不需要成为专家。当然如果大家本身不是专家，那就要认识到自 己的能力圈，并遵从一个合理的规律。保持简单，不要揠苗助长。当有人承诺让你赚 笔快钱时，立即答复“不行”。</p>

<p>关注拟投资资产未来的产出。如果大家觉得难以估计一项资产的未来盈利，那就忘了 它，放弃它。没有人能估计所有的投资回报。无所不知也是不需要的；大家只需要理 解自己的行为就可以。</p>

<p>总结宏观形势，听信别人的宏观或者市场预测都是浪费时间。实际上，这甚至是危险 的，它会模糊大家对真正重要的事实的看法。（每当我听到电视评论员流利地分析着 市场的下一步走势，我就会想起 Mickey Mantle⑩犀利的评论“你不坐到直播间里去都 不知道原来棒球比赛这么简单”。）</p>

<p>认清自己“能力圈”的半径，并且呆在能力圈里面非常重要。即便做到了，有时候我们还是 会犯错误，无论买股票还是收购公司。但是这样不会带来灾难，就像一个持续上涨的牛市诱 导大家根据价格走势买股票，或者因为需要有所行动的欲望买股票那样。</p>

<p>无论是机构还是个人，都会被赚取咨询和交易费的中介结构不断怂恿，不停地交易。对投资 者来说，这些费用总和非常巨大，它吞噬了利润。所以，忽略那些建议吧，保持最低的交易 成本，并且像持有农场那样持有股票。</p>

<p>贷款人对于拥有一个家的强烈的渴望是我们持续经营房屋按揭贷款业务的主要原因之一。同时我们可以浮息债券和短期固息债券为这些按揭贷款融资。最终我们在近年来极低的短期利率和按揭贷款收入之间操作范围越来越大，这就会催生固定利率。</p>

<p><strong>每隔大约十年时间，经济环境就会出现恶化。但随之而来的也有挣钱的良机，这时候我们是绝不会无动于衷的。</strong></p>

<p>在这样可怕岁月里，你们应该牢记两点：首先，大范围的恐慌是作为投资者的你们的朋友，因为它会提供物美价廉的资产；其次，个人恐慌是你的敌人。这是毫无必要的。那些避开高的成本和不必要成本、持有许多大型、适当筹资的企业股票并坐等较长一段时间的投资者们将必定能够获得不错的收益。</p>

<p><strong>我们被财险业务吸引的原因之一是其金融特征：财险公司提前收到保险费，之后再支付理赔金。在极端情况下，例如理赔产生于接触石棉，款项支付可以延续好几十年。这种现在收以后付的模式使得财险公司持有大量流动资金。</strong>与此同时，保险公司能够出于自己的利益进行投资。</p>

<p>有时，来自股东或媒体的言论暗示，伯克希尔·哈撒韦公司将永远持有一些股票资产。事实上，我们持有一些股票，只要我还保持健康就不准备卖掉这些股票。但是，我们并没有做出任何形式的承诺，承诺伯克希尔·哈撒韦公司将永远持有这些可以在市场中自由交易的证券资产。</p>

<p><strong>伯克希尔·哈撒韦公司认为任何在市场中自由交易的证券资产都有可能被出售，尽管目前来看公司不太可能出售这个证券资产。</strong></p>

<p><strong>有三个有关联的事实，使得成功的投资酝酿着失败。首先，良好的投资履历会吸引大量投资资金；其次，巨额的资金总是保证投资业绩之锚：几百万的资金容易管理，几十亿的资金就不好管了；第三，由于大多数经理人的个人认识，即所管理的资金越多，收取的手续费就越多，所以他们仍然会寻求获得新的投资资金。</strong></p>

<p><strong>多年来，经常有人请求我提供投资建议，我通常给的建议是，投资低成本的标准普尔500指数基金。值得肯定的是，我的只有中等收入水平的朋友通常都采纳了我的建议。</strong></p>

<p>我的计算表明<strong>，过去十年里，精英寻求优质投资建议造成的浪费总计超过1000亿美元。</strong>想想看：对几万亿美元的资产即使收取1%的手续费，加起来也有这么多。</p>

<p>人类的行为不会改变。富有的个人、养老基金、捐赠基金等仍然会认为，他们应该获得一些“额外”的投资建议。那些巧妙地利用了这种心理的顾问将变得非常富有。今年的魔药可能是对冲基金，明年可能又是别的什么。</p>

<p>有一句格言预测了夸口作出这些承诺可能带来的结果：<strong>“当一个有钱的人遇到一个有经验的人时，有经验的人最终会获得金钱，而有钱的人会带着经验离开。”</strong></p>

<p>早些时候，我已经解释过伯克希尔·哈撒韦从一家<strong>通过投资行为获得大部分利益的公司逐渐转移至通过持有公司而使得后者价值提升的过程。</strong></p>

<p>你们不需要是经济学家，就能了解我们的系统运作得多好。看看你们周围，看看这7500万套自有住房、肥沃的农田、2.6亿辆汽车、超高生产力的工厂、健全的医疗中心、人才济济的大学，它们都意味着美国人从1776年贫瘠的土地、原始社会结构和贫弱的生产力起点至今获得的纯利。白手起家的美国人已经累积了共计90万亿美元的财富。</p>

<p>当然，那些有车有房以及拥有其他资产的美国人们往往为了买这些负债累累，这也是事实。然而，如果一个美国人违约，他或者她的资产并不会消失或者丧失其可用性。通常，所有权会转给借贷机构，之后该机构再转卖一个美国人买家。我们国家的财富仍然完好无损。正如格特鲁德-斯泰因指出得那样，“钱总在那里，只是装钱的口袋不断变化”。</p>

<p>我们卖掉任何一家出色的公司都是愚蠢的，即 使出售它不需要缴任何的税。真正优秀的企业非常难找到。 卖掉任何你足够幸运才拥有的东西是毫无意义的。</p>

<p>查理和我高兴地承认，伯克希尔的成功在很大程度上只 是我认为应该被称为“美国顺风”的产物。</p>

<p><strong>投资者需要的是一种既能无视大众的恐惧或热情，又能专注于一些简单的基本面的能力。愿意在一段时间内，看起来像是缺乏想象力的甚至是愚蠢的，也是至关重要的。</strong></p>

<p>有时，对某只股票的收购价格过高会导致一家辉煌的企业沦为一项糟糕的投资 – 其痛苦如果不是永久的话，至少会持续很长时间。</p>

<p>此外，我们还在持续寻求买进新的企业的机会，只要后者能够符合三个标准。首先，他们运营的净有形资本必须能够创造得体的回报。其次，经理人必须是德才兼备，既有能力又诚实。最后，买进价格必须合理。</p>

<p>一旦我们找到了这样的企业，只要条件允许，我们都会希望将其100％全部收购下来。遗憾的是，符合我们前面全部要求的大规模收购机会其实颇为稀有。在更多的时候，我们还是只能去把握住股市波动当中涌现出的机会，去收购那些符合标准的上市公司的大量股份，但是往往并不能达到控股的程度。</p>

<p><strong>当我们考虑到华尔街的建议时，一个古老的警告永远是正确的：不要问理发师你是否需要理发。</strong></p>

<p>1924年，一位名声并不是那么显赫的<a href="http://finance.jrj.com.cn/people/peopleList2.shtml">经济学家</a>、理财顾问埃德加·劳伦斯 ·史密斯（Edgar Lawrence Smith）完成了一本《普通股的长期投资》（Common Stocks as Long Term Investments），这虽然只是一本薄薄的册子，但是却改变了整个投资世界的面貌。事实上，撰写这本书的经历也改变了史密斯本人，迫使他开始重新评估自己的投资信条。</p>

<p>刚开始写作的时候，他最初想要说明的观点是，在通货膨胀周期当中，股票的表现要好于债券，而在通货紧缩周期当中，债券的回报则好过股票。看上去，这样的观点是合情合理的。可是接下来，史密斯自己都吃了一惊。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《斯坦福极简经济学》]]></title>
    <link href="http://kobe1941.github.io/blog/the-instant-economist.html"/>
    <updated>2020-03-14T20:08:29+08:00</updated>
    <id>http://kobe1941.github.io/blog/the-instant-economist</id>
    <content type="html"><![CDATA[<p>本书整体上比较鸡肋，书名和内容不太符合，缺少趣味性，也不能指导普通人的日常生活决策，或者解释一些日常生活中遇到的现象。跟我最初买它的目的不符。</p>

<!--more-->

<p>1.自利是组成社会的有效方式。经济学始祖亚当斯密曾说：“每个人，通常既不打算促进公共利益，也不知道他促进了多少公共利益，他只盘算自己的安全，只盘算自己的获利。而他在这么做的时候，如同很多其他情况，被一只看不见的手引导，去促成一个与他本意无关的目的。虽然与他本意无关，但也不会因此使社会更糟。借由追求自身的利益，他频繁的促进了社会利益，比他认真设想促进社会利益还有效”。</p>

<p>2.如果有个东西你想要少一点，就用租税抑制它；想要多一点，就用补贴鼓励它。</p>

<p>3.所有成本都是机会成本。当你做一个选择时，你没有选择的东西就是经济学家所谓的“机会成本”。</p>

<p>4.价格是由市场决定的，而非生产者。</p>

<p>5.没有哪个人可以得到想要的每样东西，也没有哪个社会可以得到想要的每样东西，因此，取舍是不可避免的。在人们有各种技能与欲望的现代经济社会中，问题在于如何协调决定生产什么、如何生产以及为谁生产。</p>

<p>6.做自己做适合做的事，就有更好的生产力。</p>

<p>7.分工：经济学的一部分，即是了解并分析市场经济每天所协调完成的丰功伟绩。</p>

<p>分工为生产商品和厂商与国家经济创造了显著的经济利益。</p>

<p>分工使工人能聚焦于他们最适合做的事，又使企业能充分利用当地资源。</p>

<p>分工使企业得以利用规模经济。</p>

<p>8.历史数据显示，虽然新技术已经使某些产业与工作被淘汰，但也创造了新的产业与工作。此外，运用这些新技术，能使劳动更有生产力，享有更高的工资。</p>

<p>9.劳动力市场的歧视，发生在一个人找工作被拒绝或是比同样工作者薪资低的时候，理由是这个人的性别、种族、年龄、宗教或某些因素。</p>

<p>10.劳动力是一个市场，你的薪资及福利，是根据你的产出定出的价格。</p>

<p>11.折现值，它是把未来所要得到的款项，如果现在就回收，会值多少钱。</p>

<p>12.人一生累积财富的关键，在于复利的力量。</p>

<p>13.市场竞争的力量可以鼓励创新与提高效率，并惠及消费者。但是，在某些泾渭分明的情况下，当市场竞争无法良好运行时，政府可以扮演有用的角色，作为经济竞争的仲裁者。政府也是安全标准、财务报告正确性与信息揭露的合理仲裁者。当市场力量的结果似乎不受欢迎时，真正的挑战是发掘根本问题，并据此设计对策。判断该问题是有关垄断、卡特尔、限制性的商业成规、自然垄断、再也不需要管制的产业，还是需要某种服务的低收入民众。与其采取极端赞成或反对管制的封闭态度，更明智的做法应是见招拆招。</p>

<p>14.当某些人从公共物品中受益，却没有付出相对合理的成本时，经济学家把这个问题称作“搭便车”。缴税是用强迫的方式克服搭便车问题。</p>

<p>15.社会保障网不应是令人难以起身的吊床，而应能缓冲你掉落下来时的力道，并让你再弹上去。</p>

<p>16.政府在处理市场问题时可以扮演有用的角色，但它的行动也是不完美的，在某些情况下，甚至会造成自身更大或另外的问题。</p>

<p>17.思考经济政策时，你的挑战在于保持务实。要诚实面对市场发生的问题，答案要明确。对政府的作为要实事求是，坦然面对权衡取舍和风险。当你采取这种方法时——无论最后得出什么样的政策结论——你的思考方式就像经济学家了。</p>

<p>18.人均GDP较高的经济体，在很多方面都有较好的发展。</p>

<p>19.宏观经济政策的四个目标是：经济增长、充分就业、物价稳定和国际收支平衡。</p>

<p>20.GDP即国内生产总值，它是一个国家经济规模的衡量标准。GDP的定义是：一个经济体一年内所生产的最终商品和服务的总价值。GDP只包括成品，不包括投入制造这些商品的中间产品，例如投入制造汽车的钢材、投入制造椅子的木材等。</p>

<p>举例来说，GDP会反映你买的新车，但不会反映你卖给邻居的二手车；会反映你建造的新房子或装修旧房子的成本，但不会反映你买的旧房子。你买卖的公司股票也不会被计入GDP，因为它没有创造任何东西，只是交换，只有股票经纪人的手续费被当作服务器计入GDP。股市的大幅涨跌对GDP也完全没有直接影响。</p>

<p>21.长期来看，经济增长是唯一会影响生活水平的因素。</p>

<p>22.经济长期增长的根本原因是生产力的提升，也就是说，每一工时的产出增加，或是每位员工的产出增加。生产力增长的三大驱动力因素是：实物资本增加（即有更多的资本设备让员工使用）、更多的人力资本（员工有更多的经验或更好的教育）以及更好的技术（即更有效率的生产方式）。实际上，在市场经济的驱动下，这三个因素会一起运作。</p>

<p>23.如果你用类似方法分析低收入国家的经济增长原因，你会发现生产力的增长主要来自实物资本和人力资本的增加，较少来自新技术。</p>

<p>24.从个人角度来看，失业会伤害没工作的人。个人的损失不单是没有收入而已，远甚于此。失业会带来社会问题，从家庭的沉重压力到健康变差，甚至引起社会犯罪。从社会层面来看，失业会缩减国家经济规模。</p>

<p>25.贸易顺差与逆差，谈的是金钱的流向，以及向哪边的流动比较大。贸易顺差的真正意思是借钱给国外，且有对外投资的流出。</p>

<p>26.当政府的支出超过税收时，去哪里筹钱？答案是发行债券。</p>

<p>27.银行的放出的贷款资金，可能恰好接近法定准备金率的边缘。如果银行算错了，导致它不能满足法定准备金率的要求，那它就需要在很短的时间内（理论上是隔夜）借钱，来平衡放款和存款，以符合法定准备金率的要求。银行经常为此互相借钱，如果银行为此向中央银行借钱，所需支付的利率就是再贴现率。所以再贴现率是央行扩大或抑制放款的一种方式。</p>

<p>28.相似商品的跨国界贸易会给国内生产者带来更激烈的竞争，而竞争有助于低价和创新。</p>

<p>29.遭遇金融危机的郭嘉都有某些共同点：GDP会大幅萎缩。</p>

<p>30.凯恩斯法则（需求创造其自身的攻击）注重短期几年内的经济周期，撒伊定律（供给创造其自身的需求）倾向于更注重长期。</p>

<p>31.使社会的总需求增加或购买力提高的政策，称作扩张性或宽松的财政政策，包括减税与增加支出；反之则为收缩性或紧缩的财政政策，包括增税或减少支出。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《深入理解计算机系统》]]></title>
    <link href="http://kobe1941.github.io/blog/computer-system-deep.html"/>
    <updated>2019-12-27T22:34:42+08:00</updated>
    <id>http://kobe1941.github.io/blog/computer-system-deep</id>
    <content type="html"><![CDATA[<p>这本书应该是要配合实验才能理解的更加深刻。不过可惜只是过了一遍理论。。</p>

<p>第三章，第七章和第九章的内容比较有意思，相对来说对实际编程的帮助会更大一些，整体上本书可以当做参考书，有需要的时候来查一下还是很不错的。</p>

<p>ps：循环是用类似goto语句的原理（jump指令）实现的。</p>

<!--more-->

<h2 id="section">名词解释</h2>

<p>ALU：算数逻辑单元。</p>

<p>ISA：instruction Set Architecture 指令集体系结构或指令集架构</p>

<p>CISC：复杂指令集计算机</p>

<p>RISC：精简指令集计算机</p>

<p>PCI：Peripheral Component Interconnect 外围设备互联</p>

<p>USB：Universal Serial Bus 通用串行总线</p>

<p>NFS：Network File System 网络文件系统</p>

<p>LFU：Least Frequency Used 最不常使用</p>

<p>LRU：Least Recently Used 最近最少使用</p>

<p>ELF：Execute and Linkable Format 可执行可链接格式</p>

<p>ECF：ExceptionalControl Flow 异常控制流</p>

<p>HTTP：Hypertext Transfer Protocol  超文本传输协议</p>

<p>HTML：Hypertext Markup Language 超文本标记语言</p>

<p>MIMIE：Multipurpose Internet Mail Extension 多用途国际邮件扩充协议</p>

<p>URL：Universal Resource Locator  通用资源定位符</p>

<p>URI：Uniform Resource Identifier  统一资源标识符</p>

<h2 id="section-1">第一章  计算机系统漫游</h2>

<p>1.源程序实际上就是一个由值0和1组成的位（又称为比特）序列，8个位被组织成一组，称为字节。每个字节表示程序中的某些文本字符。</p>

<p>2.像hello.c这样只由ASCII字符构成的文件称为文本文件，所有其他文件都称为二进制文件。</p>

<p>3.系统所有的信息——包括磁盘文件、内存中的程序、内存中存放的用户数据以及网络上传送的数据，都是由一串比特表示的。区分不同数据对象的唯一方法是我们读到这些数据对象时的上下文。比如，在不同的上下文中，一个同样的字节序列可能表示一个整数、浮点数、字符串或者机器指令。</p>

<p>4.为了在系统上运行hello.c程序，每条c语句都必须被其他程序转化为一系列的低级机器语言指令。然后这些指令按照一种称为可执行目标程序的格式打好包，并以二进制磁盘文件的形式存放起来。目标程序也称为可执行目标文件。</p>

<p>5.在Unix系统上，从源文件到目标文件的转化是由编译器驱动程序完成的。</p>

<p>汇编器将hello.s翻译成机器语言指令。</p>

<p><img src="http://kobe1941.github.io/images/2019/12/1.jpg" alt="" /></p>

<p>6.贯穿整个系统的是一组电子管道，称作总线。通常总线被设计成传送定长的字节块，也就是字（word）。字中的字节数（即字长）是一个基本的系统参数，各个系统不尽相同。现在大多数机器字长要么是4个字节（32位），要么是8个字节（64位）。</p>

<p>7.控制器是IO设备本身或者系统的主印制电路板（主板）上的芯片组。而适配器则是一块主板插槽上的卡。它们的功能都是在IO总线和IO设备之间传递信息。</p>

<p>8.主存是一个临时存储设备，从逻辑上来说，存储器是一个线性的字节数组，每个字节都有其唯一的地址（数组索引）。</p>

<p>9.处理器CPU是解释（或执行）存储在主存中指令的引擎。处理器的核心是一个大小为一个字的存储设备（或寄存器），称为程序计数器（PC）。在任何时刻，PC都指向主存中的某条机器语言指令（即含有该条指令的地址）。</p>

<p>10.指令集架构描述的是每条机器代码指令的效果；而微体系结构描述的是处理器实际上是如何实现的。</p>

<p>11.利用DMA（直接存储器存取）技术，数据可以不通过处理器而直接从磁盘到达主存。</p>

<p>12.L1和L2高速缓存是用一种叫做静态随机访问存储器（SRAM）的硬件技术实现的。系统可以获得一个很大的存储器，同时访问速度也很快，原因是利用了高速缓存的局部性原理，即程序具有访问局部区域里的数据和代码的趋势。通过让高速缓存里存放可能经常访问的数据，大部分的内存操作都能在快速的高速缓存中完成。</p>

<p>13.我们可以把操作系统看成是应用程序和硬件之间插入的一层软件，所有应用程序对硬件的操作尝试都必须通过操作系统。</p>

<p>14.操作系统有两个基本功能：（1）防止硬件被失控的应用程序滥用；（2）向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。操作系统通过几个基本的抽象概念（进程、虚拟内存和文件）来实现这两个功能。</p>

<p>15.进程是操作系统对一个正在运行的程序的一种抽象。</p>

<p>16.无论是在单核还是在多核系统中，一个CPU看上去都像是在并发的执行多个进程，这是通过处理器在进程间切换来实现的。操作系统实现这种交错执行的机制称为上下文切换。</p>

<p>17.从一个 进程到另一个进程的转换是由操作系统内核管理的。内核是操作系统代码常驻内存的部分。内核不是一个独立的进程。相反，它是系统管理全部进程所用代码和数据结构的集合。</p>

<p>18.虚拟内存是一个抽象概念，它为每个进程提供了一个假象，即每个进程都在独占的使用主存。每个进程看到的内存都是一致的，称为虚拟地址空间。</p>

<p>在Linux中，地址空间最上面的区域是保留给操作系统中的代码和数据的（内核），这对所有进程来说都是一样。地址空间的地步区域存放用户进程定义的代码和数据。</p>

<p>大约在地址空间的中间部分是一块用来存放像C标准库和数学库这样的共享库的代码和数据的区域。</p>

<p>位于用户虚拟地址空间顶部的是用户栈。</p>

<p><img src="http://kobe1941.github.io/images/2019/12/2.jpg" alt="" /></p>

<p><img src="http://kobe1941.github.io/images/2019/12/3.jpg" alt="" /></p>

<p>19.虚拟内存的运作需要硬件和操作系统软件之间精密复杂的交互，包括对处理器生成的每个地址的硬件翻译。基本思想是把一个进程虚拟内存的内容存储在磁盘上，然后用主存作为磁盘的高速缓存。</p>

<p>20.文件就是字节序列，仅此而已。每个IO设备，包括键盘鼠标显示器甚至网络等等，都可以看成是文件。</p>

<p>21.数字计算机的整个历史中，有两个需求是驱动进步的持续动力：一个是我们想要计算机做的更多，另一个是我们想要计算机运行的更快。</p>

<p>22.并发是一个通用的概念，指一个同时具有多个活动的系统；并行指的是用并发来使一个系统运行得更快。</p>

<p>23.多核处理器是将多个CPU集成到一个集成电路芯片上。</p>

<p>24.超线程，有时称为同时多线程，是一项允许一个CPU执行多个控制流的技术。它涉及CPU某些硬件有多个备份，比如程序计数器和寄存器文件，而其他的硬件部分只有一份。Intel Core i7 处理器可以让每个核执行两个线程，所以一个4核的系统实际上可以并行的执行8个线程。</p>

<p>25.在较低的抽象层次上，现代处理器可以同时执行多条指令的属性称为指令级并行。</p>

<p>26.在流水线（pipelining）中，将执行一条指令所需要的活动划分为不同的步骤，将处理器的硬件组织成一系列的阶段，每个阶段执行一个步骤。这些阶段可以并行的操作，用来处理不同指令的不同部分。如果处理器可以达到比一个周期一条指令更快的执行速率，就称之为超标量处理器。</p>

<p>27.在最低层次上，许多现代处理器拥有特殊的硬件，允许一条指令产生多个可以并行执行的操作，这种方式称为单指令、多数据，即SIMD并行。</p>

<p>28.在处理器里，指令集架构提供了对实际处理器硬件的抽象。</p>

<p>29.三个抽象：文件是对IO设备的抽象，虚拟内存是对程序存储的抽象，而进程是对一个正在运行的程序的抽象。</p>

<p>30.虚拟机，它提供对整个计算机的抽象，包括操作系统，处理器和程序。</p>

<h3 id="section-2">第一部分   程序结构和执行</h3>

<h2 id="section-3">第二章 信息的表示和处理</h2>

<p>1.无符号（unsigned）编码基于传统的二进制表示法，表示大于或等于0的数字。补码编码是表示有符号整数的最常见的方式。浮点数编码是表示实数的科学计数法的以2为基数的版本。</p>

<p>2.大多数计算机使用8位的块，或者字节，作为最小的可寻址的内存单位，而不是访问内存中单独的位。机器级程序将内存视为一个非常大的字节数组，称为虚拟内存。内存中的每个字节都由一个唯一的数字来标识，称为它的地址，所有可能的地址的集合就称为虚拟地址空间。</p>

<p>3.我们将程序称为“32位程序”或“64位程序”时，区别在于该程序是如何编译的，而不是其运行的机器类型。</p>

<p>4.在几乎所有的机器上，多字节对象都被存储为连续的字节徐磊，对象的地址为所使用字节中最小的地址。</p>

<p>5.反汇编器（disassembler）是一种确定可执行程序文件所表示的指令序列的工具。</p>

<p>6.表达式sizeof（T）返回存储一个类型为T的对象所需要的字节数。</p>

<p>7.有一个相应的右移运算 x»k，逻辑右移在左端补k个0，算术右移是在左端补k个最高有效位的值。实际上，几乎所有的编译器/机器组合都对有符号数使用算术右移，而对于无符号数，右移必须是逻辑的。</p>

<p>8.C和C++都支持有符号（默认）和无符号数。Java只支持有符号数。</p>

<p>9.C语言标准并没有要求要用补码形式来表示有符号整数，但是几乎所有的机器都是这么做的。</p>

<p>10.当执行一个运算时，如果它的一个运算数是有符号的而另一个是无符号的，那么C语言会隐式的将有符号参数强制类型转换为无符号数，并假设这两个数都是非负的。</p>

<p>11.有符号数到无符号数的隐式转换，会导致错误或者漏洞的方式，避免这类错误的一种方法就是绝不使用无符号数。</p>

<p>12.由于整数乘法比移位和加法的代价要大得多，许多C语言编译器试图以移位、加法和减法的组合来消除很多整数乘以常数的情况。</p>

<h2 id="section-4">第三章 程序的机器级表示</h2>

<p>1.GCC C语言编译器以汇编代码的形式产生输出，汇编代码是机器代码的文本表示，给出程序中的每一条指令。然后GCC 调用汇编器和链接器，根据汇编代码生成可执行的机器代码。</p>

<p>2.使用现代的优化编译器，最大的优点是，用高级语言编写的程序可以在很多不同的机器上编译和执行，而汇编代码则是与特定机器密切相关的。</p>

<p>3.优化编译器能够重新排列执行顺序，消除不必要的计算，用快速操作替换慢速操作，甚至将递归计算变换成迭代计算。</p>

<p>4.大多数ISA，包括x86-64，将程序的行为描述成好像每条指令都是按顺序执行的，一条指令结束后，下一条再开始。处理器的硬件远比描述的精细复杂，它们并发的执行许多指令，但是可以采取措施保证整体行为与ISA指定的顺序执行的行为完全一致。</p>

<p>5.程序计数器PC给出将要执行的下一条指令在内存中的地址。</p>

<p>6.x86-64的虚拟地址是由64位的字来表示的。在目前的实现中，这些地址的高16位必须设置为0，所以一个地址实际上能够指定的是2^48或256TB范围内的一个字节。操作系统负责管理虚拟地址空间，将虚拟地址翻译成实际处理器内存中的物理地址。</p>

<p>7.机器执行的程序只是一个字节序列，它是对一系列指令的编码。机器对产生这些指令的源代码几乎一无所知。</p>

<p>8.反汇编器（disassembler）只是基于机器代码文件中的字节序列来确定汇编代码。它不需要访问该程序的源代码或汇编代码。</p>

<p>9.16个寄存器如下图，最特别的是栈指针%rsp，用来指明运行时栈的结束位置。</p>

<p>ps：函数的返回值也是存在寄存器里，函数传参一般也用寄存器，不够时才会用栈。</p>

<p><img src="http://kobe1941.github.io/images/2019/12/4.jpg" alt="" /></p>

<p>10.栈可以实现为一个数组，总是从数组的一端插入和删除元素。这一端被称为栈顶。——也可以实现为链表</p>

<p>11.因为栈和程序代码以及其他形式的程序数据都是放在同一内存中，所以程序可以用标准的内存寻址方法访问栈内的任意位置。</p>

<p>12.处理器通过使用流水线pipelining来获得高性能。</p>

<p>13.汇编中没有循环的指令存在，可以用条件测试和跳转组合起来实现循环的效果。——也就是类似goto或jump指令</p>

<p>14.使用跳转表是一种非常有效的实现多重分支的方法。在我们的例子中，程序可以只是用一次跳转表引用就分支到5个不同的位置。甚至当switch语句有上百种情况的时候，也可以只用一次跳转表访问去处理。</p>

<p>15.C语言过程调用机制的一个关键特性（大多数其他语言也是如此）在于使用了栈数据结构提供的后进先出的内存管理原则。</p>

<p>16.<strong>x86-64的栈向低地址方向增长，而栈指针%rsp指向栈顶元素。当x86-64过程需要的存储空间超出寄存器能够存放的大小时，就会在栈上分配空间。这个部分称为过程的栈帧（stack frame）。大多数过程的栈帧都是定长的，在过程的开始就分配好了。但是有些过程需要变长的栈帧。</strong></p>

<p>17.<strong>将控制从函数P转移到函数Q只需要简单的把程序计数器PC设置为Q的代码的起始位置。不过稍后从Q返回的时候，处理器必须记录好它需要继续P的执行的代码的位置。在x86-64机器中，这个信息是用指令call Q 调用过程Q来记录的。call Q指令会把地址A压入栈中，并将PC设置为Q的起始地址。压入的地址A被称为返回地址，是紧跟在call 指令后面的那条指令的地址。对应的指令ret 会从栈中弹出地址A，并把PC设置为A。——对比下上面函数返回值，函数的返回地址和返回值是不同的</strong></p>

<p>18.x86-64中，可以通过寄存器最多传递6个整形（即整数和指针）参数。如果一个函数有大于6个整形参数，超出6个的部分就要通过栈来传递。有n个整形参数，且n&gt;6，那么就把参数1-6复制到对应的寄存器，把参数7-n 放到栈上，而参数7就位于栈顶。</p>

<p><img src="http://kobe1941.github.io/images/2019/12/5.jpg" alt="" /></p>

<p>19.作为过程调用的一部分，返回地址被压入栈中。</p>

<p>20.运行时栈提供了一种简单的、在需要时分配、函数完成时释放局部存储的机制。</p>

<p>21.寄存器组是唯一被所有过程共享的资源。虽然在给定时刻只有一个过程是活动的，我们仍然必须确保当一个过程（调用者）调用另一个过程（被调用者）时，被调用者不会覆盖调用者稍后会使用的寄存器值。</p>

<p>根据惯例，寄存器%rbx、%rbp和%r12-%r15被划分为被调用者保存寄存器。当过程P调用过程Q时，Q必须保存这些寄存器的值不变，保证它们的值在Q返回到P时与Q被调用时是一样的。</p>

<p>所有其他的寄存器，除了栈指针%rsp，都分类为调用者保存寄存器：过程P在某个此类寄存器中有局部数据，然后调用过程Q。因为Q可以随意修改这个寄存器，所以在调用之前首先保存好这个数据是P（调用者）的责任。</p>

<p>22.二维数组在内存中按照“行优先”的顺序排列，意味着第0行的所有元素，可以写作A[0]。A[5][3]则可以被看成一个5行3列的二维数组。</p>

<p><img src="http://kobe1941.github.io/images/2019/12/6.jpg" alt="" /></p>

<p>23.ISO C99引入了一种功能，允许数组的维度是表达式，在数组被分配的时候才计算出来。</p>

<p>24.C语言提供了两种将不同类型的对象组合到一起创建数据类型的机制：结构，用关键字struct来声明，将多个对象集合到一个单位中；联合，用关键字union来声明，允许用几种不同的类型来引用一个对象。</p>

<p>25.类似于数组的实现，结构的所有组成部分都存在在内存中一段连续的区域内，而指向结构的指针就是结构第一个字节的地址。编译器维护关于每个结构类型的信息，指示每个字段的字节偏移。它以这些偏移作为内存引用指令中的位移，从而产生对结构元素的引用。</p>

<p>26.一种情况是，我们事先知道对一个数据结构中的两个不同字段的使用是互斥的，那么将这两个字段声明为联合的一部分，而不是结构的一部分，就会减少分配空间的总量。</p>

<p>27.许多计算机系统对基本数据类型的合法地址做了一些限制，要求某种类型对象的地址必须是某个值K（通常是2、4或8）的倍数。无论数据是否对齐，x86-64硬件都能正确工作。不过Intel还是建议要对齐数据以提高内存系统的性能。对齐原则是任何K字节的基本对象的地址必须是K的倍数。</p>

<p>28.如果数据没有对齐，某些型号的Intel或AMD处理器对于有些实现多媒体操作的SSE指令，就无法正确执行。任何试图以不满足对齐要求的地址来访问内存都会导致异常，默认的行为是程序终止。</p>

<p>因此，任何针对x86-64处理器的编译器和运行时系统都必须保证分配用来保存可能会被SSE寄存器读或写的数据结构的内存，都必须满足16字节对齐。</p>

<p>29.函数指针的值是该函数机器代码表示中第一条指令的地址。</p>

<p>30.如果存储的返回地址的值被破坏了，那么ret指令会导致程序跳转到一个完全意想不到的位置。</p>

<p>31.缓冲区溢出的一个更加致命的使用就是让程序执行它本来不愿意执行的函数。</p>

<p>32.栈随机化的思想使得栈的位置在程序每次运行时都有变化。</p>

<p>在Linux系统中，栈随机化已经变成了标准行为，它是ASLR（地址空间布局随机化）技术中的一种。采用ASLR，每次运行时程序的不同部分，包括程序代码、库代码、栈、全局变量和堆数据，都会被加载到内存的不同区域。</p>

<p>ASLR技术能够增加成功攻击一个系统的难度，但是也不能提供完全的安全保障。</p>

<p>33.随机化，栈保护和限制哪部分内存可以存储可执行代码，是用于最小化程序缓冲区溢出攻击漏洞三种最常见的机制。</p>

<p>34.为了管理变长栈帧，x86-64代码使用寄存器%bp作为帧指针。</p>

<p>35.JOT即时编译，动态的将字节代码序列翻译成机器指令。当代码要执行多次时，这种方法执行起来更快。</p>

<h2 id="section-5">第四章  处理器体系结构</h2>

<p>1.与同一时刻只执行一条指令相比，通过同时处理多条指令的不同部分，处理器可以获得更高的性能。</p>

<p>2.寄存器%rsp被入栈、出栈、调用和返回指令作为栈指针。程序计数器PC存放当前正在执行指令的地址。</p>

<p>3.内存从概念上来说就是一个很大的字节数组，保存着程序和数据。</p>

<p>4.call 指令将返回地址入栈，然后跳到目的地址。ret 指令从这样的调用中返回。nop 指令只是简单的经过各个阶段，除了要将PC加1，不进行任何处理。halt 指令使得处理器状态被设置成HLT，导致处理器停止运行。</p>

<p>5.流水线化的一个重要特性就是提高了系统的吞吐量，也就是单位时间内服务的顾客综述，不过它也会轻微的增加延迟。</p>

<p>6.猜测分支方向并根据猜测开始取指的技术称为分支预测。</p>

<p>分支预测错误会极大的降低程序的性能，因此这就促使我们在可能的时候，要使用条件数据传送而不是条件控制转移。</p>

<p>7.我们的指令集体系结构包括三种不同的内部产生的异常：（1）halt指令；（2）有非法指令和功能码组合的指令；（3）取指或数据读写试图访问一个非法地址。</p>

<h2 id="section-6">第五章  优化程序性能</h2>

<p>1.编写高效程序需要做到以下几点：①我们必须选择一组适当的算法和数据结构。②我们必须编写出编译器能够有效优化以转换成高效可执行代码的源代码。③针对处理运算量特别大的计算，将一个任务分成多个部分，这些部分可以在多核和多处理器的某种组合上并行的计算。</p>

<p>C语言的有些特性，例如执行指针运算和强制类型转换的能力，使得编译器很难对它进行优化。</p>

<p>即使是要利用并行性，每个并行的线程都以最高性能执行也是非常重要的。</p>

<p>2.程序优化的第一步就是消除不必要的工作，这包括不必要的函数调用，条件测试和内存引用。（消除循环的低效率，减少过程调用）</p>

<p>程序优化的第二步，利用处理器提供的指令级并行能力，同时执行多条指令。</p>

<p>3.用内联函数替换优化函数调用。</p>

<p>4.实际的处理器中，是同时对多条指令求值的，这个现象称为指令级并行。在某些设计中，可以有100或更多条指令在处理中。</p>

<h2 id="section-7">第六章   存储器层次结构</h2>

<p>1.具有良好局部性的程序倾向于一次又一次的访问相同的数据项集合，或是倾向于访问邻近的数据项集合。</p>

<p>2.基本的存储技术：SRAM存储器，DRAM存储器，ROM存储器以及旋转的和固态的硬盘。</p>

<p>3.随机访问存储器RAM分为两类：静态的和动态的。静态RAM（SRAM）比动态RAM（DRAM）更快，但也贵的多。SRAM用来作为高速缓存存储器，既可以在CPU芯片上，也可以在片下。DRAM用来作为主存以及图形系统的帧缓冲区。</p>

<p>4.SRAM将每个位存储在一个双稳态的存储器单元里。每个单元是用一个六晶体管电路来实现的。——从不稳定状态开始，电路会迅速的转移到两个稳定状态中的一个。</p>

<p>由于SRAM存储器单元的双稳态特性，只要有电，它就会永远的保持它的值。即使有干扰来扰乱电压，当干扰消除时，电路就会恢复到稳定值。</p>

<p>5.DRAM将每个位存储为对一个电容的充电。这个电容非常小。DRAM存储器可以制造得非常密集——每个单元由一个电容和一个访问晶体管组成。但与SRAM不同，DRAM存储器单元对干扰非常敏感。当电容的电压被扰乱之后，它就永远不会恢复了。暴露在光线下会导致电容电压改变。实际上，数码照相机和摄像机中的传感器本质上就是DRAM单元的阵列。</p>

<p>很多原因会导致漏电，使得DRAM单元在10-100ms的时间内失去电荷。内存系统必须周期性的通过读出，然后重写来刷新内存每一位。</p>

<p><img src="http://kobe1941.github.io/images/2019/12/7.jpg" alt="" /></p>

<p>6.DRAM芯片封装在内存模块中，它插到主板的扩展槽上。</p>

<p>7.SDRAM 称为同步DRAM。双倍数据速率同步DRAM称为DDR SDRAM，它是SDRAM的一种增强，它通过使用两个时钟沿作为控制信号，从而使DRAM的速度翻倍。不同类型的DDR SDRAM是用提高有效带宽的很小的预取缓冲区的大小来划分的：DDR（2位）、DDR2（4位）、DDR3（8位）。</p>

<p>8.如果断电，DRAM和SRAM会丢失它们的信息。</p>

<p>PROM可编程ROM只能被编程一次。</p>

<p>EPROM可擦写可编程ROM能够被擦除和重编程的次数的数量级可以达到1000次。EEPROM电子可擦除PROM类似于EPROM，能够被编程的次数的数量级可以达到10^5次。</p>

<p>闪存是一类非易失性存储器，基于EEPROM。基于闪存的磁盘驱动器，称为固态硬盘SSD。</p>

<p>存储在ROM设备中的驱动程序通常称为固件firmware。</p>

<p>9.数据流通过称为总线的共享电子电路在处理器和DRAM主存之间来来回回。</p>

<p>10.磁盘是由一个或多个叠放在一起的盘片组成的。每个盘片有两面或者称为表面，每个表面是由一组称为磁道的同心圆组成，每个磁道被划分为一组扇区。</p>

<p>11.磁盘控制器必须对磁盘进行格式化，然后才能在该磁盘上存储数据。格式化包括用标识扇区的信息填写扇区之间的间隙，标识出表面有故障的柱面并且不使用它们，以及在每个区中预留出一组柱面作为备用。如果区中一个或多个柱面在磁盘使用过程中坏掉了，就可以使用这些备用的柱面。因为存在着这些备用的柱面，所以磁盘制造商所说的格式化容量比最大容量要小。</p>

<p>12.CPU使用一种称为内存映射 I/O 的技术来向 I/O 设备发射命令。在使用内存映射 I/O 的系统中，地址空间中有一块地址是为与I/O设备通信保留的。每个这样的地址称为一个 I/O 端口。</p>

<p>13.在磁盘控制器收到来自CPU的读命令后，它将逻辑块号翻译成一个扇区地址，读该扇区的内容，然后将这些内容直接传送到主存，不需要CPU的干涉。设备可以自己执行读或者写总线事务而不需要CPU干涉的过程，称为直接内存访问DMA（Direct Memory Access）。</p>

<p>在DMA传送完成，磁盘扇区的内容被安全的存储在主存中以后，磁盘控制器通过给CPU发送一个中断信号来通知CPU。基本思想是中断会发信号到CPU芯片的一个外部引脚上。这会导致CPU暂停它当前正在做的工作，跳转到一个操作系统例程，这个程序会记录下I/O已经完成，然后将控制返回到CPU被中断的地方。</p>

<p>14.固态硬盘是一种基于闪存的存储技术。一个SSD封装由一个或多个闪存芯片和闪存翻译层组成。</p>

<p>15.随机写很慢，有两个原因。首先，擦除块需要相对较长的时间，1ms级的，比访问页所需时间要高一个数量级。其次，如果写操作试图修改一个包含已经有数据的页p，那么这个块中所有带有用数据的页都必须被复制到一个新（擦除过的）块，然后才能进行对页p的写。</p>

<p>16.不同的存储技术有不同的价格和性能折中。快速存储总是比慢速存储要贵的。SRAM比DRAM贵，DRAM又比磁盘贵的多，SSD位于DRAM和旋转磁盘之间。</p>

<p>DRAM和磁盘的性能滞后于CPU的性能。而且差距实际上是在加大的。</p>

<p>17.多核处理器：无法再像以前一样迅速的增加CPU的时钟频率了，因为如果那样芯片的功耗会太大。解决方法是用多个小处理器核取代单个大核处理器，从而提高性能，每个完整的处理器能够独立的，与其他核并行的执行程序。</p>

<p>18.局部性原理：它们倾向于引用邻近与其他最近引用过的数据项的数据项，或者最近引用过的数据项本身。</p>

<p>局部性通常有两种不同的形式：时间局部性和空间局部性。在一个具有良好时间局部性的程序中，被引用过一次的内存位置很可能在不远的将来再被多次引用。在一个具有良好空间局部性的程序中，如果一个内存位置被引用了一次，那么程序很可能在不远的将来引用附近的一个内存位置。</p>

<p>有良好局部性的程序比局部性差的程序运行的更快。</p>

<p>19.重复引用相同变量的程序有良好的时间局部性。对于具有步长为k的引用模式的程序，步长越小，空间局部性越好。对于取指令来说，循环有好的时间和空间局部性。循环体越小，循环迭代次数越多，局部性越好。</p>

<p>20.固态硬盘在存储器层级结构中扮演着越来越重要的角色，连接起DRAM和旋转磁盘之间的鸿沟。</p>

<p><img src="http://kobe1941.github.io/images/2019/12/8.jpg" alt="" /></p>

<p>21.直写，就是立即将w的高速缓存块写回到紧接着的低一层中。虽然简单，但是直写的缺点是每次都会引起总线的流量。</p>

<p>写回，尽可能的推迟更新，只有当替换算法要驱逐这个更新过的块时，才把它写到紧接着的低一层中。由于局部性，写回能显著的减少总线流量，但是它的缺点是增加了复杂性。</p>

<p>虚拟内存系统（用主存作为存储在磁盘上的块的缓存）只使用写回。我们在现代系统的所有层次上都能看到写回缓存，其与处理读的方式相对称。</p>

<p>一般而言，高速缓存越往下层，越可能用写回而不是直写。</p>

<p>22.存储器系统的性能不是一个数字就能描述的，相反，它是一座时间和空间局部性的山。</p>

<h4 id="section-8">第二部分  在系统上运行程序</h4>

<h2 id="section-9">第七章 链接</h2>

<p>1.链接器把程序的各个部分联合成一个文件，处理器可以将这个文件加载到内存，并且执行它。</p>

<p>链接是将各种代码合数据片段收集并组合成为一个单一文件的过程。</p>

<p>链接可以执行于编译时，也就是在源代码被翻译成机器代码时；也可以执行于加载时，也就是在程序被加载器加载到内存并执行时；甚至执行于运行时，也就是由应用程序来执行。现代系统中，链接是由叫做链接器的程序自动执行的。</p>

<p>2.链接器在软件开发中扮演着一个关键的角色，因为它们使得分离编译成为可能。我们不用将一个大型的应用程序组织为一个巨大的源文件，而是可以把它分解为更小、更好管理的模块，可以独立的修改和编译这些模块。</p>

<p>3.许多软件产品在运行时使用共享库来升级压缩包装的二进制程序。大多数web服务器都依赖于共享库的动态链接来提供动态内容。</p>

<p>4.无论是什么样的操作系统，ISA或者目标文件格式，基本的链接概念是通用的。</p>

<p>5.大多数编译系统提供编译器驱动程序，它代表用户在需要时调用语言预处理器、编译器、汇编器和链接器。</p>

<p>6.静态链接：像Linux LD 程序这样的静态链接器以一组可重定位目标文件和命令行参数作为输入，生成一个完全</p>

<p>链接的、可以加载和运行的可执行目标文件作为输出。输入的可重定位目标文件由各种不同的代码合数据节组成，每一节都是一个连续的字节序列。指令在一节中，初始化了的全局变量在另一节中，而未初始化的变量又在另外一节中。</p>

<p>为了构造可执行文件，链接器必须完成两个主要任务：</p>

<p>①符号解析。目标文件定义和引用符号，每个符号对应于一个函数、一个全局变量或一个静态变量（即C语言中任何以static属性声明的变量）。符号解析的目的是将每个符号引用正好和一个符号定义关联起来。</p>

<p>②重定位。编译器和汇编器生成从地址0开始的代码和数据节。链接器通过把每个符号定义与一个内存位置关联起来，从而重定位这些节，然后修改所有对这些符号的引用，使得它们指向这个内存位置。</p>

<p>7.关于链接器的一些基本事实：目标文件纯粹是字节块的集合。这些块中，有些包含程序代码，有些包含程序数据，而其他的则包含引导链接器和加载器的数据结构。</p>

<p>8.目标文件由三种形式：</p>

<p>①可重定位目标文件，包含二进制代码和数据，其形式可以在编译时与其他可重定位目标文件合并起来，创建一个可执行目标文件。</p>

<p>②可执行目标文件，包含二进制代码和数据，其形式可以被直接复制到内存并执行。</p>

<p>③共享目标文件，一种特殊类型的可重定位目标文件，可以在加载或者运行时被动态的加载进内存并链接。</p>

<p>9.编译器和汇编器生成可重定位目标文件（包括共享目标文件）。链接器生成可执行目标文件。从技术上来说，一个目标模块就是一个字节序列，而一个目标文件就是一个以文件形式存放在磁盘中的目标模块。</p>

<p>10.一个典型的ELF可重定位目标文件包含下面几个节：</p>

<p>.text：已编译程序的机器代码。</p>

<p>.rodate：只读数据，比如printf语句中的格式串和开关语句的跳转表。</p>

<p>.data：已初始化的全局和静态C变量。局部C变量在运行时被保存在栈中，既不出现在.data节中，也不出现在.bss节中。</p>

<p>.bss：未初始化的全局和静态C变量，以及所有被初始化为0的全局或静态变量。在目标文件中这个节不占据实际的空间，它仅仅是一个占位符。在目标文件中，未初始化的变量不需要占据任何实际的磁盘空间。运行时，在内存中分配这些变量，初始值为0。</p>

<p>.symtab：一个符号变，它存放在程序中定义和引用的函数和全局变量的信息。实际上，每个可重定位目标文件在.symtab中都有一张符号表（除非程序员特意用STRIP 命令去掉它）。然而，和编译器中的符号表不同，.symtab符号表不包含局部变量的条目。</p>

<p>11.每个可重定位目标模块m都有一个符号表，它包含m定义和引用的符号的信息。在链接器的上下文中，有三种不同的符号：</p>

<p>①由模块m定义并能被其他模块引用的全局符号。</p>

<p>②由其他模块定义并被模块m引用的全局符号。</p>

<p>③只被模块m定义和引用的局部符号。</p>

<p>有趣的是，定义为带有C static属性的本地过程变量是不在栈中管理的。相反，编译器在.data或.bss中为每个定义分配空间，并在符号表忠创建一个有唯一名字的本地链接器符号。</p>

<p>在C中，源文件扮演模块的角色。任何带有static属性声明的全局变量或者函数都是模块私有的。类似的，任何不带static属性声明的全局变量和函数都是公共的，可以被其他模块访问。</p>

<p>12.符号表是由汇编器构造的，使用编译器输出到汇编语言.s文件中的符号。</p>

<p>13.链接器解析符号引用的方法是将每个引用与它输入的可重定位目标文件的符号表忠的一个确定的符号定义关联起来。静态局部变量也会有本地链接器符号，编译器还要确保它们拥有唯一的名字。</p>

<p>14.对全局符号的符号解析很棘手，还因为多个目标文件可能会定义相同名字的全局符号。在这种情况下，链接器必须要么标志一个错误，要么以某种方法选出一个定义并抛弃其他定义。</p>

<p>15.C++和Java中能使用重载函数，是因为编译器将每个唯一的方法和参数列表组合编码成一个对链接器来说唯一的名字。这种编码过程叫做重整，而相反的过程叫做恢复。</p>

<p>16.在编译时，编译器向汇编器输出每个全局符号，或者是强strong或者是弱weak。函数和已初始化的全局变量是强符号，未初始化的全局变量是弱符号。</p>

<p>根据强弱符号的定义，Linux链接器使用下面的规则来处理多重定义的符号名：</p>

<p>①不允许有多个同名的强符号；</p>

<p>②如果有一个强符号和多个弱符号同名，那么选择强符号；</p>

<p>③如果有多个弱符号同名，那么从这些弱符号中任意选择一个。</p>

<p>17.所有的编译系统都提供一种机制，将所有相关的目标模块打包称为一个单独的文件，称为静态库。它可以用作链接器的输入。当链接器构造一个输出的可执行文件时，它只复制静态库里被应用程序引用的目标模块。</p>

<p>静态库概念被提出来，以解决这些不同方法的缺点。相关的函数可以被编译为独立的目标模块，然后封装成一个单独的静态库文件。在链接时，链接器将只复制被程序引用的目标模块，这就减少了可执行文件在磁盘和内存中的大小。</p>

<p>18.在Linux系统中，静态库以一种称为存档archive的特殊文件格式存放在 磁盘中。存档文件是一组连接起来的可重定位目标 文件的集合，有一个头部用来描述每个成员目标文件的大小和位置。存档文件名由后缀.a标识。</p>

<p>19.任何Linux程序都可以通过调用execve函数来调用加载器，加载器将可执行目标文件中的代码合数据从磁盘复制到内存中，然后通过跳转到程序的第一条指令或入口点来运行该程序。这个将程序复制到内存并运行的过程叫做加载。</p>

<p>20.所谓内核就是操作系统驻留在内存的部分。</p>

<p>21.加载器的工作流程：</p>

<p><strong>当shell运行一个程序时，父shell进程生成一个子进程，它是父进程的一个复制。子进程通过execve系统调用启动加载器。加载器删除子进程现有的虚拟内存段，并创建一组新的代码、数据、堆和栈段。新的栈和堆段被初始化为零。通过将虚拟地址空间中的页映射到 可执行文件的页大小的片chunk，新的代码和数据段被初始化为可执行文件的内容。最后，加载器跳转到_start地址，它最终会调用应用程序的main函数。除了一些头部信息，在加载过程中没有任何从磁盘到内存的数据复制。直到CPU引用一个被映射的虚拟页时才会进行复制，此时，操作系统利用它的页面调度机制自动将页面从磁盘传送到内存。</strong></p>

<p>22.共享库是致力于解决静态库缺陷的一个现代创新产物。共享库是一个目标模块，在运行或加载时，可以加载到任意的内存地址，并和一个在内存中的程序链接起来。这个过程称为动态链接，是由一个叫做动态链接器的程序来执行的。共享库也称为共享目标，在Linux系统中通常用.so后缀来表示。微软的操作系统大量的使用了共享库，它们称为DLL动态链接库。</p>

<p>23.动态链接器本身就是一个共享目标。加载器不会像它通常所做的那样将控制传递给应用，而是加载和运行这个动态链接器。最后动态链接器将控制传递给应用程序。</p>

<p>24.应用程序还可能在它运行时要求动态链接器加载和链接某个共享库，而无需在编译时将那些库链接到应用中。</p>

<p>25.现代高性能的Web服务器可以使用基于动态链接的更有效和完善的方法来生成动态内容。其思路是将每个生成动态内容的函数打包在共享库中。当一个来自Web浏览器的请求到达时，服务器动态的加载和链接适当的函数，然后直接调用它，而不是使用fork额execve在子进程的上下文中运行函数。函数会一直缓存在服务器的地址空间中，所以只要一个简单的函数调用的开销就可以处理随后的请求了。在运行时无需停止服务器，就可以更新已存在的函数，以及添加新的函数。</p>

<p>26.Linux系统为动态链接器提供了一个简单的接口，允许应用程序在运行时加载和链接共享库：dlopen()。</p>

<p>dlsym()函数的输入是一个指向前面已经打开了的共享库的句柄和一个symbol名字，如果该符号存在，就返回符号的地址，否则返回NULL。</p>

<p>如果没有其他共享库还在使用这个共享库，dlclose()函数就卸载该共享库。</p>

<p>27.JNI Java本地接口，它允许Java程序调用本地的C和C++函数。JNI的基本思想是将本地C函数（如foo）编译到一个共享库中（如foo.so）。当一个正在运行的Java程序试图调用函数foo时，Java解释器利用dlopen接口动态链接和加载foo.so，然后再调用foo。</p>

<p>28.现代系统以这样一种方式编译共享模块的代码段，使得可以把它们加载到内存的任何位置而无需链接器修改。这样子，无限多个进程可以共享一个共享模块的代码段的单一副本。（当然，每个进程仍然会有它自己的读/写数据库）。</p>

<p>可以加载而无需重定位的代码称为位置无关代码（PIC）。用户对GCC使用-fpic选项指示GNU编译系统生成PIC代码。共享库的编译必须总是使用该选项。</p>

<p>在一个x86-64系统中，对同一个目标模块中符号的引用是不需要特殊处理使之成为PIC。可以用PC相对寻址来编译这些引用，构造目标文件时由静态链接器重定位。</p>

<p>29.无论我们在内存中的何处加载一个目标模块（包括共享目标模块），数据段与代码段的距离总是保持不变。因此，代码段中任何指令和数据段中任何变量之间的距离都是一个运行时常量，与代码段和数据段的绝对内存位置是无关的。</p>

<p>30.延迟绑定：将过程地址的绑定推迟到第一次调用该过程时。</p>

<p>把函数地址的解析推迟到它实际被调用的地方，能避免动态链接器在加载时进行成百上千个其实并不需要的重定位。</p>

<p>延迟绑定是通过两个数据结构之间简洁但又有些复杂的交互来实现的，这两个数据结构是：GOT全局偏移量表和过程连接表PLT。</p>

<p>31.Linux链接器支持一个很强大的技术，称为库打桩，它允许你截获对共享库函数的调用，取而代之执行自己的代码。</p>

<p>其基本思想：给定一个需要打桩的目标函数，创建一个包函数，它的原型与目标函数完全一样。使用某种特殊的打桩机制，你就可以欺骗系统调用包装函数而不是目标函数了。包装函数通常会执行它自己的逻辑，然后调用目标函数，再将目标函数的返回值传递给调用者。</p>

<p>打桩可以发生在编译时、链接时或当程序被加载和执行的运行时。</p>

<p>32.可以使用C预处理器在编译时打桩。Linux静态链接器支持用—wrap f标志进行链接时打桩。</p>

<p>编译时打桩需要能够访问程序的源代码，链接时打桩需要能够访问程序的可重定位对象文件。基于动态链接器的LD_PRELOAD环境变量可以实现运行时打桩。</p>

<p>如果LD_PRELOAD环境变量被设置为一个共享库路径名的列表，那么当你加载和执行一个程序，需要解析未定义的引用时，动态链接器会先搜索LO_PRELOAD库，然后才搜索任何其他的库。</p>

<p>你可以用LD_PRELOAD对任何可执行程序的库函数调用打桩。</p>

<p><img src="http://kobe1941.github.io/images/2019/12/9.jpg" alt="" /></p>

<h2 id="section-10">第八章 异常控制流</h2>

<p>1.ECF异常控制流是操作系统用来实现I/O、进程和虚拟内存的基本机制。</p>

<p>应用程序通过使用一个叫做陷阱（trap）或者系统调用（system call）的ECF形式，向操作系统请求服务。比如，向磁盘写数据、从网络读取数据、创建一个新进程，以及终止当前进程，都是通过应用程序调用系统调用来实现的。</p>

<p>操作系统为应用程序提供了强大的ECF机制，用来创建新进程、等待进程终止、通知其他进程系统中的异常事件，以及检测和响应这些事件。</p>

<p>ECF是计算机系统中实现并发的基本机制。</p>

<p>像C++和Java这样的语言通过try、catch以及throw语句来提供软件异常机制。软件异常允许程序进行非本地跳转（即违反通常的调用/返回栈规则的跳转）来响应错误情况。非本地跳转是一种应用层ECF。</p>

<p>2.异常是异常控制流的一种形式，它一部分由硬件实现，一部分由操作系统实现。异常就是控制流中的突变，用来响应处理器状态中的某些变化。</p>

<p>在处理器中，状态被编码为不同的位和信号。状态变化称为事件。</p>

<p>3.在任何情况下，当处理器检测到有事件发生时，它就会通过一张叫做异常表的跳转表，进行一个间接过程调用（异常），到一个专门设计用来处理这类事件的操作系统子程序（异常处理程序exception handler）。</p>

<p>4.系统中可能的每种类型的异常都分配了一个唯一的非负整数的异常号。其中一些号码是由处理器的设计者分配的，其他号码是由操作系统内核的设计者分配的。</p>

<p>5.异常表的起始地址放在一个叫做异常表基址寄存器的特殊CPU寄存器里。</p>

<p>6.异常调用类似于过程调用，也有一些不同之处：</p>

<p>过程调用时，在跳转到处理程序之前，处理器将返回地址压入栈中。然而根据异常的类型，返回地址要么是当前指令（当事件发生时正在执行的指令），要么是下一条指令（如果事件不发生，将会在当前指令后执行的指令）。</p>

<p>处理器也把一些额外的处理器状态压到栈里，在处理程序返回时，重新开始执行被中断的程序会需要这些状态。</p>

<p>如果控制从用户程序转移到内核，所有这些项目都被压到内核栈中，而不是压到用户栈中。</p>

<p>异常处理程序运行在内核模式下，这意味着它们对所有的系统资源都有完全的访问权限。</p>

<p>7.一旦硬件触发了异常，剩下的工作就是由异常处理程序在软件中完成。在处理程序处理完事件之后，它通过执行一条特殊的“从中断返回”的指令，可选的返回到被中断的程序，该指令将适当的状态弹回到处理器的控制和数据寄存器中，如果异常中断的是一个用户程序，就将状态恢复为用户模式，然后将控制返回给被中断的程序。</p>

<p>8.异常可以分为四类：中断（interrupt）、陷阱（trap）、故障（fault）和终止（abort）。</p>

<p><img src="http://kobe1941.github.io/images/2019/12/10.jpg" alt="" /></p>

<p>需要注意的是，中断是在当前指令执行完成之后，才把控制转移给中断处理程序。剩下的异常类型（陷阱、故障和终止）是同步发生的，是执行当前指令的结果。我们把这类指令叫做故障指令。</p>

<p>9.陷阱是有意的异常，是执行一条指令的结果。就像中断处理程序一样，陷阱处理程序将控制返回到下一条指令。陷阱最重要的用途是在用户程序和内核之间提供一个像过程一样的接口，叫做系统调用。</p>

<p>10.用户程序经常需要向内核请求服务，比如读一个文件（read）、创建一个新的进程（fork）、加载一个新的程序（execve），或者终止当前进程（exit）。为了允许对这些内核服务的受控的访问，处理器提供了一条特殊的“syscall n”指令，当用户程序想要请求服务n时，可以执行这条指令。执行syscall指令会导致一个到异常处理程序的陷阱，这个处理程序解析参数，并调用适当的内核程序。</p>

<p>11.系统调用和普通的函数调用，它们的实现非常不同。普通函数运行在用户模式中，用户模式限制了函数可以执行的指令的类型，而且它们只能访问与调用函数相同的栈。系统调用运行在内核模式中，内核模式允许系统调用执行特权指令，并访问定义在内核中的栈。</p>

<p>12.故障由错误情况引起的，它可能能够被故障处理程序修正。如果处理程序能够修正这个错误情况，它就将控制返回到引起故障的指令，从而重新执行它。否则，处理程序返回到内核中的abort例程，abort会终止引起故障的应用程序。</p>

<p>一个经典的故障示例是缺页异常。</p>

<p>13.终止是不可恢复的致命错误造成的结果，通常是一些硬件错误。</p>

<p>14.Segment fault：通常是因为一个程序引用一个未定义的虚拟内存区域，或者因为程序试图写一个只读的文本段。</p>

<p>15.每个系统调用都有一个唯一的整数号，对应于一个到内核中跳转表的偏移量（注意：这个跳转表和异常表不一样）。</p>

<p>16.C程序用syscall 函数可以直接调用任何系统调用。</p>

<p>在 x86-64 系统上，系统调用是通过一条称为syscall 的陷阱指令来提供的。</p>

<p>所有到Linux系统调用的参数都是通过调用寄存器而不是栈传递的。按照惯例，寄存器%rax 包含系统调用号，寄存器%rdi、%rsi、%rdx、%r10、%r8和%r9包含最多6个参数。从系统调用返回时，寄存器%rcx和%r11 都会被破坏，%rax 包含返回值。</p>

<p>17.进程的经典定义就是一个执行中的程序的实例。系统中的每个程序都运行在某个进程的上下文context中。上下文是由程序正确运行所需的状态组成的。这个状态包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。</p>

<p>进程提供给应用程序的关键抽象：</p>

<p>一个独立的逻辑控制流，它提供一个假象，好像我们的程序独占的使用处理器。</p>

<p>一个私有的地址空间，它提供一个假象，好像我们的程序独占的使用内存系统。</p>

<p>18.PC值的序列叫做逻辑控制流，或者简称逻辑流。</p>

<p>19.一个逻辑流的执行在时间上与另一个流重叠，称为并发流。多个流并发的执行的一般现象被称为并发。一个进程和其他进程轮流运行的概念称为多任务。一个进程执行它的控制流的一部分的每一时间段叫做时间片。因此，多任务也叫做时间分片。</p>

<p>并发流的思想与流运行的处理器核数或者计算机数无关。如果两个流在时间上重叠，那么它们就是并发的，即使它们是运行在同一个处理器上。</p>

<p>并行流是并发流的一个真子集。如果两个流并发的运行在不同的处理器核或者计算机上，那么我们称它们为并行流，它们并行的运行，且并行的执行。</p>

<p>20.为了使操作系统内核提供一个无懈可击的进程抽象，处理器必须提供一种机制，限制一个应用可以执行的指令以及它可以访问的地址空间范围。</p>

<p>处理器通常用某个控制寄存器中的一个模式位来提供这种功能的，该寄存器描述了进程当前享有的特权。当设置了模式位时，进程就运行在内核模式中。一个运行在内核模式的进程可以执行指令集中的任何指令，并且可以访问系统中的任何内存位置。</p>

<p>没有设置模式位时，进程就运行在用户模式中。用户模式中的进程不允许执行特权指令。用户程序必须通过系统调用接口间接的访问内核代码和数据。</p>

<p>进程从用户模式变为内核模式的唯一方法是通过诸如中断、故障或者陷入系统调用这样的异常。</p>

<p>21.操作系统内核使用一种称为上下文切换的较高层形式的异常控制流来实现多任务。</p>

<p>内核为每个进程维持一个上下文context。</p>

<p>上下文就是内核重新启动一个被抢占的进程所需的状态。它由一些对象的值组成，这些对象包括通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构，比如描述地址空间的页表，包含有关当前进程信息的进程表，以及包含进程已打开文件的信息的文件表。</p>

<p>22.在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占了的进程。这种决策就叫做调度。</p>

<p>在内核调度了一个进程的运行后，它就抢占当前进程，并使用一种称为上下文切换的机制来将控制转移到新的进程。</p>

<p>上下文切换：保存当前进程的上下文；恢复某个先前被抢占的进程被保存的上下文；将控制传递给这个新恢复的进程。</p>

<p><img src="http://kobe1941.github.io/images/2019/12/11.jpg" alt="" /></p>

<p><img src="http://kobe1941.github.io/images/2019/12/12.jpg" alt="" /></p>

<p>23.sleep系统调用，它显式的请求让调用进程休眠。</p>

<p>pause函数让调用函数休眠，直到该进程收到一个信号。</p>

<p>24.每个进程都有一个唯一的正数进程ID（PID）。getpid函数返回调用进程的PID。getppid函数返回它的父进程的PID。</p>

<p>25.从程序员的角度，我们可以认为进程总是处于下面三种状态之一：</p>

<p>运行。进程要么在CPU上执行，要么在等待被执行且最终会被内核调度。</p>

<p>停止。进程的执行被挂起，且不会被调度。</p>

<p>终止。进程永远的停止了，进程会因为三种原因终止：收到一个信号，该信号的默认行为是终止进程；从主程序返回；调用exit函数。</p>

<p>exit函数以status退出状态来终止进程。</p>

<p>26.父进程通过调用fork函数创建一个新的运行的子进程。子进程得到与父进程用户级虚拟地址空间相同的（但是独立的）一份副本，包括代码和数据段、堆、共享库以及用户栈、子进程还获得与父进程任何打开文件描述符相同的副本，这就意味着当父进程调用fork时，子进程还获得与父进程中打开的任何文件。父进程和新创建的子进程之间最大的区别在于它们有不同的PID。</p>

<p>fork函数只被调用一次，却会返回两次：一次是在调用进程（父进程）中，一次是在新创建的子进程中。在父进程中，fork返回子进程的PID。在子进程中，fork返回0。因为子进程的PID总是为非零，返回值就提供一个明确的方法来分辨程序是在父进程还是在子进程中执行。</p>

<p>27.当一个进程由于某种原因终止时，内核并不是立即把它从系统中清楚。相反，进程被保持在一种已终止的状态中国，直到被它的父进程回收。一个终止了但还未被回收的进程称为僵死进程。</p>

<p>如果一个父进程终止了，进程会安排 init 进程成为它的孤儿进程的养父。init 进程的PID为1，是在系统启动时由内核创建的，它不会终止，是所有进程的祖先。如果父进程没有回收它的僵死子进程就终止了，那么内核会安排 init 进程去回收他们。</p>

<p>一个进程可以通过调用 waitpid 函数来等待它的子进程终止或者停止。</p>

<p>28.execve 函数在当前进程的上下文中加载并运行一个新程序。 execve 加载并运行可执行目标文件，调用一次并从不返回。execve加载了filename之后，它调用启动代码，启动代码设置栈，并将控制传递给新程序的主函数。</p>

<p>29.程序和进程之间的区别：</p>

<p>程序是一堆代码合数据；程序可以作为目标文件存在于磁盘上，或者作为段存在于地址空间中。</p>

<p>进程是执行中程序的一个具体的实例；程序总是运行在某个进程的上下文中。</p>

<p>30.一种更高层的软件形式的异常，称为Linux信号，它允许进程和内核中断其他进程。</p>

<p>一个信号就是一条小消息，它通知进程系统发生了一个某种类型的事件。</p>

<p>每种信号类型都对应于某种系统事件。低层的硬件异常是由内核异常处理程序处理的，正常情况下，对用户进程而言是不可见的。信号提供了一种机制，通知用户进程发生了这些异常。</p>

<p><img src="http://kobe1941.github.io/images/2019/12/13.jpg" alt="" /></p>

<p>31.传送一个信号到目的进程是由两个不同步骤组成的：</p>

<p>①发送信号。内核通过更新目的进程上下文中的某个状态，发送一个信号给目的进程。发送信号可以有如下两种原因：内核检测到一个系统事件，比如除零错误或者子进程终止；一个进程调用了kill 函数，显式的要求内核发送一个信号给目的进程。一个进程可以发送信号给它自己。</p>

<p>②接收信号。当目的进程被内核强迫以某种方式对信号的发送做出反应时，它就接收了信号。进程可以忽略这个信号，终止或者通过执行一个称为信号处理程序的用户层函数捕获这个信号。</p>

<p>一个发出而没有被接收的信号叫做待处理信号。在任何时刻，一种类型至多只会有一个待处理信号。如果一个进程有一个类型为k 的待处理信号，那么任何接下来发送到这个进程的类型为k 的信号都不会排队等待，它们只是被简单的丢弃。</p>

<p>一个待处理信号最多只能被接收一次。</p>

<p>32.默认的，一个子进程和它的父进程同属于一个进程组。一个进程可以通过使用setpgid 函数来改变自己或者其他进程的进程组。</p>

<p>33.一个为负的PID会导致信号被发送到进程组PID中的每个进程，比如kill 函数。</p>

<p>进程通过调用kill函数发送信号给其他进程（包括它们自己）。kill（pid, sig）。</p>

<table>
  <tbody>
    <tr>
      <td>如果pid 大于零，那么kill函数发送信号号码sig 给进程pid。如果pid 等于零，那么kill 发送信号sig 给调用进程所在进程组中的每个进程，包括调用进程自己。如果pid 小于零，kill 发送信号sig 给进程组</td>
      <td>pid</td>
      <td>（pid的绝对值）中的每个进程。</td>
    </tr>
  </tbody>
</table>

<p>34.进程可以通过调用alarm 函数向它自己发送SIGALRM信号。在任何情况下，对alarm 的调用都将取消任何待处理的闹钟。</p>

<p>35.当内核把进程p从内核模式切换到用户模式时，它会检查进程p的未被阻塞的待处理信号的集合。如果集合是非空的，那么内核选择集合中的某个信号k（通常是最小的k），并且强制p接受信号k。</p>

<p>36.进程可以通过signal 函数修改和信号相关联的默认行为。唯一的例外就是SIGSTOP和SIGKILL，它们的默认行为是不能修改的。</p>

<p>37.可以用volatile 类型限定符来定义一个变量，告诉编译器不要缓存这个变量。例如 volatile int g；</p>

<p>volatile限定符强迫编译器每次在代码中引用g时，都要从内存中读取g的值。</p>

<p>C提供一种整形数据类型 sig_atomic_t，对它的读和写保证会是原子（不可中断）的。</p>

<p>38.因为pending位向量中每种类型的信号只对应有一位，所以每种类型最多只能有一个未处理的信号。</p>

<p>39.不可以用信号来对其他进程中发生的事件计数。</p>

<p>40.Posix标准定义了sigaction函数，它允许用户在设置信号处理时，明确指定他们想要的信号处理语义。</p>

<p>41.C语言提供了一种用户级异常控制流形式，称为非本地跳转，它将控制直接从一个函数转移到另一个当前正在执行的函数，而不需要经过正常的调用-返回序列。非本地跳转是通过segjmp 和longjmp 函数来提供的。</p>

<p>setjmp 函数在env 缓冲区中保存当前调用环境，以供后面的longjmp使用，调用环境包括程序计数器、栈指针和通用目的寄存器。setjmp返回的值不能被赋值给变量。</p>

<p>setjmp 函数只被调用一次，但返回多次；longjmp 函数被调用一次，但从不返回。</p>

<p>42.非本地跳转的一个重要应用就是允许从一个深层嵌套的函数调用中立即返回，通常是由检测到某个错误情况引起的。如果在一个深层嵌套的函数调用中发现一个错误情况，我们可以使用非本地跳转直接返回到一个普通的本地化的错误处理程序，而不是费力的解开调用栈。</p>

<p>longjmp 允许它跳过所有中间调用的特性可能产生意外的后果。例如，如果中间函数调用中分配了某些数据结构，本来预期在函数结尾处释放它们，那么这些释放代码会被跳过，因而会产生内存泄漏。</p>

<p>非本地跳转的另一个重要应用是使一个信号处理程序分支到一个特殊的代码位置，而不是返回到被信号到达中断了的指令的位置。</p>

<p>可以把try 语句中的catch 子句看做类似于setjmp 函数。相似的，throw 语句就类似于longjmp 函数。</p>

<p>43.STRACE：打印一个正在运行的程序和它的子进程调用的每个系统调用的轨迹。</p>

<p>PS：列出当前系统中的进程（包括僵死进程）。</p>

<p>TOP：打印出关于当前进程资源使用的信息。</p>

<h2 id="section-11">第九章  虚拟内存</h2>

<p>1.为了更加有效的管理内存并且少出错，现代系统提供了一种对主存的抽象概念，叫做虚拟内存（VM）。它为每个进程提供了一个大的、一致的和私有的地址空间。</p>

<p>虚拟内存提供了三个重要的能力：①它将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它高效的使用了主存。②它为每个进程提供了一致的地址空间，从而简化了内存管理。③它保护了每个进程的地址空间不被其他进程破坏。</p>

<p>2.虚拟内存给予应用程序强大的能力，可以创建和销毁内存片，将内存片映射到磁盘文件的某个部分，以及与其他进程共享内存。可以加载一个文件的内容到内存中，而不需要进行任何显式的复制。</p>

<p>3.现代处理器使用的是一种称为虚拟寻址的寻址方式。</p>

<p>将一个虚拟地址转换为物理地址的任务叫做地址翻译，地址翻译需要CPU硬件和操作系统之间的紧密合作。CPU芯片上叫做内存管理单元（MMU）的专用硬件，利用存放在主存中的查询表来动态翻译虚拟地址，该表的内容由操作系统管理。</p>

<p>4.地址空间是一个非负整数地址的有序集合，如果地址空间中的证书是连续的，那么我们说它是一个线性地址空间。一个地址空间的大小是由表示最大地址所需要的位数来描述的。例如一个包含N=2^n个地址的虚拟地址空间就叫做一个n位地址空间。</p>

<p>5.概念上而言，虚拟内存被组织为一个由存放在磁盘上的N个连续的字节大小的单元组成的数组。磁盘上的数据被分割成块，这些块作为磁盘和主存之间的传输单元。VM系统通过将虚拟内存分割为称为虚拟页的大小固定的块来处理这个问题。每个虚拟页的大小为P=2^p字节，类似的，物理内存被分割为物理页，大小也为P字节（物理页也被称为页帧）。</p>

<p>6.因为大的不命中处罚和访问第一个字节的开销，虚拟页往往很大，通常是4KB-2MB。由于大的不命中处罚，DRAM缓存是全相联的，即任何虚拟页都可以放置在任何的物理页中。</p>

<p>与硬件对SRAM缓存相比，操作系统对DRAM缓存使用了更复杂精密的替换算法。</p>

<p>因为对磁盘的访问时间很长，DRAM缓存总是使用写回，而不是直写。</p>

<p>因为DRAM是全相联的，所以任意物理页都可以包含任意虚拟页。</p>

<p>7.页表将虚拟页映射到物理页。页表就是一个页表条目（PTE）的数组。虚拟地址空间中的每个页在页表中一个固定偏移量处都有一个PTE。</p>

<p>8.DRAM缓存不命中称为缺页。缺页异常调用内核中的缺页异常处理程序，该程序会选择一个牺牲页。</p>

<p>9.实际上，虚拟内存工作的相当好，这主要归功于我们的老朋友局部性。</p>

<p>局部性原则保证了在任意时刻，程序将趋向于在一个较小的活动页面集合上工作，这个集合叫做工作集或者常驻集合。在初始开销，也就是将工作集页面调度到内存中之后，接下来对这个工作集的引用将导致命中，而不会产生额外的磁盘流量。</p>

<p>如果工作集的大小超出了物理内存的大小，那么程序将产生一种不幸的状态，叫做抖动，这时页面将不断的换进换出。</p>

<p>多个虚拟页面可以映射到同一个共享物理页面上。</p>

<p>10.按需页面调度和独立的虚拟地址空间的结合，对系统中内存的使用和管理造成了深远的影响。特别的，VM简化了链接和加载、代码和数据共享，以及应用程序的内存分配。</p>

<p>简化链接。独立的地址空间允许每个进程的内存映像使用相同的基本格式，而不管代码和数据实际存放在物理内存的何处。这样的一致性极大的简化了链接器的设计和实现，允许链接器生成完全链接的可执行文件，这些可执行文件是独立于物理内存中代码和数据的最终位置的。</p>

<p>简化加载。加载器不从磁盘到内存实际复制任何数据。在每个页初次被引用时，要么是CPU取指令时引用的，要么是一条正在执行的指令引用一个内存位置时引用的，虚拟内存系统会按照需要自动的调入数据页。</p>

<p>将一组连续的虚拟页映射到任意一个文件中的任意位置的表示法称作内存映射。Linux提供一个称为mmap的系统调用，允许应用程序自己做内存映射。</p>

<p>简化共享。操作系统通过将不同进程中适当的虚拟页面映射到相同的物理页面，从而安排多个进程共享这部分代码的一个副本，而不是在每个进程中都包括单独的内核和C标准库的副本。</p>

<p>简化内存份额。当一个运行在用户进程中的程序要求额外的堆空间时，操作系统分配一个适当数字（例如k）个连续的虚拟内存页面，并且将它们映射到物理内存中任意位置的k个任意的物理页面。由于页表工作的方式，操作系统没有必要分配k个连续的物理内存页面。页面可以随机分散在物理内存中。</p>

<p>11.提供独立的地址空间使得区分不同进程的私有内存变得容易。但是，地址翻译机制可以以一种自然的方式扩展到提供更好的访问控制。因为每次CPU生成一个地址时，地址翻译硬件都会读一个PTE，所以通过在PTE上添加一些额外的许可位来控制对一个虚拟页面内容的访问十分简单。</p>

<p>如果一条指令违反了这些许可条件，那么CPU就触发一个一般保护故障，将控制传递给一个内核中的异常处理程序。Linux shell 一般将这种异常报告为 段错误 segment fault。</p>

<p>12.在任何既使用虚拟内存又使用SRAM高速缓存的系统中，都有应该使用虚拟地址还是使用物理地址来访问SRAM 高速缓存的问题。大多数系统是选择物理寻址的。使用物理寻址，多个进程同时在高速缓存中有存储块和共享来自相同虚拟页面的块成为很简单的事情。高速缓存无需处理保护问题，因为访问权限的检查是地址翻译过程的一部分。</p>

<p>13.内核虚拟内存包含内核中的代码和数据结构。有趣的是，Linux也将一组连续的虚拟页面（大小等于系统中DRAM的总量）映射到相应的一组连续的物理页面。这就为内核提供了一种便利的方法来访问物理内存中任何特定的位置。</p>

<p><img src="http://kobe1941.github.io/images/2019/12/14.jpg" alt="" /></p>

<p>PS：有兴趣可以了解下用户栈和内核的区别和联系，以及数量对比关系（一对一，一对多还是多对多？）。</p>

<p>14.内核为系统中的每个进程维护一个单独的任务结构（源代码中的task_struct）。任务结构中的元素包含或者指向内核运行该进程所需要的所有信息（例如，PID、指向用户栈的指针、可执行目标文件的名字，以及程序计数器）。</p>

<p>15.因为一个进程可以创建任意数量的新虚拟内存区域（使用mmap函数），所以顺序搜索区域结构的链表花销可能会很大。因为实际上，Linux在链表中构建了一棵树，并在这棵树上进行查找。</p>

<p>16.Linux通过将一个虚拟内存区域与一个磁盘上的对象关联起来，以初始化这个虚拟内存区域的内容，这个过程称为内存映射。</p>

<p>17.一旦一个虚拟页面被初始化了，它就在一个由内核维护的专门交换文件之间换来换去。交换文件也叫做交换空间或者交换区域。</p>

<p>18.一个对象可以被映射到虚拟内存的一个区域，要么作为共享对象，要么作为私有对象。</p>

<p>19.私有对象使用一种叫做写时复制的巧妙技术被映射到虚拟内存中。</p>

<p>20.关于execve函数加载和执行程序的过程见下图：</p>

<p><img src="http://kobe1941.github.io/images/2019/12/15.jpg" alt="" /></p>

<p>21.mmap(void* start, size_t length, int port, int flags, int fd, off_t offset)函数要求内核创建一个新的虚拟内存区域，最好是从地址start 开始的一个区域，并将文件描述符fd指定的对象的一个连续的偏映射到这个新的区域。连续的对象片大小为length字节，从距文件开始处偏移量为offset字节的地方开始。start地址仅仅是一个暗示，通常被定义为NULL。</p>

<p>munmap(void *start, size_t length) 函数删除从虚拟地址start 开始的，由接下来length 字节组成的区域。接下来对已删除区域的引用会导致段错误。</p>

<p>22.动态内存分配器维护着一个进程的虚拟内存区域，称为堆。对于每个进程，内核维护着一个变量brk，它指向堆的顶部。</p>

<p>23.显示分配器，要求应用显式的释放任何已分配的块。C++的new和delete操作符与C中的malloc和free相当。隐式分配器也叫做垃圾收集器，自动释放未使用的已分配的块的过程叫做垃圾收集。</p>

<p>24.malloc 不初始化它返回的内存。那些想要已初始化的动态内存的应用程序可以使用calloc，calloc 是一个基于malloc的瘦包装函数，它将分配的内存初始化为零。想要改变一个以前分配块的大小，可以使用realloc函数。</p>

<p>25.造成堆利用率很低的主要原因是一种称为碎片的现象，当虽然有未使用的内存但不能用来满足分配请求时，就发生这种现象。有两种形式的碎片：内部碎片和外部碎片。内部碎片是在一个已分配块比有效载荷大时发生的。外部碎片是当空闲内存合计起来足够满足一个分配请求，但是没有一个单独的空闲块足够大可以来处理这个请求时发生的。</p>

<p>因为外部碎片难以量化且不可能预测，所以分配器通常采用启发式策略来试图维持少量的大空闲块，而不是维持大量的小空闲块。</p>

<p>26.如果分配器不能为请求块找到合适的空闲块将发生什么呢？一个选择是通过合并那些在内存中物理上相邻的空闲块来创建一些更大的空闲块。如果还是不能生成一个足够大的块，那么分配器就会通过调用sbrk 函数，向内核请求额外的堆内存。</p>

<p>27.为了解决假碎片问题，任何实际的分配器都必须合并相邻的空闲块，这个过程称为合并。分配器可以选择立即合并，也就是在每次一个块被释放时，就合并所有的相邻块。或者它可以选择推迟合并，也就是等到某个稍晚的时候再合并空闲块。例如，分配器可以推迟合并，直到某个分配请求失败，然后扫描整个堆，合并所有的空闲块。</p>

<p>快速的分配器通常会选择某种形式的推迟合并。</p>

<p>28.C标准库中提供的GNU malloc 包就是采用的这种方法，因为这种方法既快速，对内存的使用也很有效率。</p>

<p>29.垃圾收集器是一种动态内存分配器，它自动释放程序不再需要的已分配块。在一个支持垃圾收集的系统中，应用显式分配堆块，但是从不显式的释放它们。</p>

<p>垃圾收集器将内存视为一张有向可达图。</p>

<p>30.像ML和Java这样的语言的垃圾收集器，对应用如何创建和使用指针有很严格的控制，能够维护可达图的一种精确的表示，因此也就能够回收所有垃圾。然而，诸如C和C++这样的语言的收集器通常不能维持可达图的精确表示。这样的收集器也叫做保守的垃圾收集器。</p>

<p>C程序的Mark &amp; Sweep收集器必须是保守的，其根本原因是C语言不会用类型信息来标记内存位置。</p>

<p>31.收集器可以按需提供它们的服务，或者它们可以作为一个和应用并行的独立线程，不断的更新可达图和回收垃圾。</p>

<p>32.虽然bss内存位置（诸如未初始化的全局C变量）总是被加载器初始化为零，但是对于堆内存却并不是这样的。一个常见的错误就是假设堆内存被初始化为零。</p>

<p>33.虚拟内存是为主存的一个抽象。虚拟内存提供三个重要的功能。第一，它在主存中自动缓存最近使用的存放磁盘上的虚拟地址空间的内容。虚拟内存缓存中的块叫做页。第二，虚拟内存简化了内存管理，进而又简化了链接、在进程间共享数据、进程的内存分配以及程序加载。最后，虚拟内存通过在每条页表条目中加入保护位，从而简化了内存保护。</p>

<p>34.内存映射为共享数据、创建新的进程以及加载程序提供了一种高效的机制。应用可以使用mmap函数来手工的创建和删除虚拟地址空间的区域。</p>

<h4 id="section-12">第三部分  程序间的交互和通信</h4>

<h2 id="io">第十章  系统级I/O</h2>

<p>1.输入/输出（I/O）是在主存和外部设备（例如磁盘驱动器、终端）之间复制数据的过程。</p>

<p>2.一个Linux文件就是一个m个字节的序列。所有的I/O设备（网络，磁盘和终端）都被模型化为文件，而所有的输入和输出都被当作对相应文件的读和写来执行。</p>

<p>3.打开文件时内核会返回一个小的非负整数，叫做描述符，它在后续对此文件的所有操作中标识这个文件。内核记录有关这个打开文件的所有信息。应用程序只需记住这个描述符。</p>

<p>Linux shell 创建的每个进程开始时都有三个打开的文件：标准输入（描述符为0）、标准输出（描述符为1）和标准错误（描述符为2）。</p>

<p>当应用完成了对文件的访问之后，它就通知内核关闭这个文件。作为响应，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中。无论一个进程因为何种原因终止时，内核都会关闭所有打开的文件并释放它们的内存资源。</p>

<p>4.文本文件是只含有ASCII或Unicode字符的普通文件，二进制文件是所有其他的文件。</p>

<p>5.目录是包含一组链接的文件，其中每个链接都将一个文件名映射到一个文件，这个文件可能是另一个目录。</p>

<p>套接字是用来与另一个进程进行跨网络通信的文件。</p>

<p>其他文件类型包含命名管道、符号链接，以及字符和块设备。</p>

<p>6.进程是通过调用open函数来打开一个已存在的文件或者创建一个新文件的。通过调用close函数关闭一个打开的文件。</p>

<p>关闭一个已关闭的描述符会出错。</p>

<p>通过调用lseek 函数，应用程序能够显示的修改当前文件的位置。</p>

<p>7.应用程序能够通过调用stat 和 fstat 函数，检索到关于文件的信息（有时也称为文件的元数据）。</p>

<p>8.内核用三个相关的数据结构来表示打开的文件：</p>

<p>描述符表。每个进程都有它独立的描述符表，它的表项是由进程打开的文件描述符来索引的。每个打开的描述符表项指向文件表中的一个表项。</p>

<p>文件表。打开文件的集合是由一张文件表来表示的，所有的进程共享这张表。每个文件表的表项组成包括当前的文件位置、引用计数，以及一个指向v-node表中对应表项的指针。关闭一个描述符会减少相应的文件表表项中的引用计数。内核不会删除这个文件表表项，直到它的引用计数为零。</p>

<p>v-node表。同文件表一样，所有的进程共享这张v-node表。每个表项包含stat结构中的大多数信息，包括st_mode和st_size 成员。</p>

<p><img src="http://kobe1941.github.io/images/2019/12/16.jpg" alt="" /></p>

<p>9.多个描述符也可以通过不同的文件表表项来引用同一个文件。例如，如果以同一个filename调用open函数两次，就会发生这种情况。</p>

<p><img src="http://kobe1941.github.io/images/2019/12/17.jpg" alt="" /></p>

<p>10.C语言定义了一组高级输入输出函数，称为标准I/O库。这个库libc 提供了打开和关闭文件的函数（fopen和fclose）、读和写字节的函数（fread和fwrite）、读和写字符串的函数（fgets和fputs），以及复杂的格式化的I/O函数（scanf和printf）。</p>

<p>标准I/O库将一个打开的文件模型化为一个流。每个ANSIC 程序开始时都有三个打开的流 stdin、stdout 和stderr ，分别对应于标准输入、标准输出和标准错误。</p>

<p>11.Unix I/O 模型是在操作系统内核中实现的。应用程序可以通过诸如open、close、lseek、read、write和stat这样的函数来访问Unix I/O。标准I/O函数提供了Unix I/O函数的一个更加完整的带缓冲的替代品。</p>

<p>12.对套接字使用lseek 函数是非法的。</p>

<p>13.建议在网络套接字上不要使用标准I/O 函数来进行输入和输出，而要使用健壮的RIO函数。如果你需要格式化的输出，使用sprintf函数在内存中格式化一个字符串，然后用 rio_writen把它发送到套接口。如果你需要格式化输入，使用rio_readlineb来读一个完整的文本行，然后用sscanf从文本行提取不同的字段。</p>

<h2 id="section-13">第十一章  网络编程</h2>

<p>1.客户端-服务器模型中的基本操作是事务。认识到客户端和服务器是进程，而不是常提到的机器或者主机，这是很重要的。</p>

<p>2.物理上而言，网络是一个按照地理远近组成的层次系统。最底层是LAN局域网，最流行的局域网是以太网。</p>

<p>在层次的更高级别中，多个不兼容的局域网可以通过叫做路由器的特殊计算机连接起来，组成一个Internet。每台路由器对于它所连接到的每个网络都有一个适配器（端口）。路由器也能连接高速点到点电话连接，这是称为WAN广域网的网络示例。</p>

<p>3.互联网络至关重要的特性是，它能由采用完全不同和不兼容技术的各种局域网和广域网组成。封装是互联网络的关键。</p>

<p>4.每台因特网主机都运行实现了TCP/IP协议的软件，几乎每个现代计算机系统都支持这个协议。因特网的客户端和服务器混合使用套接字接口函数和Unix I/O 函数来进行通信。通常将套接字函数实现为系统调用，这些系统调用会陷入内核，并调用各种内核模式的TCP/IP函数。</p>

<p>5.UDP 稍微扩展了IP协议，这样一来，包可以在进程间而不是在主机间传送。TCP 是一个构建在 IP 之上的复杂协议，提供了进程间可靠的全双工连接。</p>

<p>因特网主机上的进程能够通过连接和任何其他因特网主机上的进程通信。</p>

<p>6.TCP/IP 为任意整数数据项定义了统一的网络字节顺序（大端字节顺序）。在IP地址结构中存放的地址总是以（大端法）网络字节顺序存放的，即使主机字节顺序是小端法。</p>

<p>7.我们可以使用Linux的NSLOOKUP 程序来探究DNS 映射的一些属性。</p>

<p>8.因特网客户端和服务器通过在连接上发送和接收字节流来通信。从连接一对进程的意义上而言，连接是点对点的。从数据可以同时双向流动的角度来说，它是全双工的。</p>

<p>9.一个套接字是连接的一个端点。当客户端发起一个连接请求时，客户端套接字地址中的端口是由内核自动分配的，称为临时端口。然而，服务器套接字地址中的端口通常是某个知名端口，是和这个服务相对应的。例如，Web服务器通常使用端口80。</p>

<p>10.一个连接是由它两端的套接字地址唯一确定的。这对套接字地址叫做套接字对。</p>

<p><img src="http://kobe1941.github.io/images/2019/12/18.jpg" alt="" /></p>

<p><img src="http://kobe1941.github.io/images/2019/12/19.jpg" alt="" /></p>

<p>11.从Linux内核的角度来看，一个套接字就是通信的一个端点。从Linux程序的角度来看，套接字就是一个有相应描述符的打开文件。</p>

<p>12.客户端和服务器使用socket函数来创建一个套接字描述符。socket返回的clientfd描述符仅是部分打开的，还不能用于读写。客户端通过调用connect函数来建立和服务器的连接。connect函数会阻塞，一直到连接成功建立或是发生错误。</p>

<p>剩下的套接字函数——bind，listen和accept，服务器用它们来和客户端建立连接。</p>

<p>bind函数告诉内核将addr中的服务器套接字地址和套接字描述符sockfd联系起来。</p>

<p>服务器调用listen函数告诉内核，描述符是被服务器而不是客户端使用的。listen函数将socketfd从一个主动套接字转化为一个监听套接字。backlog 参数暗示了内核在开始拒绝连接请求之前，队列中要排队的未完成的连接请求的数量。通常我们会把它设置为一个较大的值，比如1024。</p>

<p>服务器通过调用accept函数来等待来自客户端的连接请求。</p>

<p>accept函数等待来自客户端的连接请求到达侦听描述符，然后在addr中填写客户端的套接字地址，并返回一个已连接描述符，这个描述符可被用来利用Unix I/O 函数与客户端通信。</p>

<p>监听描述符是作为客户端连接请求的一个端点。它通常被创建一次，并存在于服务器的整个生命周期。已连接描述符是客户端和服务器之间已经建立起来了的连接的一个端点。服务器每次接受连接请求时都会创建一次，它只存在于服务器为一个客户端服务的过程中。</p>

<p>在第一步中，服务器调用accept，等待连接请求到达监听描述符，具体的我们设定为描述符3。描述符0-2是预留给了标准文件的。</p>

<p>在第二步中，客户端调用connect函数，发送一个连接请求到listenfd。第三步，accept函数打开了一个新的已连接描述符connfd，在clientfd 和connfd 之间建立连接，并且随后返回connfd 给应用程序。</p>

<p><img src="http://kobe1941.github.io/images/2019/12/20.jpg" alt="" /></p>

<p>13.有监听描述符和已连接描述符之间的区别，可以使得我们可以建立并发服务器，它能够同时处理许多客户端连接。例如，每次一个连接请求到达监听描述符时，我们可以派生（fork）一个新的进程，它通过已连接描述符与客户端通信。</p>

<p>14.客户端关闭描述符（close），这会导致发送一个EOF通知到服务器，当服务器从它的reo_readlineb函数收到一个为零的返回码时，就会检测到这个结果。</p>

<p>15.其实并没有EOF字符这样的一个东西。进一步来说，EOF是由内核检测到的一种条件。应用程序在它接收到一个由read函数返回的零返回码时，它就会发现出EOF条件。对于磁盘文件，当前文件位置超出文件长度时，会发生EOF。对于因特网连接，当一个进程关闭连接它的那一端时，会发生EOF。连接另一端的进程在试图读取流中最后一个字节之后的字节时，会检测到EOF。</p>

<p>16.如果一个服务器写一个已经被客户端关闭了的连接，那么第一次这样的写会正常返回，但是第二次就会引起发送SIGPIPE 信号。</p>

<h2 id="section-14">第十二章  并发编程</h2>

<p>1.当一个应用正在等待来自慢速I/O设备的数据到达时，内核会运行其他进程，使CPU保持繁忙。每个应用都可以按照类似的方式，通过交替执行I/O请求和其他有用的工作来利用并发。</p>

<p>2.使用应用级并发的应用程序称为并发程序。现代操作系统提供了三种基本的构造并发程序的方法：</p>

<p>①进程。用这种方法，每个逻辑控制流都是一个进程，由内核来调度和维护。因为进程有独立的虚拟地址空间，想要和其他流通信，控制流必须使用某种显示的进程间通信（IPC）机制。</p>

<p>②I/O 多路复用。在这种形式的并发编程中，应用程序在一个进程的上下文中显示的调度它们自己的逻辑流。逻辑流被模型化为状态机，数据到达文件描述符后，主程序显式的从一个状态转换到另一个状态。</p>

<p>③线程。线程是运行在一个单一进程上下文中的逻辑流，由内核进行调度。你可以把线程看成是其他两种方式的混合体，像进程流一样由内核进行调度，而像I/O多路复用流一样共享同一个虚拟地址空间。</p>

<p>3.对于在父、子进程间共享状态信息，进程有一个非常清晰的模型：共享文件表，但是不共享用户地址空间。进程有独立的地址空间既是优点也是缺点。为了共享信息，它们必须使用显示的IPC机制。基于进程的设计的另一个缺点是，它们往往比较慢，因为进程控制和IPC的开销很高。</p>

<p>4.waitpid函数和信号是基本的IPC机制，它们允许进程发送小消息到同一主机上的其他进程。套接字接口是IPC的一种重要形式，它允许不同主机上的进程交换任意的字节流。</p>

<p>5.I/O多路复用技术的基本思想，就是使用select函数，要求内核挂起进程，只有在一个或多个I/O事件发生后，才将控制返回给应用程序。</p>

<p>6.现代高性能服务器（例如Node.js，nginx和Tornado）使用的都是基于I/O多路复用的事件驱动的编程方式，主要是因为相比于进程和线程的方式，它有明显的性能优势。</p>

<p>事件驱动设计的一个优点是，它比基于进程的设计给了程序员更多的对程序行为的控制。</p>

<p>一个基于I/O多路复用的事件驱动服务器是运行在单一进程上下文中的，因此每个逻辑流都能访问该进程的全部地址空间。这使得在流之间共享数据变得很容易。</p>

<p>事件驱动设计常常比基于进程的设计要高效得多，因为它们不需要进程上下文切换来调度新的流。</p>

<p>事件驱动设计一个明显的缺点就是编码复杂。修改事件驱动服务器来处理部分文本行不是一个简单的任务，但是基于进程的设计却能处理得很好，而且是自动处理的。基于事件的设计另一个重要的缺点是它们不能充分利用多核处理器。</p>

<p>7.线程就是运行在进程上下文中的逻辑流。线程由内核自动调度，每个线程都有它自己的线程上下文，包括一个唯一的整数线程ID、栈、程序计数器、通用目的寄存器和条件码。所有的运行在一个进程里的线程共享该进程的整个虚拟地址空间。</p>

<p>8.同进程一样，线程由内核自动调度，并且内核通过一个整数ID来识别线程。同基于I/O多路复用的流一样，多个线程运行在单一进程的上下文中，因此共享这个进程虚拟地址空间的所有内容，包括它的代码、数据、堆、共享库和打开的文件。</p>

<p>9.一个线程的上下文要比一个进程的上下文小得多，线程的上下文切换要比进程的上下文切换快得多。</p>

<p>和一个进程相关的线程组成一个对等（线程）池，独立于其他线程创建的线程。主线程和其他线程的区别仅在于它总是进程中第一个运行的线程。对等（线程）池概念的主要影响是，一个线程可以杀死它的任何对等线程，或者等待它的任意对等线程终止。另外，每个对等线程都能读写相同的共享数据。</p>

<p>10.Posix线程（Pthreads）是在C程序中处理线程的一个标准接口。</p>

<p>线程通过调用pthread_create函数来创建其他线程。</p>

<p>新线程可以通过调用pthread_self函数来获得它自己的线程ID。</p>

<p>通过调用pthread_exit函数，线程会显式的终止。如果主线程调用pthread_exit，它会等待所有其他对等线程终止，然后再终止主线程和整个进程。</p>

<p>某个对等线程调用Linux的exit函数，该函数终止进程以及所有与该进程相关的线程。</p>

<p>另一个对等线程通过以当前线程ID作为参数调用pthread_cancel函数来终止当前线程。</p>

<p>线程通过调用pthread_join函数等待其他线程终止。pthread_join函数会阻塞，直到其他线程终止。pthread_join函数只能等待一个指定的线程终止，没有办法让pthread_wait等待任意一个线程终止。</p>

<p>11.在任何一个时间点上，线程是可结合的或者是分离的。一个可结合的线程能够被其他线程收回和杀死。在被其他线程回收之前，它的内存资源（例如栈）是不释放的。相反，一个分离的线程是不能被其他线程回收或杀死的。它的内存资源在它终止时由系统自动释放。</p>

<p>12.在现实程序中，有很好的理由要使用分离的线程。例如，一个高性能Web服务器可能在每次收到Web浏览器的连接请求时都创建一个新的对等线程。在这种情况下，每个对等线程都应该在它开始处理请求之前分离它自身，这样就能在它终止后回收它的内存资源了。</p>

<p>13.一组并发线程运行在一个进程的上下文中。每个线程都有它自己独立的线程上下文，包括线程ID、栈、栈指针、程序计数器、条件码和通用目的寄存器值。每个线程和其他线程一起共享进程上下文的剩余部分。这包括整个用户虚拟地址空间，它是由只读文本（代码）、读/写数据、堆以及所有的共享库代码和数据区域组成的。线程也共享相同的打开文件的集合。</p>

<p>14.寄存器是从不共享的，而虚拟内存总是共享的。</p>

<p>15.各自独立的线程栈的内存模型不是那么整齐清楚的。这些栈被保存在虚拟地址空间的栈区域中，并且通常是被相应的线程独立的访问的。我们说通常而不是总是，是因为不同的线程栈是不对其他线程设防的。所以，如果一个线程以某种方式得到一个指向其他线程栈的指针，那么它就可以读写这个栈的任何部分。</p>

<p>16.以提供互斥为目的的二元信号量常常也称为互斥锁。</p>

<p>17.饥饿就是一个线程无限期的阻塞，无法进展。</p>

<p>18.并行程序是一个运行在多个处理器上的并发程序。因此，并行程序的集合是并发程序集合的真子集。</p>

<p>19.并行编程的一项重要教训：同步开销巨大，要尽可能避免。如果无可避免，必须要用尽可能多的有用计算弥补这个开销。</p>

<p>20.有一类重要的线程安全函数，叫做可重入函数，其特点在于它们具有这样一种属性：当它们被多个线程调用时，不会引用任何共享数据。</p>

<p><img src="http://kobe1941.github.io/images/2019/12/21.jpg" alt="" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[WWDC2019之启动时间与Dyld3]]></title>
    <link href="http://kobe1941.github.io/blog/launch-optimize-from-wwdc2019.html"/>
    <updated>2019-09-13T13:40:48+08:00</updated>
    <id>http://kobe1941.github.io/blog/launch-optimize-from-wwdc2019</id>
    <content type="html"><![CDATA[<p>WWDC从2016，2017到2019都有session对APP启动的过程以及如何优化做过介绍，WWDC2019因为把Dyld3开放给所有APP，所以Apple重新梳理了启动的各个阶段，并给出了对应的优化建议。</p>

<p>本文内容主要来自WWDC2019，图片取自WWDC的PPT或视频中截图；涉及到Dyld3的内容来自WWDC2017的一个session。</p>

<!--more-->

<h2 id="section">一、启动各个阶段的介绍</h2>

<p>启动类型</p>

<p><img src="http://kobe1941.github.io/images/2019/09/13/1.png" alt="" /></p>

<p>1.最好是把启动时间控制在400ms内，因为这是启动动画的时间；系统要用100ms的时间来初始化APP，所以留给了你300ms的时间来构建你的第一个view；你可以懒加载或者异步加载数据。</p>

<p>2.iOS13带来了dyld3，虽然dyld3在WWDC2017的时候介绍过，但是iOS13终于带入了它；dyld3可以缓存runtime的dependency（库）来改善热启动的耗时。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">Dynamic Linker loads shared libraries and frameworks
</span><span class="line">Introduces caching of runtime dependencies to improve warm launch </span></code></pre></td></tr></table></div></figure></notextile></div>

<p>启动的各个阶段</p>

<p><img src="http://kobe1941.github.io/images/2019/09/13/2.png" alt="" /></p>

<p>3.为了充分利用dyld3带来的优化，苹果建议避免链接不使用的动态库，以及启动时避免使用类似DLOpen和NSBundleLoad的动态库的加载（loading），因为这会抵消缓存所带来的优势。最后就是你需要硬链接你的依赖dependency库，现在这个过程比之前更快了。（硬链接应该是dyld3自带的功能？）</p>

<p><img src="http://kobe1941.github.io/images/2019/09/13/3.png" alt="" /></p>

<p>4.libSystemInit是System interface阶段的后面一部分内容，这是在给你的APP初始化低级别的系统组件，这个过程是固定的系统层面的消耗。开发者不必过多关注这个阶段。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">Initializes the interfaces with low level system components
</span><span class="line">System side work with a fixed cost </span></code></pre></td></tr></table></div></figure></notextile></div>

<p>5.之后是runtime的初始化，这是系统在初始化Objective-C和Swift的runtime。一般的，在这一步你的APP不应该做任何事除非你有静态初始化函数，这些静态函数可能在你的代码里，也可能在你链接的库里。我们也不建议使用静态初始化（函数）。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">Initializes the language runtime
</span><span class="line">Invokes all class static load methods </span></code></pre></td></tr></table></div></figure></notextile></div>

<p>如果你自己的framework里用到了静态初始化，可以考虑暴露API，以尽早初始化你的堆栈。——言下之意是用户在启动时主动调用该API，而不是写到+load函数里？</p>

<p>如果是必须要用到静态初始化，把代码从类的load函数里移动到initialize函数里去。</p>

<p><img src="http://kobe1941.github.io/images/2019/09/13/4.png" alt="" /></p>

<p>6.UIKit 初始化。系统会在这一步实例化你的UIApplication和UIApplicationDelegate。这个阶段大部分是系统的工作，设置事件处理和系统集成/整合。你仍然可以影响这个阶段的耗时，比如子类化UIApplication，或者在UIApplicationDelegate的函数里做一些别的工作（通常是增大耗时o(╯□╰)o）。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">Instantiates the UIApplication and UIApplicationDelegate
</span><span class="line">Begins event processing and integration with the system </span></code></pre></td></tr></table></div></figure></notextile></div>

<p><img src="http://kobe1941.github.io/images/2019/09/13/5.png" alt="" /></p>

<p>7.之后是Application 的初始化。一般的回调顺序如下：</p>

<p><code>application:willFinishLaunchingWithOptions:</code></p>

<p><code>application:didFinishLaunchingWithOptions:</code></p>

<p>iOS13之前</p>

<p><code>applicationDidBecomeActive:</code></p>

<p>iOS13之后，新增了UISceneDelegate的代理回调函数</p>

<p><code>scene:willConnectToSession</code></p>

<p><code>sceneWillEnterForeground</code></p>

<p><code>sceneDidBecomeActive</code></p>

<p>苹果建议推迟跟第一屏展示不相关的工作，把这些工作放到后台去做或者全部推迟。</p>

<p>如果你采用了UIScenes的API，则可以在多个Scenes之间共享资源，这是为了避免多次去做不必要的工作。</p>

<p><img src="http://kobe1941.github.io/images/2019/09/13/6.png" alt="" /></p>

<p>8.然后是Frist Frame Render阶段。首帧渲染过程为创建views，设置好布局，然后进行渲染。</p>

<p><code>loadView</code></p>

<p><code>viewDidLoad</code></p>

<p><code>layoutSubviews </code></p>

<p>这个阶段可以做的优化有：</p>

<p>减少视图view的数量；</p>

<p>减少视图view的层级（flattening your views）；</p>

<p>懒加载那些在启动过程中不会立即进行展示的view；</p>

<p>注意你的autolayout，尽量减少约束的数量；——干脆使用手动frame计算</p>

<p><img src="http://kobe1941.github.io/images/2019/09/13/7.png" alt="" /></p>

<p>9.最后进入到Extended的阶段（延长/扩展阶段）。</p>

<p>从首帧后到最后一帧之间，APP的某个特定阶段；</p>

<p>异步加载数据的阶段；</p>

<p>不是所有APP都有这个阶段；</p>

<p>这个阶段时APP应该是可交互和可响应的；</p>

<p>可以用操作系统的 signpost API来标记和测量两个时间周期内的消耗。</p>

<p><code>Leverage os_signpost to measure work </code></p>

<p><img src="http://kobe1941.github.io/images/2019/09/13/8.png" alt="" /></p>

<h2 id="section-1">二、测量启动</h2>

<p>1.测量启动过程</p>

<p>要去除掉网络和后台进程的干扰；</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">Remove sources of variance to produce more consistent results
</span><span class="line">May result in launch times that are not representative
</span><span class="line">Use consistent results to evaluate progress</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>2.tips关于设置干净和一致的测试环境</p>

<p>①重启手机，然后静置几分钟，用来清除任何启动时的工作；</p>

<p>②设置手机为飞行模式，或者使用Mock网络数据；</p>

<p>③iCloud在后台工作会干扰APP启动时间的测量，所以测量过程中使用不变的iCloud账号和不变的数据，或者干脆退出iCloud；</p>

<p>④使用release版本的APP进行测试，避免debug代码的干扰，还能享受编译器的优化（跟线上用户保持一致）；</p>

<p>⑤测试warm launch的数据，这样子可以保持更好的一致性，一部分APP的数据已经在内存里了，一部分系统服务也已经跑起来了；</p>

<p>⑥创造多个mock数据是非常重要的，比如用户数据量少和用户数据量多的情况，都要测量到；</p>

<p>⑦挑选多个设备来测试，并保证他们在测试过程中的一致性；一定要包含一些旧的设备，以及你的APP所支持的最旧的版本（指iOS操作系统版本）；</p>

<p>Xcode11开始，XCTest也提供了测量启动性能的API。只需要几行代码，Xcode就能重复启动你的APP，并提供启动性能的统计结果。</p>

<p><img src="http://kobe1941.github.io/images/2019/09/13/9.png" alt="" /></p>

<p>3.测量的三个提示和技巧</p>

<p>①首先最小化你的启动过程；</p>

<p>最小化过程的时候，应该推迟任何跟展示首帧无关的操作，比如推迟暂时不展示的view或暂时用不到的功能的初始化；</p>

<p>千万不要block住主线程，不管是网络IO操作，文件IO操作还是其他，把这些移动到后台线程去；</p>

<p>减少内存的占用，内存的分配和操作是耗时的；</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">Defer work unrelated to first frame
</span><span class="line">Move blocking work off main thread
</span><span class="line">Reduce memory usage </span></code></pre></td></tr></table></div></figure></notextile></div>

<p>②然后按照优先级来安排你的启动过程；要保证这些工作的安排是合适的；</p>

<p>这意味着把不同优先级的工作安排到不同的线程去执行比以往任何时候都更重要。</p>

<p>可以关注一下WWDC 2017对GCD的深入介绍，讲了怎么正确的使用并行队列。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">Identify the right QoS for your task
</span><span class="line">Utilize scheduler optimizations for app launch
</span><span class="line">Preserve the priority with the right primitives </span></code></pre></td></tr></table></div></figure></notextile></div>

<p>③最后对这些过程进行优化；</p>

<p>在启动过程中，应该限制到只去拉去自己需要的数据；</p>

<p>优化算法和数据结构；——指不要把启动时需要的数据结构搞的太复杂，造成拉取太多并不需要的数据</p>

<p>你应该缓存你的资源和计算结果，这是为了降低在做多次不必要的操作时产生的CPU和内存消耗；</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">Simplify or limit existing work
</span><span class="line">Optimize algorithms and data structures
</span><span class="line">Cache resources and computations </span></code></pre></td></tr></table></div></figure></notextile></div>

<p>4.Apple新带来的启动监控方式  <strong>MetricKit</strong></p>

<p>可以收集电源和性能统计数据，每24小时汇总数据进行上报。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">Collect custom power and performance metrics
</span><span class="line">
</span><span class="line">Aggregated results delivered every 24 hours </span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="instrumentsxctestdemo-app">三、使用Instruments和XCTest来优化demo app的启动性能</h2>

<p>1.Instruments对demo APP的启动耗时进行分析</p>

<p>这一节主要是介绍了这个新的工具是如何使用的，直接看视频即可。</p>

<p>①Instruments重新编译APP会使用release模式</p>

<p><code>Xcode to recompile your app in release mode, so that you can take the advantages of compiler time optimizations.</code></p>

<p>②Xcode 11的Instruments提供了启动时间的模板，可以用来专门做这一块的性能统计和分析。</p>

<p><code>iOS 13, or Xcode 11, we now have the AppLaunchTemplate, which we can use specifically for triage purposes like this, figuring out what's wrong with AppLaunch.</code></p>

<p>2.分析各个线程</p>

<p><code>The first few phases marked in purple are the phases that occur before your main function is invoked within your app.</code></p>

<p>紫色表示pre-main阶段，在main函数执行前的阶段。</p>

<p><code>Onto the green phases, these phases of the early phases that occur at the very first of your main function, as your app finishes its launch and draws its first frame in UI.</code></p>

<p>绿色表示进入到main阶段。</p>

<p><code>Speaking of thread states, gray means it's blocked, meaning that the thread isn't doing any work.</code></p>

<p>灰色表示线程被block住了，该线程目前啥都没做。</p>

<p><code>Red means it's runnable, meaning that there's work scheduled to be done, but lacking CPU resources.</code></p>

<p>红色表示可执行，也就是待调度的状态，但是缺乏CPU资源。</p>

<p><code>Orange means it's preempted, meaning that it was doing work but got interrupted in favor of other competing work that has a higher priority.</code></p>

<p>orange代表该线程正在执行某个操作，但是被某个更高优先级的线程打断了，高优先级的线程完成了它才能继续执行。</p>

<p><code>And last but not least, blue means it's running, meaning that it's actually doing work on the CPU core.</code></p>

<p>蓝色表示正在运行中的线程，正在被CPU调度中。</p>

<p><img src="http://kobe1941.github.io/images/2019/09/13/10.png" alt="" /></p>

<p>3.iOS系统进行的优化</p>

<p><code>Now notice that this initial phase only took 6 milliseconds as it sets up its system interfaces.</code></p>

<p><code>This is primarily due to the benefits of dyld3 introduction and third-party apps, in addition to other system layer enhancements.</code></p>

<p>system interface阶段只花了6ms，这是得益于dyld3和其他第三方APP，以及其他系统层面的优化。开发者可以不用写一行代码就能获得这些优化。</p>

<p><code>This discrepancy comes from the overhead of the profiling mechanism itself, which does give us a lot of information and insight, but has a cost of its own.</code></p>

<p>虽然这个阶段只花了6ms，但是因为instrumens的测量工具，导致总计花费了149ms，多出来的时间都是测量工具造成的。</p>

<p>但是如果使用XCTest的API来测量启动的性能数据，则不会有这个消耗。在demo APP中，使用Instruments的统计时间是500ms，而使用XCTest测量的时间是300ms，这个差值就是Instruments工具自身的消耗。</p>

<p>XCTest会去掉冷启动带来的数据干扰和误差，默认执行5次热启动，然后把数据汇总。</p>

<p><code>As mentioned before, dyld3 brings caching of your runtime dependencies to your apps, which you saw in the demo, that provided a huge improvement.</code></p>

<p>dyld3缓存了你的APP runtime的依赖库，这是一个很大的改善。</p>

<p><code> The Scheduler has also been optimized to help prioritize the work that happens during launch.</code></p>

<p>Scheduler也优化过以支持APP启动时区分优先级的工作。</p>

<p><code> We also put Auto Layout and Objective-C under the microscope and made a bunch of optimizations there.</code></p>

<p>我们同时优化了autolayout和OC的性能。</p>

<p><code>And then finally, we have exciting changes to app packaging coming later this year.</code></p>

<p>最后，我们会在今年晚些时候，带来APP打包方面的令人激动的改变。</p>

<p>Apple已经做的和即将要做的（app package）优化：</p>

<p><img src="http://kobe1941.github.io/images/2019/09/13/11.png" alt="" /></p>

<p><img src="http://kobe1941.github.io/images/2019/09/13/12.png" alt="" /></p>

<h2 id="appletips">四、Apple给的关于启动的Tips</h2>

<p>①不要事后才想起来做优化，应该在开始写代码的时候就要注意，在每一次bug fixed/重构/功能开发的时候去注意性能；积少成多，如果刚开始的不注意一些微小的优化，后面就会积累变成很大的消耗，而且后期会很难找到原因；</p>

<p>②应该经常性的去测量APP的启动性能数据；</p>

<p>③关注一下Xcode organizer，你就能知道你的APP在线上的表现；在iOS13下，用户同意的情况下，Apple会每24小时会把APP的性能数据发送到你的Organizer；iOS13已经支持MetricKit，它可以把收集到的性能数据通过APP内的代理函数回调给开发者自己分析和使用；</p>

<p><img src="http://kobe1941.github.io/images/2019/09/13/13.png" alt="" /></p>

<h2 id="dyld3">五、关于Dyld3</h2>

<p>本节内容主要来自WWDC2017。</p>

<p>Dyld3开放给第三方的APP，是iOS13之后第三方APP启动速度会变快的最大原因。</p>

<p>启动闭包（launch closure）：这是一个新引入的概念，指的是 app 在启动期间所需要的所有信息。比如这个 app 使用了哪些动态链接库，其中各个符号的偏移量，代码签名在哪里等等。</p>

<p><code>perform symbol lookups</code>这个步骤表示执行符号查找。（例如：如果你使用了printf()函数，就会查找printf是否在库系统中，找到它的地址，将它赋值到你的程序中的函数指针）。</p>

<p>Dyld2和Dyld3的对比</p>

<p><img src="http://kobe1941.github.io/images/2019/09/13/14.png" alt="" /></p>

<p>Dyld2做的事情</p>

<p><img src="http://kobe1941.github.io/images/2019/09/13/15.png" alt="" /></p>

<p>Dyld3做的事情</p>

<p><img src="http://kobe1941.github.io/images/2019/09/13/16.png" alt="" /></p>

<p>详细展开其在APP进程外和APP进程内做的事情</p>

<p>上半部分表示进程外</p>

<p><img src="http://kobe1941.github.io/images/2019/09/13/17.png" alt="" /></p>

<p>下半部分表示在进程内做的</p>

<p><img src="http://kobe1941.github.io/images/2019/09/13/18.png" alt="" /></p>

<p><img src="http://kobe1941.github.io/images/2019/09/13/19.png" alt="" /></p>

<p>dyld2是纯粹的in-process，也就是在程序进程内执行的，也就意味着只有当应用程序被启动的时候，dyld2才能开始执行任务。</p>

<h4 id="dyld-2">dyld 2主要工作流程为：</h4>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class=""><span class="line">•dyld的初始化，主要代码在dyldbootstrap::start，接着执行dyld::main，dyld::main代码较多，是dyld加载的核心部分；
</span><span class="line">•检查并准备环境，比如获取二进制路径，检查环境变量，解析主二进制的image header等信息；
</span><span class="line">•实例化主二进制的image loader，校验主二进制和dyld的版本是否匹配；
</span><span class="line">•检查shared cache是否已经map，没有的话则先执行map shared cache操作；
</span><span class="line">•检查DYLD_INSERT_LIBRARIES，有的话则加载插入的动态库（实例化image loader）;
</span><span class="line">•执行link操作。这个过程比较复杂，会先递归加载依赖的所有动态库（会对依赖库进行排序，被依赖的总是在前面），同时在这阶段将执行符号绑定，以及rebase，binding操作；
</span><span class="line">•执行初始化方法。OC的+load以及C的constructor方法都会在这个阶段执行；
</span><span class="line">•读取Mach-O的LC_MAIN段获取程序的入口地址，调用main方法。</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="section-2">简化版：</h4>

<p>①解析 mach-o 文件，找到其依赖的库，并且递归的找到所有依赖的库，形成一张动态库的依赖图。iOS 上的大部分 app 都依赖几百个动态链接库（大部分是系统的动态库），所以这个步骤包含了较大的工作量。</p>

<p>②匹配 mach-o 文件到自身的地址空间</p>

<p>③进行符号查找（perform symbol lookups）：比如 app 中调用了 printf 方法，就需要去系统库中查找到 printf 的地址，然后将地址拷贝到 app 中的函数指针中</p>

<p>④rebase和binding：由于 app 需要让地址空间配置随机加载，所以所有的指针都需要加上一个基地址</p>

<p>⑤运行初始化程序，之后运行 main() 函数</p>

<p>那么这些步骤在性能、安全性和可测试性上应该如何被优化呢？</p>

<p>苹果提出了这样两点思路：</p>

<p>①识别安全性敏感的组件：解析 mach-o 文件并寻找依赖是安全性敏感的，因为恶意篡改的 mach-o 头部可以进行某些攻击，如果一个 app 使用了 @rpath，那么恶意修改路径或者将一些库插入到特定的地方，攻击者就可以毁坏 app。所以这部分工作需要被搬到进程外来完成，比如搬到一个 daemon 进程中。</p>

<p>②识别可以被缓存的部分：符号查找就是其中一个，因为在一个特定的库中，除非软件更新或者这个库被改变，不然每个符号都应该有固定的偏移量。</p>

<p>以上两点思路也是 dyld 3.0 的优化思路。在 dyld 3.0 中，mach-o 头部解析和符号查找工作完成后，这些执行结果会被作为“启动闭包（launch closure）”写入硬盘。</p>

<p>因此iOS操作系统的后台守护进程可以完成所有的这些工作。然后我们确定大量占用资源的部分，也就是占用缓冲的部分。它们是符号查找，因为在给定的库中，除非进行软件更新或者在磁盘上更改库，符号将始终位于库中的相同的偏移位置。</p>

<p>Dyld3中，将这些部分移到上层（图中红色的部分），然后向磁盘写入闭包处理 “Write closure to disk”。这样，启动闭包处理就成了启动程序的重要环节。稍后可以在APP的进程中使用 dyld 3包含的这三个部分，</p>

<p>启动闭包比mach-o更简单。它们是内存映射文件，不需要用复杂的方法进行分析。</p>

<p>我们可以简单的验证它们，这样可以提高速度。</p>

<p>dyld3是部分out-of-process，部分in-process。上图中，虚线之上的部分是out-of-process的，在App下载安装和版本更新的时候会去执行。</p>

<h4 id="dyld-3">dyld 3包含三个组件：</h4>

<p>①本APP进程外的Mach-O分析器/编译器；</p>

<p>在dyld 2的加载流程中，Parse mach-o headers和Find Dependencies存在安全风险（可以通过修改mach-o header及添加非法@rpath进行攻击），而Perform symbol lookups会耗费较多的CPU时间，因为一个库文件不变时，符号将始终位于库中相同的偏移位置，这两部分在dyld 3中将采用提前写入把结果数据缓存成文件的方式构成一个”lauch closure“（可以理解为缓存文件）。</p>

<p>它处理了所有可能影响启动速度的 search path，@rpaths 和环境变量；它解析 mach-o 二进制文件，分析其依赖的动态库，并且完成了所有符号查找的工作；最后它将这些工作的结果创建成了启动闭包，写入缓存，这样，在应用启动的时候，就可以直接从缓存中读取数据，加快加载速度。</p>

<p>这是一个普通的 daemon 进程，可以使用通常的测试架构。</p>

<p>out-of-process是一个普通的后台守护程序，因为从各个APP进程抽离出来了，可以提高dyld3的可测试性。</p>

<p>②本进程内执行”lauch closure“的引擎；验证”lauch closures“是否正确，把dylib映射到APP进程的地址空间里，然后跳转到main函数。此时，它不再需要分析mach-o header和执行符号查找，节省了不少时间。</p>

<p>③”lauch closure“的缓存：</p>

<p>iOS操作系统内置APP的”lauch closure“直接内置在shared cache共享缓存中，我们甚至不需要打开一个单独的文件；</p>

<p>而对于第三方APP，将在APP安装或更新版本时（或者操作系统升级时？）生成lauch closure启动闭包，因为那时候的系统库已经发生更改。这样就能保证”lauch closure“总是在APP打开之前准备好。启动闭包会被写到到一个文件里，下次启动则直接读取和验证这个文件。</p>

<p>在 iOS，tvOS，watchOS 中，一切（生成启动闭包）都是在 app 启动之前做完的。在 macOS 上，由于有 sideload app，进程内引擎会在首次启动时启动一个 daemon，之后就可以使用启动闭包了。总之大部分情景下，这些工作都在 app 启动之前完成了。</p>

<p>大部分的启动场景都不需要调用这个进程外的 mach-o 解析器。而启动闭包又比 MachO 简单很多，因为它是一个内存映射文件，解析和验证都非常简单，并且经过了良好的性能优化。所以 dyld 3.0 的引入，能让 app 的启动速度得到明显提升。</p>

<p>总体来说，dyld 3把很多耗时的操作都提前处理好了，极大提升了启动速度。</p>

<p>参考链接：</p>

<p>1.<a href="https://developer.apple.com/videos/play/wwdc2017/413/">WWDC2017 session 413</a></p>

<p>2.<a href="https://developer.apple.com/videos/play/wwdc2019/423/">WWDC2019 session 423</a></p>

<p>3.<a href="https://blog.csdn.net/Hello_Hwc/article/details/78317863">深入理解<strong>iOS App</strong>的启动过程</a></p>

<p>4.<a href="https://techblog.toutiao.com/2017/07/05/session413/"><strong>App</strong> 启动时间：过去，现在和未来</a></p>

<p>5.<a href="https://www.jianshu.com/p/96f66b0c943c"><strong>App</strong> 启动流程以及优化 <strong>WWDC 2017</strong></a></p>

<p>6.<a href="https://easeapi.com/blog/blog/83-ios13-dyld3.html">iOS 13中的改进和优化</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS APP内存优化记录]]></title>
    <link href="http://kobe1941.github.io/blog/memory.html"/>
    <updated>2019-05-20T21:42:39+08:00</updated>
    <id>http://kobe1941.github.io/blog/memory</id>
    <content type="html"><![CDATA[<p>APP在运行过程中，如果内存占用过高则会引起以下几个问题：</p>

<p>①被操作系统的守护进程给杀掉，无论是前台还是后台；</p>

<p>②耗电增大，手机发热；</p>

<p>③系统可能会运行卡顿（不是换入换出到磁盘，而是解压缩和重压缩内存）；</p>

<p>业务背景</p>

<p>因为我们APP的直播间要玩网页版的小游戏，比较耗内存，除了JS游戏本身降低内存消耗之外，native也需要释放更多的内存以提供给游戏使用，避免因为内存占用过大而被操作系统杀掉进程。</p>

<p>优化native本身的内存占用大体分为两部分：优化长期的内存占用和优化峰值内存占用。</p>

<!--more-->

<h2 id="section">理论上的技术方案</h2>

<h3 id="section-1">优化长期的内存占用</h3>

<p>1.内存泄漏问题；</p>

<p>要做内存优化，先要分析当前占用内存较大的页面或功能。尤其是直播间。</p>

<p>①开instruments来跟课，查看直播间的内存泄漏；</p>

<p>——需要高端一点的机器，比如iPad才能跑起来，低端机器跑不了instruments。</p>

<p>②集成MLeaksFinder库到开发的target，检测内存泄漏；</p>

<p>——不过这个库只能检查UIViewcontroller和其对应的UIView是否有泄漏，可以方便开发的时候发现问题。</p>

<p>③集成 <a href="https://github.com/facebook/FBMemoryProfiler">FBMemoryProfiler</a> 可视化工具，直接嵌入到 App 中，可以起到在 App 中直接查看内存使用情况，并筛选潜在泄漏OC对象的作用；</p>

<p>网上说instruments的leaks工具无法检测循环引用导致的内存泄漏，验证下是否属实；</p>

<p>——是真的，下图这种block和self形式的循环引用，instruments检测不出来</p>

<p><img src="http://kobe1941.github.io/images/2019/05/20/1.png" alt="" /></p>

<p>2.不必要的单例；是否可以改造成懒加载，用的时候才去初始化，用完可以释放掉；这个主要是去排查代码逻辑看是否合理；</p>

<p>3.RN页面的内存占用问题见<a href="[http://bbs.reactnative.cn/topic/5550/rn%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98-%E5%86%85%E5%AD%98%E6%8C%81%E7%BB%AD%E5%A2%9E%E9%95%BF-%E7%9B%B4%E5%88%B0%E8%A2%AB%E7%B3%BB%E7%BB%9F%E6%9D%80%E6%AD%BB](http://bbs.reactnative.cn/topic/5550/rn内存问题-内存持续增长-直到被系统杀死)">这里</a></p>

<p>①列表的cell是否有复用，复用是否正确；</p>

<p>②图片是否用了大图，能不能改成小图；</p>

<p>③进入直播间时回收掉所有RN页面，在退出直播间后重新初始化RN页面。——已采用，效果显著，每个RN页面大概占用20-40M的内存。</p>

<p>当然RN页面占用内存过大的问题，最彻底的解决方案还是直接用native去重写，至少一级页面用native去实现，无论是内存，滑动响应速度等等的用户体验都会好很多。只不过我们权衡之后没有这么做而已。</p>

<p>4.大图片的使用方式，包括动画所用图片的初始化方式，UIImage的imageWithContentWithFile可以避免使用缓存，用完即释放，但是需要把图片放在bundle的目录下，而不是XCAssets里；</p>

<p>——对于降低峰值内存有一定效果，但是imageNamed方式图片的缓存，在APP退到后台或者受到内存警告时，如果未被使用则会被系统自动清理。所以该方式可以采用，但是不要有太高的心理预期。</p>

<p>5.图片下采样。大一点的图片（比如做动画用的图片），改用ImageIO的api，而不是直接imageWithNamed的方式来创建，详情见<a href="https://techblog.toutiao.com/2018/06/19/untitled-42/">这里</a> 和<a href="https://blog.csdn.net/TuGeLe/article/details/81137995">这里</a>；另实际显示的尺寸小于图片实际尺寸时可以降低采样率（下采样）；</p>

<p>——下采样的方式仅针对图片尺寸比实际显示的尺寸大的情况下才会降低内存消耗。由于效果并不明显，项目中并未使用该种方式。</p>

<p>对一张1500 × 2668的图片做测试发现</p>

<p>①使用普通的ImageWithNamed方式，APP退到后台再拉回前台，内存会被清理；</p>

<p>②使用ImageWithContentWithFile的方式，每次使用后内存被释放；——直播间可以采用</p>

<p>这两种方式的内存变化见下图：</p>

<p><img src="http://kobe1941.github.io/images/2019/05/20/2.png" alt="" /></p>

<p>③使用下采样的方式，峰值内存降低了，但是丢弃图片后，整体占用的内存并未下降。暂不知该图片缓存释放的时机。</p>

<p><img src="http://kobe1941.github.io/images/2019/05/20/3.png" alt="" /></p>

<p>④使用按比例缩放UIGraphicsBeginImageContext()，效果跟下采样类似，图片缓存在APP退到后台依然没有释放</p>

<p><img src="http://kobe1941.github.io/images/2019/05/20/4.png" alt="" /></p>

<p>6.APP监听到内存警告或APP退到后台的通知时，释放一些可重建的非必要对象。</p>

<h3 id="section-2">优化峰值内存占用</h3>

<p>1.在合适的地方添加AutoreleasePool来及时释放内存，比如全局IM消息的接收和解析，视频回放的消息过滤等；</p>

<p>2.缓存的使用，比如系统的UIImage的imageWithNamed函数创建的对象，以及YYMemoryCache和SDImageCache来共享缓存，多个业务使用同一份内存缓存。</p>

<p>3.缓存释放时机，YYMemoryCache和SDImageCache以及系统的UIImage的imageWithNamed创建的图片对象，都会在APP退到后台时，或者收到内存警告时清理全部的内存缓存。</p>

<p>4.网络图片单张图片size过大监控，以及网络图片总内存大小限制；</p>

<p>5.<a href="https://github.com/Tencent/OOMDetector/issues">OOM捕捉</a></p>

<p>——最大的用处是用来分析短期内存增长过快的原因，同时可以获取C和C++的内存分配。需要权衡下是否引入。</p>

<p>OOM暂未支持bugly集成，获取的堆栈日志暂时没地方存放。且因为都用了fishhook，会跟 <a href="https://github.com/facebook/FBRetainCycleDetector">FBRetainCycleDetector</a> 冲突，暂不引入。</p>

<p>6.了解mmap，测试其在图片映射的内存降低数据；</p>

<p>SDWebImage使用NSData的dataWithContentOfFile的方式来读取图片到内存；</p>

<p>mmap主要是可以省略从内核空间拷贝到用户空间的这一步操作，其他省不掉。FastImage额外省略了图片解码，但是却是通过把解码后的图片写磁盘来实现的（解码后图片增大，读取的IO耗时也会增大）。另FastImage可以使图片字节对齐，避免CoreAnimation在渲染时做一次额外的拷贝操作。</p>

<p>7.vmmap分析Xcode抓到的memgraph内存信息，看看有什么收获；</p>

<p>——没必要，原理跟<a href="https://github.com/facebook/FBMemoryProfiler">FBMemoryProfiler</a>类似，还不如直接用<a href="https://github.com/facebook/FBMemoryProfiler">FBMemoryProfiler</a>。</p>

<p>ps：Facebook三件套 <a href="https://github.com/facebook/FBRetainCycleDetector">FBRetainCycleDetector</a>，<a href="https://github.com/facebook/FBAllocationTracker">FBAllocationTracker</a>和<a href="https://github.com/facebook/FBMemoryProfiler">FBMemoryProfiler</a>。</p>

<p>命令行有不少工具可以用来配合分析内存，比如vmmap，leaks和heap，见<a href="https://juejin.im/post/5b23dafee51d4558e03cbf4f">这里</a>。</p>

<h2 id="section-3">在我们项目中的实际应用</h2>

<h3 id="section-4">内存泄漏</h3>

<p>1.Instruments 的部分捕获结果</p>

<p>①AFNetworking的session</p>

<p><img src="http://kobe1941.github.io/images/2019/05/20/5.png" alt="" /></p>

<p>②JSBridge的内存泄漏</p>

<p><img src="http://kobe1941.github.io/images/2019/05/20/6.png" alt="" /></p>

<p><img src="http://kobe1941.github.io/images/2019/05/20/7.png" alt="" /></p>

<p>③第三方库的泄漏</p>

<p><img src="http://kobe1941.github.io/images/2019/05/20/8.png" alt="" /></p>

<p>原因见下图，是第三方的库里边，create出来的CF对象没有release掉：</p>

<p><img src="http://kobe1941.github.io/images/2019/05/20/9.png" alt="" /></p>

<p>2.MLeaksFinder发现的部分内存问题</p>

<p>①巡堂和动画的view内存泄漏，block互相持有导致，已fixed。</p>

<p><img src="http://kobe1941.github.io/images/2019/05/20/10.png" alt="" /></p>

<p><img src="http://kobe1941.github.io/images/2019/05/20/11.png" alt="" /></p>

<p>②IAP的Header内存泄漏，动画的delegate强引用导致，在开始做动画的时候设置delegate，在动画结束后的回调里把delegate置空可以解决这个问题。</p>

<p><img src="http://kobe1941.github.io/images/2019/05/20/12.png" alt="" /></p>

<p><img src="http://kobe1941.github.io/images/2019/05/20/13.png" alt="" /></p>

<h3 id="section-5">内存峰值优化</h3>

<p>1.视频回放的业务，拖动进度条会有大量的string被分配内存，占据了快100M</p>

<p><img src="http://kobe1941.github.io/images/2019/05/20/14.png" alt="" /></p>

<p>解决方案：在拖曳进度条时会过滤消息，在过滤消息的函数里加自动释放池，及时释放局部变量的内存。</p>

<p>2.另一块是由于IM群组的设计，很多用户不需要知道的别的小班的消息也会一起发过来，数据量会很大，在子线程进行高度计算时会产生大量的临时变量，此处也加一个自动释放池用来降低内存峰值。同时之前在<a href="[http://www.zoomfeng.com/blog/crash-anr.html](http://www.zoomfeng.com/blog/crash-anr.html)">另一篇文章</a>里曾经针对消息数据的过滤做过优化</p>

<p><img src="http://kobe1941.github.io/images/2019/05/20/15.png" alt="" /></p>

<p><img src="http://kobe1941.github.io/images/2019/05/20/16.png" alt="" /></p>

<p>之后的instruments内存监控如下：</p>

<p><img src="http://kobe1941.github.io/images/2019/05/20/17.png" alt="" /></p>

<p>第一张图里红圈的string内存占用已经不再出现。</p>

<p>3.SSZPicMemoryTool优化网络图片的内存占用问题（通过SD下载的，包括native和RN），</p>

<p>——主要是通过SSZPicMemoryTool接管了native通过SDWebImage使用的网络图片，以及RN页面使用的网络图片。所以可以及时在使用时监控到内存超过阈值的单张图片。只需要不同的业务页面走查一遍即可发现。除了单张图片的最大size超出监控之外，还直接把YYCache里的LRU淘汰算法拿来用，用于避免网络图片占用的峰值内存过大。</p>

<p><img src="http://kobe1941.github.io/images/2019/05/20/18.png" alt="" /></p>

<p>原理见下图，SSZPicMemoryTool接管了图片内存缓存的管理，包括读取，写入和淘汰。</p>

<p><img src="http://kobe1941.github.io/images/2019/05/20/19.png" alt="" /></p>

<h3 id="section-6">业务逻辑优化和时间空间置换策略</h3>

<p>直播间玩H5的小游戏会比较吃内存，所以可以采用一些策略，在用户玩游戏的时候，先释放掉一些内存出来供游戏使用。我们采用的两个方案，一个是用户玩游戏时，把直播的视频画面给移除掉，仅播放音频，因为此时本身视频画面也是被游戏画面挡住的，所以没有太大必要。另一个就是由于RN页面消耗的内存比较大，采用进入直播间就释放掉外围的RN页面，等退出直播间再恢复。</p>

<p>H5游戏本身也做了一轮内存的优化，优化前后降低了一半左右的内存消耗，效果还是很明显的。</p>

<p>1.游戏时关闭视频，以及进入直播间后回收RN的内存优化效果</p>

<p>测试环境：iPhone8P + 无其他课堂互动(消息等) + 进入直播后稳定后采集数据，直接跳转到直播间，不经过试讲和课程页</p>

<p><img src="http://kobe1941.github.io/images/2019/05/20/20.png" alt="" /></p>

<p>游戏中剔除视频可以优化部分内存：剔除视频渲染后直播间整体内存可以降低25~30M（占进入直播间后增加的 40~50%），接收解码等操作因为SDK没有屏蔽接口，可能需要obs端做改造，但剩余可优化空间不足了，预计最多可优化10~20M。</p>

<p>直播间外部的内存有优化空间：剔除RN后，进入首屏和进入直播间的内存降低了约 50M，RN占用的内存比较大，首屏39M也有待细化，这两部分可以跟进优化。</p>

<p>——进入APP后会占用约40M的内存，经过测试，这部分无法继续降低了，一个空的工程也需要消耗掉这么多的内存。</p>

<p>回收RN页面</p>

<p><img src="http://kobe1941.github.io/images/2019/05/20/21.png" alt="" /></p>

<p>重新加载RN页面</p>

<p><img src="http://kobe1941.github.io/images/2019/05/20/22.png" alt="" /></p>

<p>2.直播间游戏自身的内存占用优化（主要是JS做的）</p>

<p>WKWebView 是运行在另一个进程里，Network Loading 以及 UI Rendering 在其它进程中执行。在 WKWebView 的进程里当总体的内存占用比较大的时候，WebContent Process 会 crash，从而出现白屏现象。</p>

<p>WebContent Process 因为整机内存过大被系统kill掉的时候不可控，所以一般会在crash白屏的回调加reload的逻辑，故而出现游戏不断reload问题。</p>

<p>Webview的CPU和内存优化交给前端自己做，只需要关注native本身的优化即可。WebKit进程的内存消耗可以用Instruments的Activity Monitor组件看到。</p>

<p><img src="http://kobe1941.github.io/images/2019/05/20/23.png" alt="" /></p>

<p>Instrument Activity Monitor + Allocations ，忽略IM和互动其他情况，只在音视频+测评、游戏的情况分析：</p>

<p><img src="http://kobe1941.github.io/images/2019/05/20/24.png" alt="" /></p>

<h2 id="section-7">关于内存统计</h2>

<p>APP使用内存统计可以直接如下的函数，参考来自<a href="https://github.com/aozhimin/iOS-Monitor-Platform#memory">这里</a></p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class=""><span class="line">+ (NSInteger)getResidentMemory
</span><span class="line">{
</span><span class="line">    task_vm_info_data_t vmInfo;
</span><span class="line">    mach_msg_type_number_t count = TASK_VM_INFO_COUNT;
</span><span class="line">    kern_return_t result = task_info(mach_task_self(), TASK_VM_INFO, (task_info_t) &amp;vmInfo, &amp;count);
</span><span class="line">    if (result == KERN_SUCCESS) {
</span><span class="line">        return (NSInteger)vmInfo.phys_footprint; ///&lt; 应用使用的物理内存大小
</span><span class="line">    } else {
</span><span class="line">        return -1;
</span><span class="line">    }
</span><span class="line">}</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="shared-memory">shared memory</h3>

<p>共享内存可以提供跨进程访问的能力，不过如果你的App使用了别的进程创建的共享内存，那么Debug Navigator是不会将它计入你自己的内存总量的，不过vmmap会将它加入TOTAL中，所以可能会导致vmmap计算的内存量会大于Debug Navigator统计内存量。</p>

<p>Debug Navigator其实就是统计了当前进程的所有虚拟内存的Dirty Size + Swapped Size，当然还要剔除掉对第三方共享内存的使用量，当我们发现Debug Navigator的内存量飙高时，不仅仅要去关注Heap上的内存用量，更要关注VM Tracker中那些大Dirty Size的VM Region，这样才能更透彻的了解你的App究竟是怎样使用内存的。</p>

<h3 id="section-8">其他</h3>

<p><img src="http://kobe1941.github.io/images/2019/05/20/25.png" alt="" /></p>

<h2 id="section-9">内存泄漏工具的使用</h2>

<h3 id="section-10">1.介绍</h3>

<p>在iOS的Dev的包里会集成腾讯的MLeaksFinder库和Facebook的FBMemoryProfiler三件套的库，作用都是用来检测内存泄漏的。</p>

<p>不同点在于，MLeaksFinder只用于检查页面和页面相关的view的内存泄漏，当发现有内存泄漏时，会用一个弹窗来做出提示。比如最常见的，你退出一个页面，2秒后如果该页面的内存还未释放，则会提示内存泄漏。</p>

<p>FBMemoryProfiler则可以检测所有类型的内存泄漏，原理是hook了系统的alloc和dealloc函数，跟instruments的功能类似，只不过更加轻量化，可以在APP运行时实时看到内存分配的情况，如果有对象内存泄漏，则会标红表示。</p>

<h3 id="mleaksfinder">2.MLeaksFinder使用指南</h3>

<p>很简单，在退出一个页面后，如果有弹出下图的弹窗，则说明该页面有内存泄漏，并且列出了具体的内存泄漏的对象。</p>

<p><img src="http://kobe1941.github.io/images/2019/05/20/26.png" alt="" /></p>

<p>备注：这个列表是一个内存泄漏的链表指针，不一定每个对象都会泄漏，但至少有一个是发生了内存泄漏的，通常可能是最后一个，也可能是多个，比如上图其实XunTangTipView和LOTAnimationView都有内存泄漏。</p>

<p>另外就是默认的判断时间是2秒，实际测试发现有时候会有误伤，所以可以把时间间隔调大到3秒或者更大一些。</p>

<h3 id="fbmemoryprofiler">3.FBMemoryProfiler使用指南</h3>

<p>在Dev的pod里集成该库后，Dev的包，顶部会有一个小浮窗显示当前的总内存，点击后可以展开大图查看更多信息，如下图所示。</p>

<p><img src="http://kobe1941.github.io/images/2019/05/20/27.png" alt="" /></p>

<p>当你认为某个时刻，可能有内存泄漏，或者想看看是否有内存泄漏时，可以点击下图的Mark Gen按钮，此时会生成一个当前内存状态相比前一个generation时的快照，点击Expand按钮，会展开一个列表，把所有的对象都列出来，红色的一栏则表示该对象有内存泄漏。</p>

<p><img src="http://kobe1941.github.io/images/2019/05/20/28.png" alt="" /></p>

<p>左上方有一个输入款，可以用来进行过滤。</p>

<p>点击红色的那一栏，就能看到具体的内存泄漏的原因，如下图，nats库的实例跟timer互相强引用导致。</p>

<p><img src="http://kobe1941.github.io/images/2019/05/20/29.png" alt="" /></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS知识结构]]></title>
    <link href="http://kobe1941.github.io/blog/ios-level-up.html"/>
    <updated>2019-05-12T18:06:44+08:00</updated>
    <id>http://kobe1941.github.io/blog/ios-level-up</id>
    <content type="html"><![CDATA[<p>计算机三大知识结构：数据结构和算法，网络，操作系统。</p>

<p>这里陈硕在知乎上有个补充：<a href="https://www.zhihu.com/question/21405835">https://www.zhihu.com/question/21405835</a>，主要是谈到了计算机体系结构，这一块涉及到各个层面知识的串联和整合。</p>

<p>本文不会讲的很详细，只是简单罗列一些知识点及其应用场景，具体怎么做不会展开。</p>

<p>主要分几块的内容：iOS开发相关，计算机知识结构，软实力和职业规划。</p>

<!--more-->

<h1 id="ios">一、iOS相关</h1>

<h3 id="ios-1">1.iOS基础知识</h3>

<p>OC语法，类别（系统类与自定义类的函数覆盖），协议与多重继承的关系，继承是用什么数据结构实现的（C++和OC）</p>

<p>引用计数与内存管理，ARC下什么情况需要自己管理内存</p>

<p>atomic的含义与内部实现，block是否必须用copy修饰？</p>

<p>数据库基础操作（sqlite）</p>

<p>NSThread/NSOperation/GCD使用</p>

<p>事件响应链与事件派发传递流程</p>

<p>H5与OC的交互</p>

<h3 id="ios-2">2.iOS进阶知识</h3>

<p>UI方面：CALayer与CoreAnimation做动画，CoreGraphic绘图，TextKit/CoreText图文混排。</p>

<p>正则表达式</p>

<p>图层混合，离屏渲染的原因及解决方案</p>

<p>UITableView卡顿及其解决方法</p>

<p>OC对象模型，isa与super指向图（可以增加函数和isa混写的基础）</p>

<p>KVC/KVO实现原理，ARC（<a href="http://blog.sunnyxx.com/2015/01/17/self-in-arc/">http://blog.sunnyxx.com/2015/01/17/self-in-arc/</a>），weak的实现原理，关联对象的原理，自动释放池的实现原理，（可变）数组和字典的实现原理</p>

<p>method swizzle和 isa swizzle</p>

<p>Block的实现原理与破解参数（方法签名），循环引用与解决方案</p>

<p>runtime的应用</p>

<p><a href="https://blog.ibireme.com/2015/05/18/runloop/">runloop的原理与应用</a>（对应安卓的looper以及前端的event loop），与线程的关系，子线程如何保活与销毁</p>

<p>GCD原理（线程池实现原理） ——类似UITableViewCell的缓存池</p>

<p>消息转发的流程，如何避免不能识别的方法崩溃</p>

<p>内存泄漏的常见场景及其解决方法，如何查找内存泄漏</p>

<p>Xcode如何调试EXC_BAD_ACCESS，常用LLDB调试命令有哪些</p>

<p>如何保证线程安全，比如数据库/文件/变量</p>

<p>NSProxy，NSHashTable与NSMapTable的应用场景</p>

<h3 id="section">3.高阶</h3>

<p>从HTTP请求到UIView渲染的流程和原理</p>

<p>JavascriptCore的原理</p>

<p>runtime的原理</p>

<p>崩溃库的原理，PLCrashreporter/KSCrash</p>

<p>卡顿监控和抓堆栈的原理</p>

<p>崩溃日志解析流程</p>

<p>APP与extension是如何共享数据的，Macport底层是用哪一种进程间通信方式来实现的</p>

<h3 id="section-1">4.开源库</h3>

<p>AFNetworking</p>

<p>SDWebImage/FastImageCache</p>

<p>YYCache</p>

<p>MJExtension/YYModel</p>

<p>ASDK</p>

<h3 id="section-2">5.技术专项</h3>

<p>安装包size</p>

<p>启动时间</p>

<p>流畅性/帧率</p>

<p>稳定性与主线程卡顿</p>

<p>内存消耗与内存泄漏</p>

<p>CPU使用率</p>

<p>网络优化（含弱网）</p>

<p>长连接心跳策略（参考微信）</p>

<h3 id="section-3">6.质量相关</h3>

<p>代码规范</p>

<p>持续集成</p>

<p>自动化测试</p>

<h3 id="section-4">7.其他</h3>

<p>直播几种协议的优缺点，如何性能调优，</p>

<p>直播是如何拿到第一帧开始显示的，直播的四大性能指标（直播的四大指标：画质、卡顿率、延时、秒开。画质和卡顿率要看传说的码率，码率高画质高，卡顿率也可能增大。延时跟直播协议直接相关。秒开则主要是减少GOP，即减少 I 帧在视频流的间隔。）</p>

<p>逆向</p>

<p>下拉刷新原理</p>

<p>数据安全（沙盒，HTTPS/二次加密，单次登录token）</p>

<p>代码安全（混淆加固）</p>

<p>音视频处理等特定领域，OpenGL，FFmpeg</p>

<p>iOS相关的推荐书籍</p>

<p><a href="https://book.douban.com/subject/24284008/">Objective-C 基础教程</a></p>

<p><a href="https://book.douban.com/subject/24720270/">Objective-C 高级编程</a></p>

<p><a href="https://book.douban.com/subject/25829244/">Effective Objective-C 2.0</a></p>

<p><a href="https://book.douban.com/subject/25976913/">iOS编程实战</a></p>

<p>逆向的书主要就以下两本，建议先看第一本再看第二本</p>

<p><a href="https://book.douban.com/subject/26363333/">iOS应用逆向工程 第2版</a></p>

<p><a href="https://book.douban.com/subject/30239776/">iOS应用逆向与安全</a></p>

<h1 id="section-5">二、计算机基础知识</h1>

<h3 id="section-6">1.网络知识</h3>

<p>HTTP/HTTPS（握手流程）</p>

<p>DNS（劫持）</p>

<p>TCP三次握手四次挥手/慢启动/滑动窗口/流量控制/拥塞控制/快速重传/延迟应答/捎带应答，Dos攻击与防护</p>

<p>第三次握手或第四次挥手如果丢包会如何处理？</p>

<p>UDP及其应用</p>

<p>IP（IPV4与IPV6）与数据链路</p>

<p>cookie与session的区别和联系</p>

<p>公钥加密算法，证书信任链和数字签名</p>

<p>HTTP短连接和长连接的区别和联系</p>

<p>从浏览器输入一个字符串后发生了什么？</p>

<p>网络相关推荐书籍</p>

<p><a href="https://book.douban.com/subject/25863515/">图解HTTP</a></p>

<p><a href="https://book.douban.com/subject/24737674/">图解TCP/IP</a></p>

<p><a href="https://book.douban.com/subject/10746113/">HTTP权威指南</a></p>

<p><a href="https://book.douban.com/subject/26960678/">计算机网络 [谢希仁] </a></p>

<h3 id="section-7">2.数据结构和算法</h3>

<p>数组，链表，哈希表的实现原理</p>

<p>串和KMP</p>

<p>二叉树，二叉排序树，AVL二叉平衡树，红黑树，B数和B+树</p>

<p>队列，栈和堆及其应用</p>

<p>图的最小连接路径（最小生成图），广度遍历与深度遍历</p>

<p>排序和查找算法，不同排序算法的适用场景，如何选择</p>

<p>递归与分治，动态规划和贪心算法</p>

<p><a href="https://book.douban.com/subject/6424904/">大话数据结构</a></p>

<p><a href="https://book.douban.com/subject/27008702/">剑指offer</a></p>

<p>如果是准备面试的话去LeetCode刷题目吧</p>

<h3 id="section-8">3.操作系统</h3>

<p>进程和线程，进程间通信和线程间通信的方式</p>

<p>进程的内存分布区域：代码区，常量区，数据区（已初始化和未初始化），堆和栈</p>

<p>不同锁的区别，什么情况下会死锁，怎么解决</p>

<p>存储管理与置换/淘汰算法</p>

<p>文件系统、数据库索引和B树B+树的关联</p>

<p>多处理机，多计算机和分布式系统的概念</p>

<p>用户态和内核态，用户线程和内核线程的关系/如何切换/映射关系</p>

<p>BSD层和Mach层</p>

<p><a href="https://book.douban.com/subject/3852290/">现代操作系统</a></p>

<p><a href="https://book.douban.com/subject/25870206/">深入解析Mac OS X 与 iOS操作系统</a></p>

<p><a href="https://book.douban.com/subject/5333562/">深入理解计算机系统</a></p>

<h3 id="section-9">4.设计模式和面向对象设计原则</h3>

<p>MVC，MVVM，单例，代理，观察者，中介者，组合模式</p>

<p>工厂模式/简单工厂</p>

<p>单一原则，依赖倒置原则，接口隔离原则，迪米特原则（最小知识原则），</p>

<p>无环依赖原则，开闭原则，里氏替换原则</p>

<p>时序图，流程图，UML类图，框架图</p>

<p><a href="https://book.douban.com/subject/2334288/">大话设计模式</a></p>

<h1 id="section-10">三、软实力</h1>

<p>沟通与表达</p>

<p>总结复盘与提炼/升华</p>

<p>支撑业务与个人成长/团队成长</p>

<p>个人与团队影响力（技术总结，SDK，培训等给其他团队带来价值）</p>

<h1 id="section-11">四、职业规划</h1>

<p>技术专家 or 技术管理</p>

<p>全栈 or 架构师</p>

<p>目前看到的国内的现象是，技术管理并不见得核心竞争力有多强，而且换公司之后的可复用性和可落地性，比走技术深度路线似乎更难。</p>

<p>另外全栈工程师的确很厉害，无论在创业公司还是大厂都很喜欢，但是全栈一定要有自己特别擅长的领域，就是说还是T型人才的路子，如果一个领域的技术都不深入，成为每个都会一点每个都不精的万金油，也很尴尬。</p>

<p>架构师的价值主要体现在服务器端，客户端来说，除非产品的DAU在百万以上，否则架构设计真正在推动项目往前走所体现的价值，并没有多大，也就是说，如果业务做不起来，架构设计的再精妙再先进，都没办法创造价值。而往往架构师又是脱离一线业务的，所以你会发现基本架构师都是在大厂的基础架构组做支撑，或者在某个明星项目里成为核心主力，但是在一般的创业公司，或者中小型的公司，则不见得都设有该岗位。。</p>

<p>整体上，技术方向也有风口这一说法，比如大数据在2013年那会儿就很火，千人千面的推荐算法很受欢迎，大厂招人给的溢价也高。现在则是人工智能的子分支，比如计算机视觉里的人脸识别，声音识别，或者自动驾驶等比较火爆。基本上要获得溢价，都是要在某个技术受欢迎，大厂愿意投资，而市场上人才比较紧缺的时候才行。一旦人才供需平衡了，或者技术的风口过了，溢价也容易往下掉。对于普通人来说，如果能抓住某次溢价，把身价往上走一个两个台阶，那还是很爽的，不过现在技术发展越来越成熟，往后的技术风口上的技术，门槛越来越高，像人工智能/自动驾驶这种，已经不是普通本科生能够靠自学学会的了，也不是普通智商的人能玩的转的。平常心吧~</p>

<p>网上看到的一个大神</p>

<p><img src="http://kobe1941.github.io/images/2019/05/12/20.png" alt="" /></p>

<p>从图中的描述里，可以看出大神的过人之处，可以以此为榜样去学习和进步~</p>

<h3 id="section-12">写在最后</h3>

<p>技术能力的提升不是一个线性增长的过程，当你各方面的基础知识基本过关了之后，如果之后不知道如何深入可以尝试去做一些技术专项，最好是跟自己公司的项目有关联的技术专项，既能提升自己在某一块的技术水平，也能对公司有帮助，这是一个互惠互利的过程。</p>

<p>抛开音/视频，AR/VR这种特定领域的技术来说，在通用的技术栈上，如果不知道怎么继续深入了，那就去学习操作系统吧，深挖操作系统的原理和实现，会有很大的好处。目前本菜鸡也在往这个方向深入学习，希望跟大家共勉~</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[崩溃和卡顿]]></title>
    <link href="http://kobe1941.github.io/blog/crash-anr.html"/>
    <updated>2019-05-12T13:20:17+08:00</updated>
    <id>http://kobe1941.github.io/blog/crash-anr</id>
    <content type="html"><![CDATA[<p>本文尝试分析和总结一下崩溃和主线程卡顿(ANR)的原理，以及对应的部分解决方案和案例。</p>

<!--more-->

<h1 id="section">一、崩溃</h1>

<p>业界的崩溃率标准：</p>

<p><img src="http://kobe1941.github.io/images/2019/05/12/1.png" alt="" /></p>

<p><img src="http://kobe1941.github.io/images/2019/05/12/2.png" alt="" /></p>

<h3 id="section-1">1.崩溃的信号类型</h3>

<p>崩溃主要是由于 Mach 异常、Objective-C 异常（NSException）引起的，同时对于 Mach 异常，到了 BSD 层会转换为对应的 Signal 信号，那么我们也可以通过捕获信号，来捕获 Crash 事件。针对 NSException 可以通过注册 NSUncaughtExceptionHandler 捕获异常信息。</p>

<p>OC层的异常通常可以通过崩溃日志去case by case解决，异常信息会很充分，对号入座即可。</p>

<p>EXC_BAD_ACCESS  对应的子类型有SIGSEGV，SIGBUS，SIGILL。</p>

<p>完整的描述通常为 Exception Type: EXC_BAD_ACCESS (SIGSEGV)</p>

<p>SIGSEGV：一般是非法内存访问错误，比如访问了已经释放的野指针，或者C数组越界。是EXC_BAD_ACCESS的子集；</p>

<p>程序无效内存中止信号，比如访问已经释放的内存，或者访问没有权限访问的内存，写入只读的内存等。</p>

<p>SEGV:（Segmentation  Violation），代表无效内存地址，比如空指针，未初始化指针，栈溢出等；</p>

<p>SIGABRT：重复释放同一块内存两次会导致，或者手动调用abort()函数；或者iOS内存jetsam的SIGABRT，对应的kill信号。或某些情况下的C数组越界导致的SIGABRT</p>

<p>SIGBUS：非法地址，意味着指针所对应的地址是有效地址，但总线不能正常使用该指针。通常是未对齐的数据访问所致。是EXC_BAD_ACCESS的子集；</p>

<p>SIGILL：非法指令。SIG是信号名的通用前缀。ILL是 illegal instruction（非法指令） 的缩写。SIGILL 是当一个进程尝试执行一个非法指令时发送给它的信号。可执行程序含有非法指令的原因，一般也就是cpu架构不对，编译时指定的march和实际执行的机器的march不同。这种情况，因为工具链一样，连接脚 本一样，所以可执行程序可以执行，不会发生exec format error。但是会包含一些不兼容的指令。还有另外一种可能，就是程序的执行权限不够，比如在用户态下运行的程序只能执行非特权指令，一旦CPU遇到特权指 令，将产生illegal instruction错误。</p>

<p>有时候也会因为打印数据的时候参数类型不匹配导致SIGILL，见这个例子 <a href="https://blog.csdn.net/Cow_cz/article/details/72930343">https://blog.csdn.net/Cow_cz/article/details/72930343</a></p>

<p>非法指令[EXC_BAD_INSTRUCTION // SIGILL] 该进程试图执行非法或未定义的指令。该进程可能试图通过配置错误的函数指针跳转到无效地址。</p>

<p>在Intel处理器上，ud2操作码会导致EXC_BAD_INSTRUCTION异常，但通常用于捕获进程以进行调试。如果在运行时遇到意外情况，则Intel处理器上的Swift代码将以此异常类型终止。有关详细信息，请参阅<a href="https://juejin.im/post/5bdd78bc6fb9a049d2357ca2">https://juejin.im/post/5bdd78bc6fb9a049d2357ca2</a></p>

<p>SIGTRAP：跟踪陷阱EXC_BREAKPOINT / SIGTRAP</p>

<p>SIGTRAP 由断点指令或其它trap指令产生，由debugger使用。swift的空指针或类型转换失败也会导致此信号。</p>

<p>与异常退出类似，此异常旨在为附加的调试器提供在其执行的特定点中断进程的机会。您可以使用该__builtin_trap()函数从您自己的代码中触发此异常。如果未附加调试器，则终止该过程并生成崩溃报告。</p>

<p>较低级别的库（例如libdispatch）会在遇到致命错误时捕获进程。有关错误的其他信息可以在崩溃报告的“ 其他诊断信息”部分或设备的控制台中找到。</p>

<p>如果在运行时遇到意外情况，则Swift代码将以此异常类型终止，例如：</p>

<p>①具有nil值的非可选类型</p>

<p>②强制类型转换失败</p>

<p>SIGINT 程序终止(interrupt)信号, 在用户键入INTR字符(通常是Ctrl-C)时发出，用于通知前台进程组终止进程。</p>

<p>SIGPIPE 管道破裂。这个信号通常在进程间通信产生，比如采用FIFO(管道)通信的两个进程，读管道没打开或者意外终止就往管道写，写进程会收到SIGPIPE信号。此外用Socket通信的两个进程，写进程在写Socket的时候，读进程已经终止。</p>

<h3 id="bsdmach">2.BSD层和Mach层的含义</h3>

<p><img src="http://kobe1941.github.io/images/2019/05/12/3.png" alt="" /></p>

<h3 id="section-2">3.如何拦截崩溃</h3>

<p>OC的异常可以针对性做处理，比如不能识别的方法，你可以动态去添加。数组越界或者字典空值则可以method swizzle拦截掉。</p>

<p>其他异常信号的拦截则参考<a href="http://www.zoomfeng.com/blog/plcrashreporter-1.html">PLC的实现</a>，从BSD层和Mach层都可以处理，不过保险起见，一般从Mach层捕获异常信号。</p>

<h3 id="section-3">4.如何分析和解决崩溃</h3>

<p>①SIGSEGV野指针，RN的例子；</p>

<p>②SIGTRAP，swift的nats库的例子。</p>

<p>③通用类型的崩溃，比如OC容器的越界和空值导致的，以及unrecognized selector sent to instance这种，可以通过<a href="https://github.com/kobe1941/FFExtension">FFExtension</a>直接拦截掉。</p>

<p>例子见下方。</p>

<p>野指针大全</p>

<p><img src="http://kobe1941.github.io/images/2019/05/12/4.png" alt="" /></p>

<p>这里是调试一个Bad Memory Access的一些小技巧:</p>

<p>如果objc_msgSend或者objc_release在回溯(Backtraces)的顶部附近，这个进程可能是尝试给一个释放的对象发送消息。你应该用Zombies instrument(调试僵尸对象的工具)来更好的理解这个崩溃。</p>

<p>事实上Xcode的这几个工具还是挺有用处的：</p>

<p><img src="http://kobe1941.github.io/images/2019/05/12/5.png" alt="" /></p>

<p>关于野指针的类型崩溃在objc_msgSend函数时的拓展阅读见<a href="&lt;https://blog.csdn.net/u010960265/article/details/82454436&gt;">这里</a> 。这篇文章分析了该函数的汇编实现，以及崩溃在不同汇编指令时的情况分析。</p>

<h1 id="section-4">二、卡顿</h1>

<h3 id="section-5">1.监控卡顿的原理</h3>

<p>解主线程的卡顿，首先要能够看懂卡顿的堆栈回溯，这里需要了解一下runtime里的消息发送的流程，runloop的流程，以及自动释放池的一些函数调用。</p>

<p>另外就是要理解bugly是如何监控卡顿的，这样子才能知道如何去修复卡顿的问题：</p>

<p><img src="http://kobe1941.github.io/images/2019/05/12/6.png" alt="" /></p>

<p>这就是很多SDK会采用的主线程卡顿监控的原理了，只是在execssiveHandler去抓堆栈的具体实现上，可能会有一些不同。PLC则是通过暂停先主线程，然后读取寄存器状态，之后再恢复的方法来实现抓取线程堆栈信息的。不过据说这种策略耗时比较大？有知道其他更好更快策略的小伙伴麻烦告知一下~</p>

<h3 id="section-6">2.避免主线程卡顿的通用策略</h3>

<p>①不要在主线程做耗时操作，比如解析数据，高度计算，解压缩文件和IO操作；</p>

<p>②耗时的计算结果，应该缓存起来，比如cell的高度；</p>

<p>③尽量少的用同步操作，一定避免死锁；</p>

<p>④能在子线程做的事情，就不要在主线程去做，比如统计打点；</p>

<p>⑤大对象的销毁，可以在子线程去做，参考YYCache；</p>

<p>⑥代码逻辑是否合理，比如我们项目中视频回放处的数据过滤，过滤的大班而不是小班数据；</p>

<p>⑦对于TableView这样的列表，为了提高滑动时的帧率，其cell的层级和数量，应该尽可能的少，离屏渲染一定要控制住，另外就是手动计算frame要比autolayout的性能好的多。</p>

<p>不同布局方式的性能差异见这里 <a href="https://lpd-ios.github.io/2017/04/05/FlexBox-Weex/">https://lpd-ios.github.io/2017/04/05/FlexBox-Weex/</a> 和 <a href="https://draveness.me/layout-performance">https://draveness.me/layout-performance</a> 。</p>

<h1 id="section-7">三、技术优化的一般流程</h1>

<p>通常针对一个技术点做优化的时候，都要先了解清楚这个技术点有哪些流程，优化的方向往往是减少流程的数量，以及减少每个流程的消耗。</p>

<p>比如安装包size的减少，启动时间的降低，滑动帧率的提升，弱网下连接的优化（到达率），耗电量的降低。</p>

<p>例外的是稳定性和主线程卡顿，这两块是从异常日志反推的。</p>

<p>帧率因为Xcode提供的工具比较强大，可以监控整个渲染流程的消耗，所以一般都先用instruments去找问题，然后再去逐个解决。</p>

<h1 id="anr">四、崩溃和ANR的案例及其解决</h1>

<p>1.LDNetPing多线程访问property导致野指针，使用串行队列来解决，异步同步皆可；</p>

<p><img src="http://kobe1941.github.io/images/2019/05/12/7.png" alt="" /></p>

<p>实际上线程安全除了串行队列之外，并行队列配合barrier也可以实现。当然通用的方案是加锁，比如互斥锁，读写锁等等。</p>

<p>2.SSZAppConfig的getServerConfig函数：</p>

<p>使用AFURLSessionManager要注意，manager和它内部的session循环引用了，原因是NSURLSession的sessionWithConfiguration:delegate:delegateQueue:函数，会对delegate做强引用，除非手动解除，否则就内存泄漏</p>

<p><img src="http://kobe1941.github.io/images/2019/05/12/8.png" alt="" /></p>

<p>但是需要注意的一点是，sessionDidBecomeInvalidBlock的回调是在子线程，如果用户反复的切换前后台会导致getServerConfig这个函数被反复调用，同时session失效的概率也会增加，</p>

<p>某些情况下，会导致session失效后，manager来不及设置为nil，从而使用了失效的session去发起网络请求，导致崩溃。后来又修改为如下：</p>

<p><img src="http://kobe1941.github.io/images/2019/05/12/9.png" alt="" /></p>

<p>不过遗憾的是，因为业务的原因，我们的用户会频繁切换前后台，所以线上还是会不可避免的有崩溃，故并没有去刻意避开内存泄漏的问题，反而是让其成为一个单例，不做释放的操作。即把block里session的finishTaskAndInvalidate函数调用给注释掉了。</p>

<p>3.RN野指针崩溃</p>

<p>以RCTImageLoader的canHandleRequest:函数为例，videoRegex这个值的创建并不是多线程安全的，多线程野指针的问题基本都可以通过加锁来解决</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
<span class="line-number">50</span>
<span class="line-number">51</span>
<span class="line-number">52</span>
<span class="line-number">53</span>
<span class="line-number">54</span>
<span class="line-number">55</span>
<span class="line-number">56</span>
<span class="line-number">57</span>
<span class="line-number">58</span>
<span class="line-number">59</span>
<span class="line-number">60</span>
<span class="line-number">61</span>
</pre></td><td class="code"><pre><code class=""><span class="line">- (BOOL)canHandleRequest:(NSURLRequest *)request
</span><span class="line">
</span><span class="line">{
</span><span class="line">
</span><span class="line">    NSURL *requestURL = request.URL;
</span><span class="line">
</span><span class="line">    static NSRegularExpression *videoRegex = nil;
</span><span class="line">
</span><span class="line">    if (!videoRegex) {
</span><span class="line">
</span><span class="line">      NSError *error = nil;
</span><span class="line">
</span><span class="line">      videoRegex = [NSRegularExpression regularExpressionWithPattern:@"(?:&amp;|^)ext=MOV(?:&amp;|$)"
</span><span class="line">
</span><span class="line"> 
</span><span class="line">
</span><span class="line">                                                             options:NSRegularExpressionCaseInsensitive
</span><span class="line">
</span><span class="line"> 
</span><span class="line">
</span><span class="line">                                                               error:&amp;error];
</span><span class="line">
</span><span class="line">      if (error) {
</span><span class="line">
</span><span class="line">        RCTLogError(@"%@", error);
</span><span class="line">
</span><span class="line">      }
</span><span class="line">
</span><span class="line">    }
</span><span class="line">
</span><span class="line"> 
</span><span class="line">
</span><span class="line">    NSString *query = requestURL.query;
</span><span class="line">
</span><span class="line">    if (query != nil &amp;&amp; [videoRegex firstMatchInString:query
</span><span class="line">
</span><span class="line">                                               options:0
</span><span class="line">
</span><span class="line">                                                 range:NSMakeRange(0, query.length)]) {
</span><span class="line">
</span><span class="line">      return NO;
</span><span class="line">
</span><span class="line">    }
</span><span class="line">
</span><span class="line"> 
</span><span class="line">
</span><span class="line">    for (id&lt;RCTImageURLLoader&gt; loader in _loaders) {
</span><span class="line">
</span><span class="line">        if (![loader conformsToProtocol:@protocol(RCTURLRequestHandler)] &amp;&amp;
</span><span class="line">
</span><span class="line">            [loader canLoadImageURL:requestURL]) {
</span><span class="line">
</span><span class="line">            return YES;
</span><span class="line">
</span><span class="line">        }
</span><span class="line">
</span><span class="line">    }
</span><span class="line">
</span><span class="line">    return NO;
</span><span class="line">
</span><span class="line">}
</span></code></pre></td></tr></table></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
</pre></td><td class="code"><pre><code class=""><span class="line">@implementation RCTImageLoader (Hook)
</span><span class="line">
</span><span class="line">- (BOOL)hook_canHandleRequest:(NSURLRequest *)request
</span><span class="line">
</span><span class="line">{
</span><span class="line">
</span><span class="line">    static pthread_mutex_t mutex;
</span><span class="line">
</span><span class="line">    static dispatch_once_t onceToken;
</span><span class="line">
</span><span class="line">    dispatch_once(&amp;onceToken, ^{
</span><span class="line">
</span><span class="line">        pthread_mutex_init(&amp;mutex, NULL);
</span><span class="line">
</span><span class="line">    });
</span><span class="line">
</span><span class="line">    pthread_mutex_lock(&amp;mutex);
</span><span class="line">
</span><span class="line">    BOOL result;
</span><span class="line">
</span><span class="line">    result = [self hook_canHandleRequest:request];
</span><span class="line">
</span><span class="line">    pthread_mutex_unlock(&amp;mutex);
</span><span class="line">
</span><span class="line"> 
</span><span class="line">
</span><span class="line">    return result;
</span><span class="line">
</span><span class="line">}
</span><span class="line">
</span><span class="line">@end
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><strong>其他的RN野指针崩溃可以通过类似的方式来解决，只不过有时候要用递归锁。</strong></p>

<p>4.主线程卡死问题</p>

<p>有时候子线程会先拿到锁，主线程反而在等待，而子线程可能会同步的丢一个block到主线程，造成死锁。</p>

<p>RCTBatchedBridge+Hook.m里对线程做了加锁上的优化：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
</pre></td><td class="code"><pre><code class=""><span class="line">- (id)hook_moduleForName:(NSString *)moduleName
</span><span class="line">{
</span><span class="line">    if (!moduleName || ![moduleName isKindOfClass:[NSString class]]) {
</span><span class="line">        return nil;
</span><span class="line">    }
</span><span class="line">    ///&lt; 这个函数会递归调用
</span><span class="line">    static NSRecursiveLock *lock;
</span><span class="line">    static dispatch_once_t onceToken;
</span><span class="line">    dispatch_once(&amp;onceToken, ^{
</span><span class="line">        lock = [[NSRecursiveLock alloc] init];
</span><span class="line">    });
</span><span class="line"> 
</span><span class="line">    id value = nil;
</span><span class="line">    if (![NSThread isMainThread]) {
</span><span class="line">        [lock lock];
</span><span class="line">        value = [self hook_moduleForName:moduleName];
</span><span class="line">        [lock unlock];
</span><span class="line">    } else {
</span><span class="line">        ///&lt; 子线程有时候会同步丢一个block到主线程，避免死锁
</span><span class="line">        if ([lock tryLock]) {
</span><span class="line">            value = [self hook_moduleForName:moduleName];
</span><span class="line">            [lock unlock];
</span><span class="line">        } else {
</span><span class="line">            value = [self hook_moduleForName:moduleName];
</span><span class="line">        }
</span><span class="line">    }
</span><span class="line">     
</span><span class="line">    return value;
</span><span class="line">}</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>5.页面退出后block继续执行导致的野指针问题</p>

<p><img src="http://kobe1941.github.io/images/2019/05/12/11.png" alt="" /></p>

<p>如上图，第605行导致了野指针，看下方的代码，正好处于GCD的执行步骤，猜测是直播间的控制器已经销毁，self为nil导致的，GCD的queue这个值不能传nil，否则crash。</p>

<p><img src="http://kobe1941.github.io/images/2019/05/12/12.png" alt="" /></p>

<p>bugly上的日志统计证实了猜测，确实是直播间退出后，block里的代码依然在执行导致崩溃。</p>

<p><img src="http://kobe1941.github.io/images/2019/05/12/13.png" alt="" /></p>

<p>解决方案：在block对self进行强引用并判空。</p>

<p><img src="http://kobe1941.github.io/images/2019/05/12/14.png" alt="" /></p>

<p>6.swift写的nats库的崩溃问题</p>

<p><img src="http://kobe1941.github.io/images/2019/05/12/15.png" alt="" /></p>

<p>以下是源码</p>

<p><img src="http://kobe1941.github.io/images/2019/05/12/16.png" alt="" /></p>

<p>因为这里的queue.async是一个异步操作，做成同步会更合适，避免时序问题导致莫名其妙对象被置nil。</p>

<p>另一个问题就是swift下不允许为nil的情况，此处因为是switch-case的语法，case的条件以及后面的指针解引用是不能传nil指针的，所以当inputstream如果是nil值时会造成SIGTRAP类型的崩溃，解决方案也就是对对象做判空，如下图：</p>

<p><img src="http://kobe1941.github.io/images/2019/05/12/17.png" alt="" /></p>

<p>事实上Nats的崩溃在做完上述两个操作后（其实最根本的是对inputstream判空的操作），就没有出现SIGTRAP类型的崩溃了，也就是说不会再有值被莫名其妙的置nil导致崩溃。</p>

<p>7.self指针的问题</p>

<p><img src="http://kobe1941.github.io/images/2019/05/12/18.png" alt="" /></p>

<p>上图提示为addSubview是野指针。</p>

<p>具体崩溃代码见下图</p>

<p><img src="http://kobe1941.github.io/images/2019/05/12/19.png" alt="" /></p>

<p>原因是ARC对self指针为unsafe_unretained，当上图这个函数在调用还未完成时，页面退出或用其他方式把self回收了，此后继续addSubView:的参数传入self则会野指针。</p>

<p>具体原因见<a href="http://blog.sunnyxx.com/2015/01/17/self-in-arc/">sunny的这篇文章</a>。</p>

<p>解决方案为，用一个局部strong指针去强引用self。</p>

<p>8.ANR问题</p>

<p>卓越网校的ANR问题，基本是主线程做IO操作，或者解析数据造成的，处理起来也简单，把这些操作放到子线程去做基本就没问题。尤其是对于cell的高度计算，子线程算好高度再返回，是一个通用的做法，用时间换流畅度。</p>

<p>另有小部分ANR是autolayout造成的，而这些ANR分布在相对较旧性能较差的机器上，可以不用修改代码，只需要知道手动计算frame的方式比autolayout的性能要好就可以了。</p>

<p>9.一个解决ANR的骚操作</p>

<p>场景是某个接口数据请求回来后，先解析，然后如果数据命中某个逻辑则发通知去通知业务方做其他的操作，通知是同步的，导致函数调用栈太长执行的时间太久被bugly抓到了ANR。</p>

<p>解决方案是把一个操作拆分成两个步骤，后面的步骤放到下一个runloop去做。原理是这么操作既能让出一个优先级给系统去响应用户的手势操作，还能让bugly检测ANR的代码执行过去。</p>

<p>异步丢到main queue的block是在下一次runloop循环或者从休眠中唤醒后执行的，要注意到runloop的源码里，唤醒后执行操作，会去查看此次唤醒是来自source1的mach port还是来自dispatch_asyn的dispatchPort，这两个的具体执行是两个逻辑分支，是分开的而不是一起执行。对用户手势的响应是来自source1的port。</p>

<p><img src="http://kobe1941.github.io/images/2019/05/12/10.png" alt="" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《深入解析Mac OS X & iOS操作系统》]]></title>
    <link href="http://kobe1941.github.io/blog/ios-system-deep.html"/>
    <updated>2019-04-14T21:14:53+08:00</updated>
    <id>http://kobe1941.github.io/blog/ios-system-deep</id>
    <content type="html"><![CDATA[<p>整体上还算不错，对内核，Mach和BSD的介绍，包括一些函数和调用等，以及对异常处理的描述，对于理解PLC这个崩溃日志生成的库还是很有帮助的。同时一些内核线程、用户线程的概念也算是填补部分知识空白。引导过程虽然讲的很详细，不过兴趣不大。</p>

<!--more-->

<h2 id="section">名词解释</h2>

<p>ASLR：Address Space Layout Randomization 地址空间布局随机化</p>

<p>XNU：X is Not UNIX</p>

<p>POSIX：Portable Operating System Interface 可移植操作系统接口</p>

<p>XPC：高级IPC框架，实现进程间特权的分离</p>

<p>ELF：Executable and Library Format ，Unix下的可执行文件格式</p>

<p>__LINKEDIT：由dyld使用，这个区包含了字符串表、符号表以及其他数据</p>

<p>pthread：就是BSD层实现的POSIX规范的线程，Mach层则是mach_thread</p>

<p>DFU：设备固件更新模式，这个模式用于更新iOS镜像</p>

<p>HFS：Hierarchical File System 层次文件系统</p>

<p>FAT：File Allocation Table 文件分配表</p>

<p>NFS：Network File System网络文件系统</p>

<p>VFS：Virtual File System虚拟文件系统</p>

<p>LR寄存器：保存了当前函数的返回地址</p>

<p>PC寄存器：指令指针，程序计数器，PC寄存器中的内容，是下一条要取来执行的指令的地址</p>

<p>ABI：Application Binary Interface 应用程序二进制接口</p>

<h2 id="section-1">第一部分 第一到三章 高级用户指南</h2>

<p>1.iOS系统的GUI是springboard，这是大家熟知的触屏应用加载器。</p>

<p>2.Darwin是操作系统的类UNIX核心，本身由内核，XNU和运行时组成。</p>

<p>3.XNU实际上是由两种技术混合在一起的：Mach和BSD，此外还添加了一些其他的组件，主要是IOKit。</p>

<p>4.在Mac OS中，“bundle”这个词实际上描述的是两种不同的术语：第一种是本节中讨论的目录结构；第二种是共享库目标的一种文件目标格式，共享库由进程显示的加载（普通的库是隐式加载的）。这个词有时候也表示一个插件。</p>

<p>5.OS X是在Mach内核的基础上构建的，而Mach是NeXTSTEP的遗产。BSD层是对Mach内核的包装，但是Mach系统调用仍然可以在用户态访问。</p>

<p>6.内核XNU是Darwin的核心，也是整个OS X的核心。XNU本身由以下几个组件构成：Mach微内核，BSD层，libKern，IOKit。</p>

<p>7.Mach微内核仅能处理操作系统最基本的职责：进程和线程抽象，虚拟内存管理，任务调度，进程间通信和消息传递机制。</p>

<p>8.BSD层建立在Mach层之上，BSD层提供了更高层次的抽象，其中包括：UNIX进程模型，POSIX线程模型（Pthread）及其相关的同步原语，UNIX用户和组，网络协议栈（BSD Socket API），文件系统访问，设备访问（通过/dev目录访问）。</p>

<p>9.OS X提供了一个系统级的通知机制。这是分布式IPC的一种形式，进程可以通过这种机制广播或监听事件。通知机制的核心部分在于notifyd(8) 守护程序，这个守护程序是在系统引导时启动的，这是Darwin的通知服务器。还有一个守护程序 distnoetd(8) 的作用是分布式通知服务器。notify(8) 默认使用Mach消息并注册Mach端口 com.apple.system.notification_center，能够处理大部分通知。notify(8)还有一个有意思的特点，这个API允许通过Mach消息传递文件描述符。</p>

<p>10.苹果通过代码签名，沙盒以及entitlement授权文件来保证iOS和OS X的安全。</p>

<p>11.沙盒机制也有一个专用的守护程序usr/libexec/sandboxd，这个程序运行在用户态，提供了跟踪功能以及内核扩展所需要的辅助服务，这个守护程序是根据需要启动的。</p>

<h2 id="mach-o">第四章 进程线程和Mach-O</h2>

<p>1.尽管同一个可执行程序可以并发的启动多个实例，但是每一个实例都有一个不同的PID。</p>

<p>2.子进程返回的整数由其父进程收集。进程将要返回的值传递给exit(2) 系统调用（或者从main()函数返回）。</p>

<p>3.一个进程内的所有线程都共享虚拟内存空间，文件描述符和各种句柄。</p>

<p>4.进程的生命周期开始于SIDL状态，在这个状态中，进程仍被定义为”正在初始化“，不会响应任何信号，也不会进行任何操作。</p>

<p><img src="http://kobe1941.github.io/images/2019/04/1.png" alt="" /></p>

<p>5.睡眠的进程也会被信号唤醒。通过一个特殊的信号（TSTOP或TOSTOP）可以使一个进程停止执行。这相当于”冻结“了进程（即同时挂起这个进程的所有线程），将这个进程置于”深度睡眠“的状态。恢复这个进程的唯一方法就是发送另一个信号（CONT），这个信号可以将进程切换回可运行状态，使得进程中的每一个线程都可以被重新调度了。</p>

<p>6.终止一个进程会同时终止其所有线程。但是在进程完成终止之前，会短暂的处于僵尸（zombie）状态。每一个进程在安息之前都会有很短暂的时间处于这个状态。僵尸进程都是绝对死亡的进程，僵尸进程只是进程的空壳，所有的资源都被释放了，但是仍然占用着PID。</p>

<p>7.pid_suspend”冰冻“一个进程，pid_resume”解冻“一个进程。冰冻背后的挂起操作是在更为底层的Mach任务的层次实现的，而不是进程的层次实现的，所以这个睡眠更深。iOS的springboard大量使用了这些调用，比如用户按下Home键时。</p>

<p>8.iOS还添加了一个私有的系统调用 pid_shutdown_sockets，这在OS X是没有的。这个系统调用可以在进程之外关闭这个进程所有的套接字。只有springboard使用了这个调用，多半是挂起进程时使用的。</p>

<p>9.信号指发送给程序的异步通知，其中不包括数据（或只包括非常少量的数据）。信号是操作系统发送给进程的，用于表示发生了某种条件，而这种条件通常是因为某类硬件错误或程序异常而产生的。除了SIGKILL之外，进程可以通过一些系统调用屏蔽或处理以下的所有错误。</p>

<p><img src="http://kobe1941.github.io/images/2019/04/2.png" alt="" /></p>

<p><img src="http://kobe1941.github.io/images/2019/04/3.png" alt="" /></p>

<p>10.通用二进制（胖二进制）格式只不过是其支持的各种架构的二进制文件的打包文件。也就是说，这种格式的文件包含一个非常简单的文件头，文件头后面依次拷贝了每一种支持架构的二进制文件。lipo这个工具可以提取、删除或替换通用二进制文件中制定架构的二进制代码，因此可以用于对通用二进制文件进行”瘦身“。这个工具还可以显示胖二进制文件头的详细信息。</p>

<p>11.调用一个二进制文件时，Mach加载器会首先解析胖二进制文件头，确定其中可用的架构，然后只加载最适合的架构的代码，因此不相关架构的代码不会占用任何内存。</p>

<p>12.Mach-O格式具有一个固定的文件头，文件头一开始是一个魔数值，加载器可以通过这个魔数值快速判断这个二进制文件用于32位还是64位，在魔数值之后跟着的是CPU类型及子类型字段。</p>

<p>13.在iOS中，没有暴露sysct接口，堆和栈都默认不可执行。</p>

<p>14.Mach-O文件头的主要功能在于加载命令load command。otool工具可用于分析Mach-O文件。</p>

<p>15.加载过程在内核的部分负责新进程的基本设置——分配虚拟内存，创建主线程，以及处理任何可能的代码签名/加密的工作。然而对于动态链接的可执行文件（大部分可执行文件都是动态链接的）来说，真正的库加载和符号解析的工作都是通过LC_LOAD_DYLINKER命令指定的动态链接器在用户态完成的。控制权会转交给链接器。</p>

<p>16._PAGEZERO段（空指针陷阱）、_TEXT段（程序代码）、_DATA段（程序数据）和_LINKEDIT（链接器使用的符号和其他表）段提供了LC_SEGMENT命令。段有时候也可以进一步分解为区（section）。</p>

<p>17.当所有的库都完成加载之后，dyld的工作也完成了，之后由LC_UNIXTHREAD命令负责启动二进制程序的主线程（因此主线程总是在可执行文件中，而不会在其他二进制文件中例如库文件）。</p>

<p>18.LC_THREAD用于核心转储文件，Mach-O核心转储文件实际上是一组LC_SEGMENT命令的集合，这些命令负责建立起进程的内存镜像。</p>

<p>19.LC_MAIN命令的作用是设置程序主线程的入口点地址和栈大小。</p>

<p>20.Mach-O二进制文件有一个重要特性就是可以进行数字签名。LC_CODE_SIGNATURE包含了Mach-O二进制文件的代码签名，如果这个签名和代码本身不匹配（或者在iOS上这条命令不存在），那么内核会立即给进程发送一个SIGKILL信号，将进程杀死，没有商量的余地。</p>

<p>21.dyld是一个用户态的进程，dyld不属于内核的一部分，而是作为一个开源的项目由苹果单独维护的。</p>

<p>22.可执行文件很少是独立的，除了极少数的一些静态链接的可执行文件，大部分可执行文件都是动态链接的。</p>

<p>23.内核加载器执行的设置工作包括根据段的描述初始化进程地址空间以及执行其他命令。然而，仅有非常少量的进程只需要内核加载器就可以完成加载，而OS X上几乎所有的程序都是动态链接的。也就是说，Mach-O镜像中有很多”空洞“——即对外部的库和符号的引用——这些空洞要在程序启动时填补。这项工作就需要由动态链接器来完成。这个过程有时候也称为符号绑定（binding）。</p>

<p>24.动态链接器是内核执行LC_DYLINKER 加载命令时启动的。通常情况下，使用的是 /usr/lib/dyld 作为动态链接器，不过这条加载命令可以指定任何程序作为参数。链接器接管刚创建的进程的控制权，因为内核将进程的入口点设置为链接器的入口点。链接器索要完成的工作，就是查找进程中所有的符号和库的依赖关系，然后解决这些关系。这个过程必须递归的完成，因为通常情况下库还会依赖于其他的库。</p>

<p>25.通过otool -L命令可以显示库的依赖关系。</p>

<p>26.LC_LOAD_DYLIB命令告诉链接器在哪里可以找到这些符号。链接器要加载每一个指定的库，并且搜寻匹配的符号。被链接的库有一个符号表，符号表将符号名称和地址关联起来。符号表在Mach-O目标文件中的地址可以通过LC_SYMTAB加载命令指定的symoff找到。</p>

<p>27.libSystem库是系统上所有二进制代码的绝对先决条件，不论是C、C++还是Objective-C的程序。这是因为这个库是对底层系统调用和内核服务的接口，如果没有这些接口就什么事也干不了。</p>

<p>28.共享库缓存指的是一些库经过预先链接，然后保存在磁盘上的一个文件中。iOS中大部分常用的库都被缓存了。这个概念有点类似安卓的prelink-map，在prelink-map中的库被提前链接到地址空间中的固定偏移处。</p>

<p>29.为了节省加载的时间，iOS的dyld采用了一个共享库链接缓存，苹果从iOS3.0开始将所有的基础库都移到了这个缓存中。</p>

<p>30.在OS X中，dyld共享库缓存保存在/private/var/db/dyld目录下。在iOS中，共享库缓存可以在/System/Library/Caches/com.apple.dyld 中找到。这个缓存是一个单独的文件，即dyld_shared_cache_armv7。共享库缓存都会增长到非常庞大，OS X包含整整200多个文件，而iOS包含500多个文件，大小约为200M。</p>

<p>问题：共享库缓存到底是一个文件还是多个文件的组合？如果APP使用的第三方的动态库，是APP启动的时候操作系统才去加载，还是手机开机后自动加载这个共享库缓存目录下的文件？</p>

<p>31.OS X的dyld支持两级名称空间。这个特性是10.1引入的，指的是符号名称还包含其所在库的信息。这种方法更具有优势，因为允许两个不同的库导出相同的符号——而这在其他UNIX中会产生链接错误。有时候又需要禁用这种行为，通过将DYLD_FORCE_FLAT_NAMESPACE 环境变量设置为非零的值即可禁用。</p>

<p>32.函数拦截是传统ld没有而dyld有的特性。DYLD_INTERPOSE宏定义允许一个库将其库函数实现替换为另一个函数的实现。——这也是追踪函数调用和修改函数实现的原理</p>

<p><img src="http://kobe1941.github.io/images/2019/04/4.png" alt="" /></p>

<p>33.用户态的一个优点在于虚拟内存的隔离。进程独享一个私有的地址空间。</p>

<p>34.和所有标准的C语言程序一样，OS X中的可执行文件也有一个标准的入口点，默认名称为”main“。不过除了三个标准的参数——argc、argv和envp——之外，Mach-O程序还接受第四个参数：名为”apple“的char**。在Snow Leopard系统之前，”apple“参数只包含一个字符串——程序的完整路径，即启动这个程序所用的execve()系统调用传入的第一个参数。dyld在进程加载的过程中使用了这个参数。从Lion系统开始，”apple“参数被扩展为一个完整的向量，其中包括两个新加入的参数。</p>

<p>35.Cocoa应用程序的入口也是标准的C main()，不过常见做法是将main实现为NSApplicationMain()的包装，然后通过其进入Objective-C的编程模型。</p>

<p>36.重写内存最常用的方法是采用缓冲区溢出（即利用未经保护的内存复制操作越过栈上数组的边界），将函数的返回地址重写为自己的指针。不仅如此，黑客还有更具创意的技术，例如破坏pringtf()格式化字符串以及基于堆的缓冲区溢出等。</p>

<p>37.ASLR：进程每一次启动时，地址空间都会被简单的随机化——只是偏移，而不是搅乱。实现方法是通过内核将Mach-O的段平移某个随机系数。</p>

<p>38.在64位模式下，由于内存空间巨大，所以也就可以遵循其他操作系统采用的模型了，即将内核的地址空间映射到每一个进程的地址空间中。这是64位地址空间和传统的OS X模型的不同之处，传统的OS X内存模型中内核有自己的地址空间，但是新的地址空间允许更快速的用户态/内核态切换（共享CR3寄存器，CR3寄存器是包含了页表指针的控制寄存器）。</p>

<p>39.在内核层面，既没有用户堆也没有栈存在，所有的内存相关操作都要归约为页面。</p>

<p>40.尽管栈在传统上一直是用来保存自动变量的，但是在某些情况下，程序员也可以选择使用栈来动态分配内存，方法是使用鲜为人知的alloca()。如果发生了栈溢出，alloca()会返回NULL，进程会收到SIGSEGV信号。</p>

<p>41.iOS中VM压力释放机制依赖于Jetsam，Jetsam是一种类似于Linux的Out-Of-Memory killer的机制。</p>

<p>42.OS X有一个来自于Mach的独特之处在于，交换空间不是直接在内核层次管理的，而是由一个专用的用户进程dynamic_pager()处理所有的交换请求。这个进程在引导时由launchd通过一个属性列表文件cpm.apple.dynamic_pager.plist启动。</p>

<p>43.线程，作为最大化利用进程时间片的方法应运而生：通过使用多个线程，程序的执行可以分割为表面看上去并发执行的子任务。</p>

<p>44.进程中线程的抢占开销比多任务系统对进程抢占的开销要小。因此从这个角度看，大部分操作系统开始将调度策略从进程转换到线程是有意义的。</p>

<p>45.多处理器更是特别适合线程，因为多个处理器核心共享同样的cache和RAM——这为多线程之间的共享虚拟内存提供了基础。</p>

<p>46.GCD自己维护了一个底层的线程库实现，以支持并发和异步的执行模型，减轻开发者处理并发问题的负担，以及减少类似于死锁之类的潜在错误。GCD的另一个优势是能够自动的随着逻辑处理器的个数而扩展。 ——YYDispatchQueuePool可以根据设备的物理核心数量来创建对应的线程数量。</p>

<h2 id="section-2">第五章  进程跟踪和调试</h2>

<p>1.OS X中的调试工具首先要介绍的就是 DTrace。DTrace是一个重要的调试平台，移植自Sun的Solaris。DTrace中的D指的是D语言，这是一门完整的跟踪语言，通过这个语言可以创建专用的跟踪器，或称为探测器。D语言脚本被编译后由内核执行。</p>

<p>2.iOS中根本就没有提供DTrace。Linux上的ptrace提供了完整的进程跟踪和调试能力，因此称为了Linux下strace，gdb的基础。</p>

<p>3.DTrace神器的调试功能来源于能在内核中执行探测器的能力。DTrace的用户态部分由/usr/lib/dtrace.dylib 负责，Instruments和脚本解释器/usr/sbin/dtrace都使用了这个库。这是编译D脚本的运行时系统。然而，对于大部分有用的脚本来说，实际的执行都在内核态。DTrace通过一个特殊的字符设备(/dev/device)和内核组件进行通信。</p>

<p><img src="http://kobe1941.github.io/images/2019/04/5.png" alt="" /></p>

<p>4.sysctl机制在之前的章节中已经讨论过了，sysctl提供 一些显示进程统计数据的变量。sysctl获得进程ID列表的机制非常重要（事实上，ps和top指令都是通过这个机制获得进程列表的）。</p>

<p>5.除了DTrace和Instruments之外，在OS X中海油一些工具可以获得系统或进程状态的快照：system_profiler，sysdiagnose，allmemory，stackshot，stack_snapshot系统调用。</p>

<p>6.allmemory工具的作用是捕获用户进程的所有内存使用情况。运行时，这个工具遍历系统中的每一个进程，然后将其内存映射导出至/tmp/allmemoryfiles（可以通过-o指定其他文件）。获得了所有进程内存快照之后，allmemory会显示每一个进程的汇总统计数据，还会显示框架的内存使用。</p>

<p>7.stack_snapshot这个系统调用可以捕获指定进程中所有线程的状态。</p>

<p>8.sc_usage工具显示每一个进程的系统调用信息。fs_usage可以显示系统调用，但是显示的是与文件、套接字和目录相关的应用，这个工具可以显示系统范围内的跟踪（除非调用时提供了PID或命令参数）。</p>

<p>9.latency工具显示中断和调度的延迟值。这个工具展示落在阈值内的上下文切换和中断处理程序计数，这两个阈值分别可以通过-st和-it参数设置。</p>

<p>10.XNU包含一个称谓kdebug的内建内核跟踪设施。kdebug利用内核缓冲器来记录日志，而内核缓冲器的空间极为有限。</p>

<p>11.在UNIX中，崩溃和一个信号有关。崩溃的真正原因来自于内核，内核发现进程无法继续执行时，生成这个信号作为最后的补救办法。</p>

<p>12.当一个进程崩溃时，可以选择是否生成核心存储文件。iOS和OS X都没有选择创建巨大的核心转存文件，而是包含了一个CrashReporter，当进程异常终止时自动触发Crash Reporter，生成详细的崩溃日志。这个机制在进程消亡之前进行快速简单的分析，并且在崩溃日志中记录重要的内容。</p>

<p>13.有没有可能在一个应用程序崩溃时自动运行另一个应用程序？在iOS和OS X中，将异常端口绑定至BSD进程底层的Mach任务的机制则能实现这一点。</p>

<p>14.spindump和sample命令的采样方法都是类似的——挂起进程，记录栈跟踪（spindump使用之前描述的stack_snapshot系统调用），然后恢复进程。采样间隔通常大约为10毫秒，整个采样过程通常持续10秒，这两个值是可以配置的。</p>

<p>15.应用程序崩溃的主要原因就是缓冲区溢出（既包含栈也包含堆）和堆内存的破坏。</p>

<p><img src="http://kobe1941.github.io/images/2019/04/6.png" alt="" /></p>

<p>16.libgmalloc.dylib这个库可以截获并调试内存分配，这个强大的库的工作原理是截获LibSystem中的分配函数。</p>

<p>17.任何读/写操作如果越过了缓冲区的尾部就会导致读写操作越过页边界，从而导致一个未处理的页错误，使得进程收到总线错误的信号（SIGBUS）而崩溃。</p>

<p>18.标准的UNIX命令ps可以显示进程列表。UNIX的top命令是一个获得当前系统运行状况的关键工具，在OS X和iOS上都可用，而且相比标准版本有所修改。这些修改都和底层的Mach架构有关，使得top既能显示UNIX的信息（来自XNU的BSD层），也能显示Mach的信息。</p>

<p>19.有时候需要查看某个进程在使用哪些文件，或某个文件正在被哪些进程使用。lsof()和fuser()这两个工具就分别能够实现以上两个功能。lsof()是对之前描述的fs_usage的补充，因为后者只能看到新打开文件的操作，而看不到已经打开的文件。lsof()能显示一个进程所有文件描述符（包括套接字）的映射。换句话说，fs_usage可以持续运行，lsof产生的是一个快照。</p>

<p>20.fuser()提供的是反向的映射——从文件到拥有这个文件的进程。这个工具的主要作用是诊断文件锁定或者“文件被占用”的问题。</p>

<p>21.尽管XNU在用户态提供了完整的POSIX API，展示了UNIX兼容的人格，但是底层的实现却主要依靠Mach的基本原语。</p>

<p><img src="http://kobe1941.github.io/images/2019/04/7.png" alt="" /></p>

<p>22.随着苹果转向LLVM-gcc转换，还引入了LLDB作为GDB的替代品。LLDB的语法基本上和GDB类似，但是调试功能大有增强。</p>

<h2 id="launchd">第六章 引导过程 第七章 贯穿始终——launchd</h2>

<p>1.固件（firmware）可以看作是一种软件，这种软件因为被写入了芯片，所以是“固化”的。固件代码本身可以保存在只读存储器（ROM）中，也可以保存在电可擦除只读存储器EEPROM中</p>

<p>2.BIOS是一个固定的程序，而且通常都是封闭的。EFI是一套接口。EFI更像是一个运行时环境，规范了一组应用程序编程接口，基于EFI的程序可以利用这些接口实现功能。</p>

<p>3.苹果的EFI实现的另一个重要特性是Boot Camp。Boot Camp是苹果双重引导的解决方案，这个解决方案再Mac硬件上运行非苹果的操作系统（主要是Windows）。</p>

<p><img src="http://kobe1941.github.io/images/2019/04/8.png" alt="" /></p>

<p>4.一旦苹果关闭了某个iOS版本的时间窗口，将安全服务器配置为拒绝这个版本的签名时，就不可能降级固件了。</p>

<p>5.OS X和iOS中，用户环境始于launchd。launchd作为系统中的第一个用户态进程，负责直接或间接的启动系统中的其他进程。launchd仍然属于Darwin的范畴。</p>

<p>6.launchd是由内核直接启动的。负责加载BSD子系统的主内核线程创建一个线程来执行bdsinit_task。这个线程获得PID 1，并且临时命令为“init”，这是一项来源于BSD的遗产。bsdinit_task然后调用load_init_program()，这个函数调用execve()系统调用（在内核空间中执行）执行守护程序。</p>

<p>7.系统范围的launchd（PID 1）是不可能终止的。事实上，这个launchd是系统上唯一不朽的进程。当系统关闭的时候，launchd也是最后一个退出的进程。</p>

<p>8.launchd的核心职责是根据预定的安排或实际的需要加载其他应用程序或作业。launchd区分两种类型的后台作业：</p>

<p>①守护程序（daemon）和传统的UNIX概念一样，是后台服务，通常和用户没有交互。守护程序由系统自动启动，不考虑是否有用户登录进系统。</p>

<p>②代码程序（agent）是一类特殊的守护程序，只有在用户登录的时候才启动。和守护程序的不同之处在于，代理程序可以和用户交互，有的代理程序还有GUI。</p>

<p>③iOS不支持用户登录的概念，因此只有LaunchDaemon。</p>

<p>④守护程序和代理程序都是通过自己的属性列表文件（.plist）声明的。</p>

<p>9.launchd是用户态出现的第一个进程。当系统还在启动初期的时候，launchd是系统上唯一的进程（尽管这个状态很短暂）。这意味着系统启动和功能的方方面面都和launchd直接或间接相关。</p>

<p>10.launchd的第一个，也是主要的职责就是init守护程序的职责。init的职责是派生出各种各样的后台守护程序，设置好系统，然后转入后台，确保这些守护程序都活着。如果有程序死亡了，launchd要负责重新派生出新的守护程序。</p>

<p>11.传统意义上，init是用户态的第一个进程，从init fork出其他进程（转而可能fork出更多进程），init设置的资源限制会被所有后代继承。而launchd（新时代意义上的用户态第一个进程）还会设置Mach异常端口，内核内部通过异常端口处理异常情况并生成信号。</p>

<p>12.UNIX传统上包含两个守护程序——atd和crond——来定时作业，即在指定时间运行指定的命令。第一个守护程序atd负责一次运行的作业，第二个守护程序crond提供了重复执行作业的支持。</p>

<p>13.inetd/xinetd的用途是启动网络服务。这个守护程序的职责是绑定一些端口（UDP端口或TCP端口），当有连接请求到达的时候，根据需要启动相应的服务程序，并且将服务程序的输入输出描述符（stdin，stderr，stdout）连接到对应的套接字。</p>

<p>14.Mach的IPC服务依赖于“端口”的概念（有点类似TCP和UDP端口的概念），端口是通信的端点。</p>

<p>15.launchd还整合了iOS的Jetsam机制，Jetsam机制可以强制施行虚拟内存使用率的限制，这项特性在没有交换空间的iOS中特别重要。</p>

<p>16.ReportCrash守护程序是默认的崩溃处理程序，截获所有应用程序的崩溃。通过设置作业的Mach异常端口，在发生崩溃的时候自动运行。</p>

<p>17.iOS中amfid守护程序，可以阻止一切无签名无entitlement的代码在iOS中运行。</p>

<p>18.apsd（ApplePushService.framework）守护程序则是苹果推送服务的守护程序，以mobile用户运行。</p>

<p>19.atc守护程序则用于空中流量限制。crash_mover守护程序用于将崩溃日志移动到 <code>/var/Mobile/Library/Logs</code> 目录。</p>

<p>20.mobile_obliterator守护程序则用于远程擦除设备。</p>

<p>21.lockdownd就像是用户态的狱警，是所有越狱者的头号敌人。lockdownd由launchd启动，负责处理设备激活、备份、崩溃报告、设备同步以及其他服务。</p>

<p>22.OS X下的图形shell环境是Finder，iOS使用的择时SpringBoard。</p>

<p>23.和Finder不太一样，SpringBoard几乎全部靠自己完成所有的工作，在CoreServices目录下也只有少量几个可加载的bundle。</p>

<p>lockbundle提供了锁屏时的功能。NowPlayingArtLockScreen.lockbundle负责提供当音乐播放器正在运行且屏幕锁定的时候的锁屏画面，PictureFramePlugin负责显示用户照片库中的图片。iPhone还有一个名为VoiceMemosLockScreen的bundle，负责显示语音信息和未接电话指示器。</p>

<p>24.SpringBoard是一个多线程的应用程序，线程数远多于Finder。如果SpringBoard超过几分钟没有响应，那么看门狗会重启系统。</p>

<p>25.SpringBoard注册的端口中，最重要的是PurpleSystemEventPort，这个端口通过GSEvent消息的方式处理UI事件。SpringBoard中的主线程调用GSEventRun()，GSEventRun()是一个处理UI消息的CFRunloop。其他线程都类似的运行循环，处理SpringBoard中的其他Mach端口。</p>

<p>26.XPC是Lion和iOS5新引入的轻量级进程间通信原语。libxpc.dylib提供了各种各样的C语言层次的XPC原语。默认情况下XPC的消息是异步发送的，应答也是异步的，通过reply_sync函数可以阻塞知道收到应答消息。XPC是通过Mach消息机制实现的。</p>

<h4 id="section-3">第二部分 内核</h4>

<h2 id="section-4">第八章 内核架构</h2>

<p>1.内核既是一个操作系统，也是一个调度器，还是一个仲裁器，内核同时也提供安全服务。</p>

<p>2.内核从架构上分为巨内核，微内核和混合内核。</p>

<p>3.巨内核采取的方式是将所有的内核功能——不论是基础功能还是高级功能——全部放在一个地址空间中。在这种架构的内核中，线程调度和内存管理，以及文件系统、安全管理、甚至设备驱动全都在一起。</p>

<p>所有的内核功能都实现在同一个地址空间中吗。为了进一步优化，巨内核不进将所有的工呢过都组织在同一个地址空间中们还将这个地址空间映射到每一个进程的内存中。</p>

<p>在巨内核架构中，从用户态到内核态的切换非常搞笑，基本上就是一次线程切换的开销。这是因为内核的你内存页面映射在所有进程的地址空间中，也就是说，除了硬件强制的内核态和用户态之间的隔离外，两者之间其实没有任何分别。所有的进程，不论所有者或功能，都包含一份内核内存的拷贝，就好像包含共享库的拷贝一样。此外，这些拷贝（同样类似于共享库）都映射到了同一组物理页面，而且是常驻内存的物理页面。</p>

<p>4.XNU的核心组件Mach是一个微内核系统。</p>

<p>一个微内核值包含最核心的内核功能，代码量也最精简。内黑只负责完成最最关键的部分——通常包括任务调度和内存管理，其他的功能都交给外部服务程序（通常是用户态）完成。</p>

<p>微内核有几个巨内核没有的有点：正确性，稳定性和健壮性，灵活性（移植）。</p>

<p>尽管微内核架构有着种种优势，但是却有一个致命的缺点——性能。微内核的消息传递在底层需要通过内存复制操作以及数次上下文的切换来实现，而这些操作对计算速度的影响都不小。</p>

<p>5.混合内核试图结合两种内核的好处。内核最核心部分支持底层服务，包括调度、进程间通信和虚拟内存，是自包含的，这一部分就像微内核一样。所有其他的服务都实现在这个核心之外，但是也在内核态中，而且和这个核心在同一个内存空间中。</p>

<p>这种内核不强制要求消息传递。其他组件可以调用这个“内部核心”的服务，但是这个“内部核心”不能调用外部的组件。</p>

<p>6.从技术上说，XNU是一个混合内核。Windows内核也被认为是一个混合型的内核，但是两者差别巨大。Windows更接近巨内核，所以死亡蓝屏概率高，而XNU更接近于微内核。</p>

<p>7.XNU的Mach最早是一个真正的微内核，现在Mach的原语仍然是围绕着消息传递的基础构建的。然而，消息通常是以指针的形式传递的，因此没有昂贵的复制操作。这是因为大部分服务现在都在同一个地址空间中执行（因为也会被归为巨内核）。类似的，建立在Mach之上的BSD层一直都是一个巨内核，而且这个子系统也在同一个地址空间中。</p>

<p>8.32位的OS X应用程序可以享用完整的没有内核预留的地址空间——内核有自己的地址空间。然而在64位的OS X中，苹果却顺从了，就像其他巨内核的系统一样，内核空间和用户空间是共享的。在iOS中也是如此。</p>

<p>9.内核是一个受信任的系统组件。内核的功能和应用程序的功能之间需要有一种严格的分离，否则应用程序的崩溃会使整个系统本科鬼。这种分离需要由硬件强制支持，因为基于软件的强制实施不但会产生很大的开销，也不可靠。区分内核态和用户态非常重要，因此这个功能是由硬件提供的。</p>

<p>10.用户态和内核态的切换有两种类型：</p>

<p>①自愿转换，比如系统调用；</p>

<p>②非自愿转换，当发生异常、中断或处理器陷阱的时候，代码的执行会被挂起，并且保留发生错误时候的完整状态。控制权被转交给预定义的内核态错误处理程序或中断服务程序。</p>

<p>11.一共有三种类型的异常：</p>

<p>①错误（fault）：指令遇到一个可以纠正的异常，并且处理器可以重新启动这条出现异常的指令。</p>

<p>②陷阱（trap）：类似于错误，但是错误处理完成后返回发生陷阱指令之后的那条指令。</p>

<p>③中止（abort）：不可重启指令。</p>

<p>12.BSD系统调用，可以通过current_task获得当前BSD进程的数据结构。</p>

<h2 id="section-5">第九章 内核引导和内核崩溃</h2>

<p>1.苹果只开源了针对OS X编译的XNU版本，iOS的版本则是闭源的。</p>

<p>2.和Linux内核类似，Linux可以针对特定架构编译，Mach也能。</p>

<p>3.如果要在一堆源码文件中查找某个特定的函数名、变量名或其他符号，grep是一个不错的工具，grep可以接受任何正则表达式，并且在.h和.c文件中寻找匹配。</p>

<p>4.vstart是i386/x64架构下的“官方”的内核初始化函数，标志着从汇编代码到C语言代码的转换。</p>

<p>5.除了虚拟内存之外，kernel_bootstrap还初始化Mach的一些关键抽象：</p>

<p>IPC——进程间通信是Mach构建的根基，IPC要求一些重要的资源，例如内存、同步对象和Mach接口生成器；</p>

<p>时钟clock——通过时钟抽象实现闹铃；</p>

<p>账本——账本是Mach系统的记账工具；</p>

<p>任务task——任务是Mach的容器，类似BSD的进程；</p>

<p>线程thread——线程是实际的执行单元。任务只不过是一个资源容器，真正被调度和执行的是线程。</p>

<p>6.关于异常处理</p>

<p><img src="http://kobe1941.github.io/images/2019/04/9.png" alt="" /></p>

<h2 id="mach">第十章 Mach原语：一切以消息为媒介</h2>

<p>1.XNU的核心是苹果从NeXTSTEP带来的Mach微内核。尽管Mach核心被BSD层包装起来了，而且主要的内核接口是标准的POSIX系统调用，但是这个Mach核心具有一组独特的API和原语。</p>

<p>消息传递原语：讨论消息和端口，这是Mach IPC的基础。</p>

<p>同步原语：锁和信号量是两种内核对象，这些对象用于确保并发执行的安全。</p>

<p>2.Mach采用的是极简主义的概念。Mach和其他操作系统不同，其他操作系统提供了用户态进程实现所基于的完整模型，而Mach只提供了一个极简的模型，操作系统本身可以在这个模型的基础上实现。</p>

<p>在Mach中，所有的东西都是通过自己的对象实现的。进程（在Mach中称为任务）、线程和虚拟内存都是对象，所有对象都有自己的属性。</p>

<p>Mach的独特之处在于选择了通过消息传递的方式实现对象和对象之间的通信。Mach对象不能直接调用另一个对象，而是必须传递消息。源对象发送一条消息，然后这条消息被加入到目标对象的队列中等待处理。类似的，消息处理中可能会产生一个应答，这个应答通过另一条消息被发送回源对象。消息是以FIFO的方式可靠传输的（如果消息被发送出去，那么一定能被收到）。</p>

<p>3.Mach的首要设计目标也是最重要的目标就是要将所有功能移出内核，并且放在用户态中，将内核保持在极简的状态。</p>

<p>4.Mach的设计有一个非常强大的优点——在设计中考虑了多处理。从理论上说，Mach可以轻松扩展成计算机集群使用的操作系统。</p>

<p>5.Mach中最基本的概念是消息，消息在两个端点或端口之间传递。任何两个端口之间都可以传递消息——不论是同一台机器上的端口还是远程主机的端口。Mach消息的设计考虑了参数串行化、对齐、填充和字节顺序的问题，这些问题都被消息实现隐藏了。</p>

<p>6.Mach消息的发送和接收都是通过同一个API函数mach_msg()进行的，这个函数在用户态和内核态都有实现。</p>

<p>7.Mach消息原本是为真正的微内核架构而设计的，也就是说，mach_msg()函数必须在发送者和接受者之间复制消息所在的内存。但是XNU通过单一内核的方式来“作弊”：所有的内核组件都共享同一个地址空间，因此消息传递时只需要传递消息的指针就可以了，从而省去了昂贵的内存复制操作。</p>

<p>8.为了实现消息的发送和接收，mach_msg()函数调用了一个Mach陷阱（trap）。Mach陷阱就是Mach中跟系统调用等同的概念，在用户态调用mach_msg_trap()会引发陷阱机制，切换到内核态，在内核态中，内核实现的mach_msg()会完成实际的工作。</p>

<p>9.消息在端口之间传递。消息从某个端口发送到另一个端口。每个端口都可以接收来自任意发送者的消息，但是只能有一个指定接收者。向一个端口发送消息时实际上是将消息放在一个队列中，直到消息能被接收者处理。</p>

<p>10.所有的Mach原生对象都是通过对对应的端口访问的。</p>

<p>11.端口和权限也可以从一个实体传递到另一个实体。实际上，通过复杂消息将端口从一个任务传递到另一个任务并不罕见。这是IPC设计中的一个非常强大的特性，有一点类似于主流UNIX的domain socket，允许在进程之间传递文件描述符。</p>

<p>12.Mach的消息传递模型是远程过程调用（RPC）的一种实现。</p>

<p>13.IPC所需要的基本原语：消息、发送和接收消息的端口，以及确保安全并发的信号量和锁。</p>

<p>14.每一个Mach任务（Mach任务是一个对应于进程的高层次抽象）包含一个指针指向自己的IPC名称空间，在名称空间中保存了自己的端口。此外，任务也可以获得系统范围内的端口。</p>

<p>15.同步机制的根本是排他访问的能力：当别人在使用一个资源时，排除其他人对这个资源的访问。因此最基本的同步原语是互斥对象，也称为互斥体。互斥体只不过是内核内存中的普通变量，通常是机器字大小的证书，但是有一个特殊要求——硬件必须对这些变量进行原子操作。“原子”的意思就是说，对互斥体的操作决不允许被打断——即使是硬件中断也不能打断。在SMP系统上，对物理互斥还有一个要求，就是要求硬件实现某种内存屏障。</p>

<p>16.Mach的锁依赖两个层次组合而成：硬件相关层——依赖于硬件的特殊性质，并且通过特定的汇编指令实现原子性和互斥性；硬件无关层——通过统一的API包装硬件特定的调用，这些API使得Mach之上的层完全不用关心实现的细节。</p>

<p>17.互斥体有一个最大的缺点，就是一次只能有一个线程持有锁。读写锁就是这个问题的解决方案，读写锁能够区分读访问和写访问，多个读者可以同时持有锁，而一次只能有一个写者。当一个写者持有锁时，所有其他线程都被阻塞。 ——pthread_rwlock_t就是POSIX层的API在iOS下的读写锁，区分pthread_rwlock_rdlock读和pthread_rwlock_wrlock写的加锁，解锁统一用pthread_rwlock_unlock。</p>

<p>18.阻塞一个线程意味着放弃线程的时间片，把处理器让给调度器认为下一个要执行的线程。当锁可用时，调度器会得到通知，然后根据自己的判断将线程从等待队列中取出并重新调度。</p>

<p>19.Mach提供了信号量，信号量是泛化的互斥体。互斥体的值只能是0和1，而信号量的取值可以达到某个正数，即允许并发持有信号量的持有者的个数。信号量可以在用户态使用，而互斥体只能在内核态使用。</p>

<p>20.在XNU上，POSIX信号量的底层实现是通过Mach信号量实现的。</p>

<p>21.信号量可以转换为端口，也可以由端口转换而来。</p>

<p>22.锁集就是锁的数组，通过给定的锁ID可以访问锁。锁也可以传递给其他线程。交出一个锁会阻塞交出锁的线程，并唤醒接受锁的线程。</p>

<p>23.锁集的有趣之处在于允许锁的传递。锁的传递指的是将锁从一个任务传递给另一个任务的过程。Mach在调度中也使用了传递的概念，允许一个线程放弃处理器但是指定哪一个线程接替运行。</p>

<p>24.Mach提供了一组异常丰富的API调用用于查询机器信息，所有这些调用都要求获得主机端口才能工作。</p>

<p>主机API最重要的一个方面就是能提供其他方式几乎无法获得的信息。Mach API是获得内核模块信息，内存映射表信息以及其他POSIX（BSD层）无法获得的信息的最直接方法。</p>

<p>25.所有的用户都可以通过mach_host_self()获得主机端口，但是只有特权用户才能通过调用host_get_host_priv_port()获得特权端口。</p>

<p>26.host_set_exception_ports()获得/设置或交换主机层次的异常处理程序。</p>

<p>27.一个或多个processor_t对象可以分组为处理器集，或称为pset。pset中的处理器通过两个队列进行维护：一个是active_queue，保存当前正在执行线程的处理器；另一个是idle_queue，用于保存当前空闲的处理器。</p>

<h2 id="mach-1">第十一章  Mach调度</h2>

<p>1.和所有现代的操作系统一样，内核调度的对象是线程，而不是进程。Mach使用了比进程更轻量级的概念：任务task。</p>

<p>2.线程定义了Mach中最小的执行单元。一个或多个线程包含在一个任务中。</p>

<p>3.Mach将任务定义为线程的容器，因此资源是在任务这个层次处理的。线程只能（通过端口）访问包含这个线程的任务中分配的资源和内存。</p>

<p>4.任务task是一种容器对象，虚拟内存空间和其他资源都是通过这个容器对象管理的。这些资源包括设备和其他句柄。资源进一步被抽象为端口。因此资源的共享实际上相当于允许对对应端口进行访问。</p>

<p>5.严格的说，Mach的任务并不是其他操作系统中所谓的进程，因为Mach作为一个微内核的操作系统，并没有提供“进程”的逻辑，而只提供了最基本的实现。不过在BSD的模型中，这两个概念有1：1的简单映射，每一个BSD进程（也就是OS X进程）都在底层关联了一个Mach任务对象。实现这种映射的防范是指定一个透明的指针bsd_info，Mach对bsd_info完全无知。</p>

<p>6.任务是没有生命的，任务存在的目的就是要成为一个或多个线程的容器。大部分针对任务的操作实际上就是遍历给定任务中的所有线程，并对这些线程进行对应的线程操作。</p>

<p>7.在任何时刻，内核都必须能够蝴蝶当前任务和当前线程的句柄。内核分别通过current_task()和current_thread()函数完成这两个任务。</p>

<p>8.thread_suspend/thread_resume表示挂起/恢复线程，会递增/递减挂起计数器。线程只有在其suspend计数器和所在的任务的suspend计数器都为0时才能执行。</p>

<p>9.当调用pthread_create()时，底层会转而调用Mach的API调用thread_create()，并且使用mach_task_self()作为第一个参数。</p>

<p>10.由于每一个处理器核心在同一时刻只能运行一个线程，所以内核必须具有抢占一个线程的执行，将处理器让给另一个线程的能力，从而实现上下文切换。</p>

<p>11.由于Mach具有处理器集的抽象，所以从某种角度说，Mach比Linux和Windows更擅长管理多核处理器：Mach可以将同一个CPU的多个核心放在同一个pset中管理，并且通过不同的pset管理不同的CPU。</p>

<p>12.上下文切换是暂停某个线程的执行，并且将其寄存器状态记录在某个预定义的内存位置中。当一个线程被抢占时，CPU寄存器中会加载另一个线程保存的线程状态，从而恢复那个线程的执行。</p>

<p>13.一个线程在CPU上可以执行任意长时间。执行指的是这样一个事实：CPU寄存器中填满了线程的状态，因此CPU执行该线程函数的代码。这个执行过程一直持续，直到①线程终止；②线程自愿放弃CPU；③外部中断打断了线程执行（时间片用完或更高优先级的线程被唤醒）。</p>

<p>14.每一个操作系统都提供了一个优先级的范围：Windows有32个优先级，Linux有140个优先级，而Mach有128个优先级。</p>

<p>内核线程的最低优先级为80，比用户态线程的优先级要高，可以保证内核以及系统维护管理的线程能够抢占用户态的线程。</p>

<p>通过 ps -l 命令可以查看优先级</p>

<p>15.Mach会针对每一个线程的CPU利用率和整体系统负载动态吊证每一个线程的优先级。因此线程会在自己的优先级范围中“漂移”，如果耗CPU太多则降低优先级，如果不能得到足够的CPU资源则提升优先级。</p>

<p>16.在使用多核、SMP或超线程的现代架构中，还可以设置某个线程和一个或多个指定CPU的亲缘性。这种亲缘性对于线程和系统来说都是有好处的，因为当线程回到同一个CPU上执行时，线程的数据可能还留在CPU的缓存中，从而提升性能。用Mach的说法，线程对CPU的亲缘性的意思就是绑定。</p>

<p>17.Mach含有的特殊特性：</p>

<p>①控制权转交（handoff）允许一个线程主动放弃CPU，但不是将CPU放弃给任何其他线程，而是降CPU转交给自己选择的某个特定的线程。</p>

<p>②使用续体可以使线程不用管理自己的栈，线程可以丢弃自己的栈，系统恢复线程执行时不需要恢复线程的栈。</p>

<p>③异步软件陷阱AST是软件对底层硬件陷阱机制的补充完善。通过使用AST，内核可以响应需要得到关注的带外（out-of-band）事件，例如调度事件。</p>

<p>18.Mach对yield做了改进，允许选择将CPU转交给谁。控制权转交并不是对调度器的强制要求，调度器还可以选择将控制权转交给其他线程（例如，如果指定的线程处于不可运行的状态）。作为控制权转交的结果，当前线程剩下的时间片也会被转交给新调度的线程。</p>

<p>19.如果线程要进行控制权转交而不是简单的yield操作，那么需要调用thread_switch()，Mach将thread_switch()导出为一个陷阱，因此也可以从用户态调用这个函数。</p>

<p>20.上下文切换采用的是每一个线程都有自己独有栈的模型，当线程自愿请求一次上下文切换时可以选择指定一个续体。如果指定了续体，那么当线程恢复执行时，系统会以续体作为入口点重新加载线程，并创建新的栈，之前的状态都不会得到保留。这样可以明显加快上下文切换的速度，因为不需要保存和加载寄存器（此外还能显著地节省内核栈的空间，内核栈本身很小，只有4个页面，即16kb）。续体中的线程只需要4-5kb的空间来保存线程状态，将16kb中的其他空间节省下来用作其他用途。使用续体不需要保存完整的寄存器状态和线程栈，只需要保存续体以及参数。</p>

<p>21.续体是缓解上下文切换开销的简单有效的机制，主要由Mach的内核线程使用。内核线程特别喜欢使用续体，Mach的内核线程是通过续体启动的。</p>

<p>22.Mach支持两种不同模式的抢占——显示抢占和隐式抢占，续体模式只能用于显示抢占。</p>

<p>23.系统中的线程可能会被两种方式抢占：一种是显示的抢占，即线程放弃CPU的控制权或进入阻塞的操作；另一种是隐式的抢占，这种抢占是由中断引起的。显示抢占有时候也被认为是同步的，因为这种抢占是事先可以预知的。而由于中断不可预测的本质，所以隐式的抢占是异步的。</p>

<p>24.发生显示抢占的原因可能是等待某个资源，等待某个IO，或睡眠一定的时间。当用户态的线程调用阻塞的系统调用（例如read(),select()和sleep()）时会发生显示抢占。</p>

<p>25.thread_invoke()函数负责执行上下文切换并负责处理续体。</p>

<p>26.显示抢占本身是有局限性的，将放弃CPU的选择权交给运行的线程是极为不可靠的。线程会陷入费时的处理操作中，甚至会进入死循环。</p>

<p>27.Mac OS X是一个抢占式的多任务系统。简单的说，Mach具有随时抢占一个线程的权利，不论这个线程是否准备好了抢占。和显示的抢占不同，这种隐式的抢占对于线程来说是不可见的。线程可以对这种抢占完全不知情，线程的状态会被透明的保存并恢复。大部分线程不会受到太大的影响，因为大部分线程都是IO密集型的。但是对于CPU密集型的线程来说，这种抢占可能会造成一些问题，特别是要求时间关键的性能时（例如视频和音频解码都是这种类型的任务）。</p>

<p>28.Mach是一个分时系统，而不是一个实时系统。</p>

<p>29.THREAD_AFFINITY_POLICY策略定义了线程的L2缓存亲缘性，这些线程共享同一块缓存。这意味着这些线程很可能运行在同一个CPU上，不论这个CPU有多少核心（毕竟同一个CPU上所有核心都共享同一块L2缓存）。</p>

<p>30.异步软件陷阱AST就是为了支持隐士抢占的。AST是人工引发的非硬件触发的陷阱。AST是内核操作的关键部分，而且是调度时间的底层机制，也是BSD信号的实现基础。</p>

<p>31.ast_taken函数（内核陷阱中和内核线程终止时也可以调用）负责处理除了内核idle线程之外的所有线程的AST。否则，这个函数会检查AST_BSD，这原本是对Mach的一个临时修改，使其能够处理BSD事件（例如信号），但是被永久的保留了。如果设置了AST_BSD，则调用bsd_ast处理信号。</p>

<p>32.Mach的线程调度算法高度可扩展，而且允许更换用于线程调度的算法。不过通常情况下，只启用了一个调度器，即传统调度器。调度器大量使用了AST机制。</p>

<p>33.对于要提供抢占式多任务的系统来说，必须有某种机制允许调度器能够首先得到CPU的控制权，从而抢占当前正在执行的线程，然后才能执行调度算法，并且通过调度算法决定当前的线程可以继续恢复执行还是要抢夺其CPU给更重要的线程使用。</p>

<p>34.为了能够从当前运行的线程抢夺CPU，现在的操作系统都利用了现有的硬件中断机制。由于中断的特点是强迫CPU在发生中断时“放下手中所有的任务”，并longjmp跳转到中断处理程序（也称为中断服务例程ISR）执行，因此可以通过中断机制在发生中断时运行调度器。但是问题是，中断是异步的。</p>

<p>35.内核可以配置时钟使其在给定数目的周期之后产生一个中断。这个中断源通常称为定时器中断。</p>

<p>36.解决方案是采用另一种不同的模型：无tick内核。在这种模型中，每一次定时中断发生时，定时器都会被重新设置为调度器认为需要下一次中断的时刻。这意味着在每一次定时器中断时，中断处理程序都要（非常快）扫描还没超期的截止时间线的列表。相比大量不必要的中断，每一次定时器中断中多做的这些处理工作还是值得的，而且通过只跟踪那些最紧急的截止时间线可以将这些处理工作的开销降到最低。</p>

<p>37.在添加非严格的定时器事件是会加上一个所谓的“宽限slop”值，通过宽限值可以合并一些定时器事件，从而增加这些定时器事件同时超时的概率（从而减少了定时器中断的总数）。</p>

<p>38.Mach只提供了一个异常处理机制用于处理所有类型的异常——包括用户定义的异常、平台无关的异常、以及平台特定的异常。</p>

<p>39.在Mach中，异常是通过内核中的基础设施——消息传递机制——处理的。异常由出错的线程或任务（通过msg_send()）抛出，然后由一个处理程序（通过msg_recv()）捕捉。处理程序可以处理异常，也可以清除异常，可以决定终止线程。</p>

<p>40.Mach的异常处理程序在不同的上下文中运行异常处理程序，出错的线程向预先指定好的异常端口发送消息，然后等待应答。每一个任务都可以注册一个异常端口，这个异常端口会对同一个任务中的所有线程起效。单个的线程还可以通过 thread_set_exception_prots 注册自己的异常端口。通常情况下，任务和线程的异常端口都是NULL，也就是说异常不会被处理。</p>

<p>41.发生异常时，首先尝试将异常抛给线程的异常端口，然后尝试抛给任务的异常端口，最后再抛给主机的异常端口（即主机注册的默认端口）。如果没有一个端口返回 KERN_SUCCESS，那么整个任务被终止。Mach不提供异常处理逻辑——只提供传递异常通知的框架。</p>

<p>42.exception_triage()负责主要的异常处理逻辑，这个逻辑在两种架构上的Mach消息层面都是一样的。这个函数尝试根据前文描述的方式——线程、任务、最终到达主机——利用exception_deliver()投递异常。</p>

<p>43.每一个线程或任务对象，以及主机本身，都有一个异常端口数组，这个数组中的端口通常初始化为IP_NULL。通过xxx_set_exception_ports()调用可以设置这些异常端口，其中的xxx为thread、task或host。</p>

<p>44.[mach]_exception_raise 用于EXCEPTION_DEFAULT，[mach]_exception_state_raise 用于EXCEPTION_STATE。[PLCrashReporter里有相关的使用] 这些函数最终通过调用ux_exception将异常转换为响应的UNIX信号，并且通过threadsignal将信号投递到出错的线程。</p>

<p>45.OS X的最重要的特性之一崩溃报告器（crash reporter）就是利用异常端口的机制实现的。launchd注册了异常端口，然后将所有子进程都应用同样的异常端口，因为异常端口是随着进程fork集成的。launchd将ReportCrash设置为MachExceptionHandler。通过这种方式，当一个launchd作业发生异常时，崩溃报告器会自动根据需要启动。调试器也可以利用异常端口捕捉异常并且在发生错误时中断。</p>

<p>46.Mach异常处理会先于UNIX异常处理发生。</p>

<p>47.使用mach_msg在异常端口上创建一个活动监视者。异常处理可以由同一个程序中的另一个线程来完成，不过更有意思的做法是在另一个程序中实现异常处理的部分。</p>

<p>48.Mach是XNU的微内核核心。XNU暴露给用户的主要接口：BSD层。BSD层使用了Mach作为底层的原语和抽象，向应用程序暴露出流行的POSIX API，使得OS X能够和很多其他的UNIX实现兼容。</p>

<p>常见的架构无关的Mach异常</p>

<p>EXC_BAD_ACCESS 内存访问异常，代码包含发生内存访问异常的地址。</p>

<p>EXC_BAD_INSTRUCTION  指令异常，非法或未定义的指令或操作数。</p>

<p>EXC_BREAKPOINT  和跟踪、断点相关的异常</p>

<p>EXC_SYSCALL  系统调用</p>

<p>EXC_CRASH  异常的进程退出</p>

<h2 id="section-6">第十二章  虚拟内存</h2>

<p>1.Mach和所有内核一样，代码中有很大一部分都在负责高效的管理虚拟内存。</p>

<p>2.vm_map：表示任务地址空间内的一个或多个虚拟内存区域。每一个区域都由一个独立的条目vm_map_entry表示，这些条目由一个双向链表vm_map_links维护。</p>

<p>vm_map_entry: 每一个vm_map_entry 都表示了虚拟内存中一块连续的区域。每一个这样的区域都可以通过指定的访问保护权限进行保护（和虚拟内存页面采用同样的权限，即r/w/x权限）。vm_map_entry 通常指向一个vm_object，但是也可以指向一个嵌套的vm_map，即子映射。</p>

<p>vm_object: 用于将vm_map_entry 和实际支撑的内存关联起来。这个数据结构包含一个 vm_page 的链表。</p>

<p>vm_page：vm_page真正表示了vm_object或部分vm_object。vm_page可以有多种状态：驻留内存、交换出、加密、干净和脏等。</p>

<p>3.每一个Mach任务都有一个自己的虚拟内存空间，任务的struct task 中的map字段保存的就是这个虚拟内存空间。</p>

<p>4.purgeable的对象在内存低的情况下可能会丢失，即直接释放，而不是提交到后备存储。</p>

<p>5.Mach的API比POSIX提供的等同API要强大得多，主要是因为Mach API允许一个任务入侵到另一个任务的地址空间。为了访问其他任务的地址空间，要求有相应的权限（具体来说就是任务的端口）。除了这点要求之外，这些调用几乎是无所不能的。事实上，在OS X中很多进程入侵和线程注入技术都依赖这些Mach调用，而不是依赖BSD提供的调用。</p>

<p>6.vmmap()的例子可以很容易扩展得更具有入侵性，比如可以将进程内存映射导出到磁盘，甚至可以写入内存映射。</p>

<p>7.pmap可以嵌套（即包含其他pmap）。这是一个非常常见的技术，共享内存严重依赖这项技术——包括隐式的共享内存（共享库）和显式的共享内存（mmap()）。</p>

<p>8.Mach Zone的概念相当于Linux的内存缓存和Windows的Pool。Zone是一种内存区域，用于快速分配和释放频繁使用的固定大小的对象。Zone的API是内核内部使用的，在用户态不可使用。内核中的Zone和malloc的zone完全不同，后者是C运行时库的一部分，在用户态使用，而且具有很好的文档。</p>

<p>BSD内核zone 直接构建与Mach的zone之上。</p>

<p>9.如果系统内存不足，zone可能会进行垃圾回收。垃圾回收是一个两趟的过程，系统首先扫描所有的zone（跳过标记为不可回收的zone），检查这些zone的空闲列表，判断哪些对象是可以回收的。在第二趟中，将这些对象转换为页面：和非空闲对象共享了一个页面的对象不能被释放，只有页面全部空闲的对象才能被释放。最后，当判定好了可以释放的页面之后，通过kmem_free()释放。</p>

<p>10.所有的内核分配（除了连续物理内存的分配）的路径最终都会到达一个函数，那就是kernel_memory_allocate()。</p>

<p>11.进程的内存需求早晚会超过可用的RAM，系统必须有一种方法能将不活动的页面备份起来并且从RAM中删除，腾出更多的RAM给活动的页面使用，至少暂时能够满足活动页面的需求。在其他的操作系统中，这个工作是由专门的内核线程完成的。例如，Linux中的pdflush和wswapd内核线程。在Mach中，这些专用的任务成为分页器，分页器可以是内核线程，甚至可以是外部的用户态服务程序。</p>

<p>这里提到的分页器及基金实现了各自负责的内存对象的分页操作。这些分页器不会控制系统的分页侧路。分页策略是由vm_pageour守护线程负责的，而vm_pageout守护线程是kernel_bootstrap_thread()完成所有任务之后最后变成的。</p>

<p>12.Mach通过Universal Page List（统一页列表）这个数据结构来维护页的信息，这个列表和分页器的具体实现无关。UPL是连接虚拟地址和实际的物理页面的纽带，有一点类似于Windows的Memory Descriptor List和IOKit的IOMemoryDescriptor。</p>

<p>13.Vnode分页器负责支持文件的内存映射。当内存映射了文件，这些文件的内容需要从文件系统中读取。当内存映射的文件在内存中“脏”了，那么这些脏的页面需要写回文件系统。解密的页面永远不会被标记为脏，因此永远都不会被换出到磁盘上（如果可以从交换文件中提取到明文，那么整个加密就没有意义了）。</p>

<p>14.通过DYLD_INSERT_LIBRARIES强制注入一个库，然后直接从任务中读取内存。这也是为什么尽管App Store的二进制文件被加密，但是iOS应用程序的破解依然很繁荣的原因。</p>

<p>15.pageout守护程序其实不是一个真正的守护程序，而是一个线程。vm_pageout永不返回。初始化之后会派生出两个线程：外部的iothread，和一个垃圾回收线程（其实还有第三个线程，内部的iothread，是默认分页器注册时创建的）。设置完成后，vm_pageout()最终调用vm_pageout_continue()，这个函数周期性的唤醒并执行vm_pageout_scan()。</p>

<p>16.BSD层的Jetsam机制类似于Linux的Low Memory Killer。</p>

<p>17.在iOS中，物理内存非常紧缺而且没有交换空间，这个宏调用了vm_check_memorystatus()，而后者负责唤醒kernel_memorystatus线程，这属于Jetsam机制的一部分。</p>

<p>18.vm_fault()函数调用vm_page_fault()处理实际发生错误（缺页中断）的页面，并且从后备存储中将这个页面取回。实现方法是：查找vm_page对应的vm_object，然后从中获得分页器的端口，分页器的data_request函数负责从后备存储中读入要换入的页面。如果需要的话，换入操作还会对页面进行解密（如果页面在加密的交换文件中），并且验证代码签名。</p>

<p>19.非法访问：访问一个没有映射到进程地址空间（即任务的vm_map）的地址。解引用一个野指针时通常会发生这种错误。发生这种错误时进程会收到SIGSEGV信号。</p>

<p>20.页面保护错误：访问一个映射的地址，但是页面的保护掩码拒绝请求的访问。通常引发这个错误的原因包括跳转到数据段或试图写入（或读取）一个不允许写入（或不允许读取）的页面。发生这种错误时进程会收到SIGBUS信号。</p>

<p>21.dynamic_pager()是一个用户态的守护程序，负责维护系统交换文件，默认情况下交换文件在/private/var/vm/swapfile目录下。内核的default_pager分页器需要在用户态的干预下调整或修改交换条件时，从内核态调用这个守护程序。</p>

<h2 id="bsd">第十三章 BSD层</h2>

<p>1.Mach只是一个微内核。尽管Mach的部分应用程序编程接口（API）也暴露给了用户态，但是开发者主要使用的还是更为流行的POSIX API，而这一套API是通过Mach之上的BSD层实现的。</p>

<p>2.ptrace()属于进程控制相关的调用。</p>

<p>3.在Mach提供的这些原语之上还需要建立一个层次提供像文件、设备、用户和组等重要从抽象。Mach最早选择的这个层次就是BSD，而且延续在XNU中了。</p>

<p>4.BSD采用了两个原语，并且组织成立UNIX世界上著名的进程和线程的概念。</p>

<p>5.BSD的进程可以唯一的映射到Mach任务，但是包含的信息比Mach任务提供的基本调度和统计信息要丰富。其中最值得注意的是，BSD进程包含了文件描述符和信号处理程序的数据。进程还支持复杂的谱系，将进程和其父进程、兄弟进程和子进程连接起来。</p>

<p>6.进程就是容器，二进制代码的实际执行单元是线程。</p>

<p>7.用户态的线程始于对pthread_create的调用。这个函数做的工作并不多，因为主要工作是由bsdthread_create()系统调用完成的，bsdthread_create()只不过是对Mach线程创建的复杂包装。真正的线程创建是由底层的Mach层完成的。bsdthread_create()负责的工作是设置线程栈（如果指定了自定义栈），设置（机器相关的）线程状态，以及设置自定义调度参数（如果提供了的话）等。</p>

<p>8.在UNIX中，进程不能被创建出来，只能通过fork()系统调用复制出来。如果fork()操作失败，fork()只会在调用的进程中返回-1。</p>

<p>9.子进程是父进程的完整复制，除了一下几个重要的例外：</p>

<p>①文件描述符，尽管数值和指向的文件都是一样，但只是原始描述符的副本。这意味着后续对这些描述符修改的调用（例如lseek()和close()）只会影响创建这些描述符的进程。</p>

<p>②资源限制，子进程会继承资源限制，但是资源利用率都设置为0。</p>

<p>③子进程的内存映像看上去是子进程私有的，但是事实上子进程和父进程使用的是内存中相通的物理页面。虚拟内存的私有性是通过设置页面的写时复制标志位来保证的，因此不论是哪个进程试图写入页面时都会引发页错误，从而创建页面的副本，并且重新建立映射。</p>

<p>10.vfork()的进程没有对应的Mach任务和线程。只有在接下来调用了execve()之后才会创建任务和线程。事实上，除了有一个execve()跟在后面之外，vfork()没有存在的意义，因为这个系统调用最初的设计就是为了这个目的。子进程的 task_t 和 thread_t （可以分别通过mach_task_self()和mach_thread_self()获得）完全就是父进程的 task_t 和 thread_t ，vm_map也是如此，只有以后调用 execve()载入一个Mach-O镜像才能最终真正创建一个Mach任务和进程。</p>

<p>11.如果将一个进程比作是一个人体，那么在进程中执行的二进制程序就是这个人体的大脑。只是通过fork()新创建出来的进程也没有多大作用，除非执行镜像通过exec()替换为另一个可执行程序。因此，进程创建的核心在于二进制文件的加载和执行。</p>

<p>12.execsw镜像加载器。进程执行镜像的流程太长了，这里不做记录，还是直接看书吧，</p>

<p>13.所有的镜像加载的路径要么终止在一个错误上，要么最终完成加载Mach镜像。</p>

<p>14.XNU中的Mach-O加载逻辑基本上和NeXT在1988年发明这个格式时差不多。经过这么多年苹果对这个过程做了一些修改，其中主要针对代码解密部分进行修改，但是Mach-O文件格式基础基本没什么变化。</p>

<p>苹果将这个修改封装在 exec_mach_imgact()中了，这是Mach二进制文件注册的处理程序。这个函数首先读取Mach文件头，然后解析其架构（32位或64位）和标志位。这个函数拒绝接受Dylib和Bundle文件——这些文件是由用户态的dyld动态链接器负责的。然后再应用posix_spawn()中的参数（如果有的话）。之后，对二进制进行评估以确保满足当前架构的需求。</p>

<p>处理Mach-O加载的主要函数是load_machfile()。load_machfile()函数负责设置内存映射，这个映射最终会加载各种 LC_SEGMENT 命令加载的数据。</p>

<p>Load_machfile()的核心在于parse_machfile。这个函数负责实际解析加载命令的繁杂工作。</p>

<p>其中，load_code_signature 也是load_machfile()函数里众多流程中的一个步骤，也就是验证代码签名。</p>

<p>经过三趟扫描后，在dlp变量中有一个保存的动态链接器命令，将动态链接器加载到新的映射中，可能要根据ASLR偏移进行调整。load_dylinker()函数会递归的调用parse_machfile()。</p>

<p>如果load_machfile()成功返回了，exec_mach_imgact会继续完成后续的工作。具体操作如下：</p>

<p>①通过调用vm_map_set_user_write_limit设置ulimit-m；</p>

<p>②设置代码签名的标志：</p>

<p>​    CS_HARD：拒绝加载无效页；</p>

<p>​    CS_KILL：如果有任何无效页则杀掉进程；</p>

<p>​    CS_EXEC_*：和上面两个标志位一样，只不过来自execve()。</p>

<p>③设置新的进程名称等等。</p>

<p>需要注意的是，这里并没有强制任何事情：真正的代码签名实施是在Mach的VM页错误处理程序中，通过调用 cs_invalid_page 来强制实施策略。</p>

<p>15.Mach提供了丰富的跟踪机制，其中最重要的就是DTrace。另一个机制ptrace()，这个机制在OS X和iOS（故意的）上只有部分功能有效。</p>

<p>16.BSD和其他UNIX系统提供了一个名为ptrace()的一站式系统调用，这个调用支持进程跟踪和调试。这个系统调用对于调试和逆向工程来说非常有用，例如在Linux中，gdb，系统调用跟踪（strace）和库函数调用跟踪（ltrace）就是用了这个系统调用。</p>

<p>17.在Linux中，ptrace的真正实力在于能够读写其他进程的内存，而XNU的ptrace实现则忽略了这些选项。不过Mach的API也能实现类似的功能。</p>

<p>18.挂起一个进程相当于停止一个进程的执行无限长时间，知道这个进程被恢复。冷冻和解冻的决定权通常都在iOS的加载器SpringBoard手中。</p>

<p>19.Mach已经通过异常机制提供了底层的陷阱处理，而BSD则在异常机制之上构建了信号处理机制。硬件产生的信号被Mach层捕捉，然后转换为对应的UNIX信号。为了维护一个统一的机制，操作系统和用户产生的信号首先被转换为Mach异常，然后再转换为信号。</p>

<p>20.当一个BSD进程（也是用户态进程）被bsdinit_task()函数启动时，这个函数还调用了 ux_handler_init()函数，这个函数设置了一个名为 ux_handler 的Mach内核线程。只有在 ux_handler_init()函数返回之后，bsdinit_task() 才能够注册使用 ux_exception_port。</p>

<p>通过调用 host_set_exception_ports()函数，bsdinit_task() 将所有的Mach异常消息都重定向到 ux_exception_port，这个端口由 ux_handler() 线程持有。由于所有后创建的用户态进程都是PID 1的后台，所以这些进程都会自动继承这个异常端口，相当于 ux_handler() 线程要负责处理系统上 UNIX 进程产生的每一个Mach异常。</p>

<p>ux_handler()函数非常简单，这个函数在进入时首先设置好 ux_handler_port，然后进入一个无限的Mach消息循环。消息循环接收Mach异常消息，然后调用mach_exc_server()处理异常。</p>

<p>mach_exc_server会调用mach_exception_raise()，然后会被mach_catch_exception_raise()捕获，信号处理逻辑就在这里。</p>

<p>21.硬件产生的信号始于处理器陷阱。处理器陷阱是平台相关的。ux_exception负责将陷阱转换为信号。</p>

<p>如果信号不是由硬件产生的，那么这个信号来源于两个API调用：kill()或pthread_kill()。这两个函数分别向进程和线程发送信号。</p>

<p><img src="http://kobe1941.github.io/images/2019/04/10.png" alt="" /></p>

<h2 id="bsd-1">第十四章 BSD的高级功能</h2>

<p>1.虚拟内存管理是在Mach层进行的，Mach控制了分页器，并且向用户态导出了各种vm_和mach_vm_消息接口。而用户态的开发者大部分都只知道标准的POSIX调用，因此需要对这些Mach调用进行封装。类似的，BSD层也使用了自己的内存管理函数。</p>

<p>2.OS X和iOS实现了一个低内存情形的处理机制，成为Jetsam，或者称为Memorystatus。这个机制有点类似于Linux的“out-of-memory”杀手，最初的用途就是杀掉消耗太多内存的进程。Jetsam的名字来源于杀掉消耗内存最多的进程并且抛弃这些进程占用的内存页面的过程。</p>

<p>3.Memorystaus维护了两个列表：一个是快照列表，这个列表保存了系统中所有进程的状态以及消耗的内存页面数；还有一个优先级列表，保存了要杀掉的备选进程。</p>

<p>4.用户态也可以通过pid_suspend()和pid_resume()控制进程的休眠。</p>

<p>5.ASLR：Address Space Layout Randomization 内核地址空间布局随机化。</p>

<p>ASLR对内核代码的影响非常小：代码不再使用固定地址，而是转变为使用相对地址，相对地址是针对程序的当前位置确定的。</p>

<p>6.工作队列是OS X中开发的一项机制，作用是为应用程序提供多线程并扩展到多处理器支持。工作队列是GCD的基础机制。</p>

<p>7.overcommit位表示这个队列可以创建新的线程。通常情况下不建议使用这个策略，因为线程数多于CPU数会降低程序的运行速度。</p>

<p>GCD仅通过dispatch_get_global_queue调用可以接受的一个标志（DISPATCH_QUEUE_OVERCOMMIT）来支持overcommit，但是苹果的文档掩盖了这个事实，宣称这个标志位必须为0。</p>

<p>GCD和libdispatch在工作队列不存在或被禁用时也能工作，在这种情况下，GCD和libdispatch会退而使用线程池模型。</p>

<p>补充：</p>

<p>_dispatch_get_root_queue 会获取一个全局队列，它有两个参数，分别表示优先级和是否支持 overcommit。一共有四个优先级，LOW、DEFAULT、HIGH 和 BACKGROUND，因此共有 8 个全局队列。带有 overcommit 的队列表示每当有任务提交时，系统都会新开一个线程处理，这样就不会造成某个线程过载(overcommit)。——参考自<a href="https://bestswifter.com/deep-gcd/">https://bestswifter.com/deep-gcd/</a></p>

<p>阅读过 GCD 源码的同学会知道，所有默认创建的 GCD queue 都有一个优先级，但其实每个优先级对应两个 queue，比如一个是 default-priority， 那么另一个就是 default-priority-overcommit。dispatch_async 的时候，会首先将任务丢进 default-priority 队列，如果队列满了，就转而丢进 default-priority-overcommit。</p>

<p>在 Mac 系统里，GCD 允许 overcommit，意味着每次 dispatch_async 都会创建一个新线程，即使 over commit 了，这些过量的线程会根据优先级来竞争 CPU 资源。</p>

<p>而在 iOS 系统里，GCD 会控制 overcommit，如果某个优先级队列 over commit 里，那么排在后面的任务就会处于等待状态。移动设备 CPU 资源比较紧张，这种设计合乎常理。</p>

<p>所以如果在 iOS 里创建过多的 serial queue，那么后面提交的任务可能就会一直处于等待状态。这也是为什么我们需要严格控制 queue 的数量和层级关系，最好是 App 当中每个子系统只能分配固定数量和优先级的 queue，从而避免 thread explosion 导致的代码无法及时执行问题。</p>

<p>——参考自<a href="https://zhuanlan.zhihu.com/p/37463055">https://zhuanlan.zhihu.com/p/37463055</a></p>

<p>8.MAC：Mandatory Access Control 强制访问控制。</p>

<p>9.iOS的安全机制比OS X的安全机制严格得多。OS X中代码签名是可选的，而iOS会通过kill-9杀掉任何代码签名不正确的进程。</p>

<p>iOS中“坏警察”是由AMFL扮演的，AMFL在用户态也有一个守护程序：/usr/libexec/amfid。这个守护程序是由launchd启动的。也注册了一个主机特殊端口。</p>

<h2 id="section-7">第十五/十六章 文件系统</h2>

<p>1.ACL：Access Control List 访问控制列表。OS X允许通过chmod()设置和修改ACL。通过 ls -e 可以显示访问控制列表。 ——比如著名的chomd 777就是把文件改为可读可写可执行的状态</p>

<p>2.Unix要求维护3个时间戳：创建事件、修改时间和访问时间。</p>

<p>3.FIFO是UNIX对“具名管道”的实现。通过pipe()系统调用可以创建匿名管道，但是匿名管道不能在无关的进程间共享。</p>

<p>4.底层的文件系统可以是基于表的（例如FAT），也可以基于B树的（例如NTFS和HFS+）。</p>

<p>5.每一个操作系统都有一个自己的原生文件系统。DOS的原生文件系统是FAT，Windows的原生文件系统是NTFS，HFS+是OS X的原生文件系统。</p>

<p>6.内核不能执行压缩操作，而且也没有提供对外部压缩的支持：在内核层只支持解压缩。</p>

<p>7.HFS+使用的是UTF_16编码——双字节Unicode。HFS+也是大小写不敏感的文件系统。OS X 默认使用HFS+，iOS使用启动了大小写敏感的HFSX。</p>

<p>8.日志是磁盘中一块特殊的区域，用户看不见这个区域，文件系统在向磁盘提交事务之前会将事务记录在这个区域中。如果修改事务被成功提交，那么这些事务就会从日志中删除。但是如果发生了崩溃，文件系统可以快速恢复到一致的状态——要么重放日志（即提交所有记录的事务），要么回滚日志（如果包含未完成的事务）。</p>

<p>日志并不是解决数据丢失的灵丹妙药。然而，日志可以显著的减少系统崩溃导致文件系统无法使用的情况。</p>

<p>9.HFS+有一项很有意思很特别的特性是能够动态适应频繁访问的文件。HFS+为每一个文件维护一个热度值。HFS+能够在工作时进行碎片整理工作。</p>

<p>10.B树是一些文件系统构建的基础，例如NTFS（Windows）、Ext4（Linux）和苹果的HFS及HFS+。</p>

<p>11.任何文件系统最基本的概念就是用于保存和取得文件的机制。需要满足的需求包括：搜索、插入、更新和随机访问。</p>

<p>大部分文件系统都采用了基于树的方案。根据树形结构的设计，上述的要求都能满足，而且还很自然的提供了层次结构，这是平坦的表示结构无法提供的。</p>

<p>12.B数可以看成是二叉树的扩展，相似的地方在于都采用了树形结构，而不同的地方在于B树的节点可以有任意数据的子节点——定义为m——而不只是两个子节点。这种结构可以帮助限制树的深度，从log2(N)（典型的二叉树搜索时间复杂度），到最优情况的logm(N)以及最坏情况的logm/2(N)。</p>

<p>13.和所有的树一样，B树由节点组成，但是和其他树不一样的地方在于，B树的节点可以有具体的子类型，或称为kind。不同的节点类型可以保存不同的数据，但是所有类型的节点都来源于一个基本类型（可以看成是一个基类）。</p>

<p>为了遍历所有的记录，在节点尾部向头部方向依次保存了指向每一条记录的指针，其中也包含节点中包含的任何空闲空间使用的空记录的指针。</p>

<p>14.HFS+的B树总是有一个固定的深度。也就是说，所有的叶子节点都在同一层上。</p>

<p>15.当HFS+挂载时启动了日志功能，那么还会启用一个日志文件。</p>

<h4 id="iokit">其他部分  网络协议栈/内核扩展模块/IOKit</h4>

<p>1.一般的Cocoa开发者并不需要了解套接字相关的知识。因为CoreFoundation通过CFNetwork提供了封装了套接字的CFSocket和CFStream，此外还提供了一些协议的封装，例如CFFTP、CFHTTP等。尽管如此，BSD套接字是XNU中所有网络组件的核心（实际上也是所有现代操作系统的核心）。</p>

<p><img src="http://kobe1941.github.io/images/2019/04/11.png" alt="" /></p>

<p>2.模块化设计是可扩展性之母。</p>

<p>3.代码签名，如今已经被大多数系统采纳为标准。Windows是一个典型实例，只允许加载具有合法数字签名的驱动程序。在控制权转交给模块入口点之前，内核会验证代码签名，代码签名保存在附加的证书中。证书必须通过私钥签名，内核已知公钥，内核也可以通过一个信任链获得这样一个秘钥。</p>

<p>早在iBoot阶段，未经苹果签名的代码就不能被加载。</p>

<p>4.预链接是苹果在OS X和iOS中使用的方法。引导加载器不按照先加载内核，再以一定顺序加载kext的方式进行加载，而是加载一个kernelcache文件。——好处是加载的速度快得多，并且kernelcache可以添加签名，甚至还可以加密，一旦加载了kernelcache，就可以禁止所有kext加载，这样可以阻断代码进入iOS内核的合法通道。</p>

<p>5.IOKit有一个顶层的抽象基类是OSObject。</p>

<p>6.IOKit提供了一个工作循环（work loop）模型，有一点类似于Objective-C的runloop（或Mach的消息循环）。简而言之，工作循环是一个不断处理事件的消息处理循环。通过使用工作循环可以极大的简化并发问题，而且通常可以避免对锁的使用，锁是会影响性能的。</p>

<p>7.IOKit采用了NeXT的runloop模型，用户态开发者应该会想到CFRunLoop。IOKit版本的runloop成为IOWorkloop，基本思想是一样的：提供一个单线程且线程安全的机制处理所有类型的事件，如果不采用这种机制则是异步的。工作循环的访问被一个互斥体保护，因此不需要考虑可重入的问题以及线程安全的问题。不过要注意的是，不能保证工作循环确实是一个线程。也就是说，工作循环的迭代可能会运行在系统中另一个线程的上下文中。</p>

<p>8.上下文切换：是另一种类型的控制权转移，上下文切换指的是将当前正在执行的线程的上下文切换为另一个线程的上下文。</p>

<p>9.ARM和Intel处理器都在处理器层次提供了线程的支持。事实上，这也是为什么现代操作系统都不调度进程，而是调度线程的原因。</p>

<p>10.在现代操作系统中，实现并发的先决条件是具有能够提供安全锁定机制的能力，通过这种方式能够同步共享资源的访问。同步机制通常都依赖于硬件的支持，因此在ARM和Intel架构上的实现是不同的。Mach底层的hw_lock_lock()函数的实现时候一个很好的示例。从内核的角度看，这个函数提供的方法总是一直的：快速的自旋锁。</p>

<p>11.原子操作是和锁非常接近的功能。院子操作是一类保证了原子性（atomicity，几不可中断性）的操作。原子操作常作为锁操作的底层机制（因为必须以原子的方式访问锁），而且经常可以替代锁的使用（当要保护的对象为机器字大小时）。</p>

<p>原子不一定意味着单周期，原子的意思只是说CPU保证在访问的过程中不会被打断。</p>

<p>12.为了能够最优化的利用内部组件（例如ALU，FPU和加载/存储组件），现代的CPU会采用乱序的方式执行指令。然而在某些情况下，乱序执行可能会在程序中引入bug。在这种情况下，可以使用屏障（barrier）指令来确保程序执行到某个点时所有访问操作都完成了。——比如iOS的内存屏障</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《现代操作系统》]]></title>
    <link href="http://kobe1941.github.io/blog/modern-operate-system.html"/>
    <updated>2019-02-11T22:17:58+08:00</updated>
    <id>http://kobe1941.github.io/blog/modern-operate-system</id>
    <content type="html"><![CDATA[<p>非常棒的一本书，可以把很多知识点给串起来，对于操作系统的历史发展和基本运行规则有比较清晰的描述。对非计算机科班的孩纸特别友好。个人认为第二章进程和线程，第三章存储管理，第六章死锁，第十章Linux实例研究都是非常值得读的章节，对实际理解操作系统也非常有用。当然如果涉及到视频，第七章的多媒体也不错。</p>

<p>存储管理这一章有一个小节介绍了很多种页面置换算法，在实际应用中，iOS很多第三方的框架有用到，比如YYCache用的LRU算法。</p>

<!--more-->

<h2 id="section">名词解释</h2>

<p>BIOS：Basic Input Output System 基本输入输出系统；</p>

<p>BSD：Berkeley SoftWare Distribution 伯克利软件发布版本；</p>

<p>POSIX：Portable Operating System Interface of UNIX，可移植操作系统接口，前三个字母代表可移植操作系统，后缀IX用来使这个名字与Unix的构词相似；</p>

<p>MMU：Memory management Unit 内存管理单元</p>

<p>IDE：Integrated Drive Electronics 集成驱动电子设备</p>

<p>ADSL：非对称数字用户环线</p>

<p>JPEG：Joint Photographic Experts Group 联合摄影专家组</p>

<p>MPEG：Motion Picture Experts Group 运动图像专家组</p>

<p>VCR：Video Cassette Recorder 录像机</p>

<p>RPC：Remote Procedure Call 远程过程调用</p>

<p>TCP：Transmission Control Protocol 传输控制协议</p>

<p>DNS：Domain Name System 域名系统</p>

<p>URL：Uniform Resource Locator 统一资源定位符</p>

<p>HTTP：Hypertext Transfer Protocol 超文本传输协议</p>

<p>shell：命令行界面</p>

<p>PID：Process Identifer 进程标识符</p>

<p>PAE：物理地址扩展</p>

<p>NFS：Network File System 网路文件系统</p>

<p>LPC：Local Procedure Call  本地过程调用</p>

<p>APC：Asynchronous Procedure Calls 异步过程调用</p>

<p>ACL：访问权限控制列表</p>

<p>ALPC：Advanced Local Procedure Call 高级本地过程调用</p>

<p>VAD：Vritual Address Descriptor 虚拟地址描述符</p>

<h2 id="section-1">第二章  进程与线程</h2>

<p>1.进程间通信的几种方式：管道pipe，信号量，互斥量（信号量的简化版本），管程，消息传递。其中信号量和互斥量是属于共享内存的方式，比如信号量可以存放在内核中，只能通过系统调用来访问。如果没有共享的途径，则可以使用共享文件。</p>

<p>——似乎kill(pid,signal)这个系统调用，可以发送信号给别的进程，算进程间通信方式的一种嘛？——是的</p>

<p>——信号（signal）：信号是一种比较复杂的通信方式，用于通知接收进程某一事件已经发生。</p>

<p>——套接字socket也算一种进程间的通信机制？——对，只不过一般是两台不同机器上的进程之间的通信。</p>

<p>管道pipe是一种虚文件，它可连接两个进程。当进程A想对进程B发送数据时，它把数据写到管道上，仿佛管道就是输出文件一样。进程B可以通过读该管道而得到数据，仿佛该管道就是一个输入文件一样。</p>

<table>
  <tbody>
    <tr>
      <td>一个例子： git log</td>
      <td>grep xyz</td>
    </tr>
  </tbody>
</table>

<p>把进程git 的输出 作为进程grep的输入。</p>

<p>进程间通信方式的扩展阅读：<a href="https://www.jianshu.com/p/c1015f5ffa74">https://www.jianshu.com/p/c1015f5ffa74</a></p>

<p>2.对于单核处理器来说，如果某个进程需要从内存中读出一个字（需要花费多个时钟周期），多线程CPU则可以切换至另一个线程。多线程不提供真正的并行处理。在任一时刻只有一个进程在运行，但是线程的切换时间则减少到纳秒数量级。</p>

<p>在Unix系统中，使用fork 系统调用来创建新的进程。在调用了fork后，这两个进程（父进程和子进程）拥有相同的存储映像、同样的环境字符串和同样的打开文件。通常，子进程接着执行一个execve或一个类似的系统调用，以修改其存储映像并运行一个新的程序。</p>

<p>在Unix中，进程和它的所有子女和后裔共同组成一个进程组；相反，Windows则没有进程层次的概念，所有的进程地位都是相同的。</p>

<p>3.一个进程是某种类型的一个活动，它有程序，输入，输出以及状态；如果一个程序运行了两遍，则算作两个进程。 ——这是微信可以多开的基本原理。</p>

<p>4.停留在后台处理诸如电子邮件，web页面，新闻，打印之类活动的进程称为守护进程；在Unix中可以用ps指令列出正在运行的进程。</p>

<p>5.不同的进程有不同的地址空间，父进程和子进程也有不同的地址空间。</p>

<p>6.进程有三种状态：运行态（此时占用CPU），就绪态（可运行，但是没有CPU分配给它）和阻塞态（除非外部事件发生，否则不能运行）。</p>

<p>Unix中，当一个进程从管道或设备文件（例如终端）读取数据时，如果没有有效的输入存在，则进程会被自动阻塞。</p>

<p>7.为了实现进程模型，操作系统维护着一张表格——进程表（数组或链表结构）；每个进程占用一个表项，该表项包含了进程状态的重要信息，包括程序计数器，堆栈指针，内存分配情况，所打开文件的状态，账号和调度信息，以及其他在进程由运行态转换到就绪态或阻塞态时必须保存的信息。</p>

<p>每个计算都有一个被保存的状态，存在一个会发生且使得相关状态发生改变的事件集合，我们把这类设计称为有限状态机。</p>

<p>多线程使得顺序进程的思想得以保留下来，这种顺序进程阻塞了系统调用（如磁盘IO），但是仍旧实现了并行性。</p>

<p>8.进程模型基于两种独立的概念：资源分组与执行。</p>

<p>9.进程用于把资源集中到一起，而线程则是在CPU上被调度执行的实体。资源管理的单位是进程而不是线程。</p>

<p>10.所有的线程都有完全一样的地址空间，这意味着他们也共享同样的全局变量。线程可以在用户空间或内核中实现。</p>

<p>线程概念试图实现的是，共享一组资源的多个线程的执行能力，以便这些线程可以为完成某一任务而共同工作。</p>

<p>每个线程的堆栈有一帧，供各个被调用但是还没有从中返回的过程使用。在该帧中存放了相应过程的局部变量以及过程调用完成之后使用的返回地址。</p>

<p>11.用户级线程切换，保存该线程状态的过程和调度程序都只是本地过程，所以其要比内核级线程切换快很多，同时它允许每个进程有自己定制的调度算法。</p>

<p>12.在内核中创建或撤销线程的代价比较大。系统调用的代价比较大。</p>

<p>13.信号是发给进程的而不是线程的。</p>

<p>一个消息的到达导致系统创建一个处理该消息的线程，这种线程称为弹出式线程。因为线程相当新，没有历史包袱，这类线程可以快速创建。使用弹出式线程的结果是，消息到达与处理之间的时间非常短。</p>

<p>在内核空间中运行弹出式线程通常比在用户空间中容易且快捷，而且内核空间中的弹出式线程可以很容易访问所有的表格和IO设备。不过出错的内核线程会比出错的用户线程造成更大的损害。</p>

<p>14.把对共享内存进行访问的程序片段称作临界区域。</p>

<p>15.只有在有理由认为等待时间是非常短的情形下，才使用忙等待。用于忙等待的锁，称为自旋锁。</p>

<p>使用TSL或XCHG指令来防止几个CPU同时访问一个信号量，这与生产者或消费者使用忙等待来等待对方腾出或填充缓冲区是完全不同的。信号量操作仅需几个毫秒，而生产者或消费者则可能需要任意长的时间。</p>

<p>供两个或多个进程使用的信号量，初始值为1，保证同时只有一个进程可以进入临界区，称为二元信号量。</p>

<p>信号量mutex用于互斥，它用于保证任一时刻只有一个进程读写缓冲区和相关的变量。</p>

<p>信号量的另一种用途是用于实现同步。信号量full和empty用来保证某种时间的顺序发生或不发生。在本例中，他们保证当缓冲区满的时候生产者停止运行，以及当缓冲区空的时候消费者停止运行，这种用法与互斥是不同的。</p>

<p>如果不需要信号量的计数能力，又是可以使用信号量的一个简化版本，称为互斥量。</p>

<p>如果多个线程被阻塞在同一个互斥量上，当互斥量被解锁时，将随机选择一个线程运行并允许它获得锁。</p>

<p>如果两个或多个进程共享其全部或大部分的地址空间，进程和线程之间的差别就变得模糊起来。当然，共享一个公共地址空间的两个进程仍旧有各自的打开文件，报警定时器以及其他一些单个进程的特性个，而在单个进程中的线程，则共享进程的全部的特性。另外，共享一个公共地址空间的多个进程决不会拥有用户级线程的效率。</p>

<p>16.管程是一种高级同步原语，一个管程是一个由过程、变量及数据结构等组成的一个集合，他们组成一个特殊的模块或软件包。</p>

<p>17.任一时刻管程中只能有一个活跃进程。</p>

<p>18.进入管程时的互斥由编译器负责，但通常的做法是用一个互斥量或者二元信号量。</p>

<p>19.消息传递是系统调用。</p>

<p>20.进程切换的代价是比较高的。首先用户态必须切换到内核态；然后保存当前进程的状态，然后通过运行调度算法选定一个新进程，之后将新进程的内存映像重新装入MMU，之后进程开始运行。进程切换还要使整个内存告诉缓存失效，强迫缓存从内存中动态装入两次（进入内核一次，离开内核一次）。</p>

<p>21.尽管有一些不同，但许多适用于进程调度的处理方法也同样适用于线程调度。当内核管理线程的时候，调度经常是按线程的，与线程所属的进程基本或根本没有关联。</p>

<p>22.批处理系统中的调度算法：FIFO先来先服务，最短作业优先（耗时短），最短剩余时间优先。</p>

<p>23.交互式系统的调度算法：轮转调度，优先级调度，多级队列，公平分享等等。</p>

<p>24.进程切换的消耗：保存和装入寄存器值及内存映像，更新各种表格和列表，清除和重新调入内存高速缓存等。</p>

<p>25.用户级线程和内核级线程之间的差别在于性能。用户级线程的线程切换需要少量的机器指令，而内核级线程需要完整的上下文切换，修改内存映像，使告诉缓存失效，这导致了若干数量级的延迟。</p>

<p>26.内核级线程中，内核从来不了解每个线程的作用（虽然它们被赋予了不同的优先级）。一般而言，应用定制的线程调度程序能够比内核更好的满足应用的需要。</p>

<p>27.几乎所有的操作系统都把一个进程视为一个容器，该容器用以聚集相关的资源，如地址空间、线程、打开的文件、保护许可等。</p>

<h2 id="section-2">第三章  存储管理</h2>

<p>1.操作系统中管理分层存储器体系的部分称为存储管理器。它的任务是有效的管理内存，即记录哪些内存是正在使用的，哪些内存是空闲的；在进程需要时为其分配内存，在进程使用完后释放内存。</p>

<p>——所有APP内部的内存泄漏，在APP被杀掉后，都会不复存在，因为APP所在的地址空间里的内存page会悉数被操作系统回收标记为空闲内存。安卓越用越卡是因为很多APP开了很多的后台服务service，或者干脆后台重启。</p>

<p>2.最底层的高速缓存方案由硬件来完成。</p>

<p>3.地址空间为程序创造了一种抽象的内存。地址空间是一个进程可用于寻址内存的一套地址集合。每个进程都有一个自己的地址空间，并且这个地址空间独立于其他进程的地址空间（除了在一些特殊情况下进程需要共享它们的地址空间外）。</p>

<p>——动态库的地址空间是独立的，是在App加载动态库的时候动态分配的（这也是可以被多个APP进程共享的基础）。而静态库是在链接的时候就已经确定了地址。比如有一个单例 [Preference sharedInstance]，Preference是静态库P提供的，你的App在使用这个，然后你开发了一个动态库B，B也在使用Preference这个静态库P。那么你以为你们的单例是同一个实例么，遗憾的告诉你，不是。因为静态库P既会链接到App中，也会编译链接到动态库B中，也就是这两个模块中分别存在一份P的完整代码编译结果，单例 [Preference sharedInstance]会在各自模块的地址空间分配一个实例。</p>

<p>4.地址空间可以不是数字的。一套“.com”的互联网域名也是地址空间。</p>

<p>5.基址寄存器和界限寄存器的机制，是简单的把每个进程的地址空间映射到物理内存的不同部分。程序的起始物理地址装载到基址寄存器中，程序的长度装载到界限寄存器中。每次一个进程访问内存，取一条指令，读或写一个数据字，CPU硬件会把地址发送到内存总线前，自动把基址值加到进程发出的地址值上。</p>

<p>6.有两种处理内存超载的通用方法。最简单的策略是交换技术，即把一个进程完整调入内存，使该进程运行一段时间，然后把它存回磁盘。空闲进程主要存储在磁盘上。另一种策略是虚拟内存，该策略甚至能使程序在只有一部分被调入内存的情况下运行。（缺页会产生中断，从而读取缺失的页面）</p>

<p>7.交换技术在内存中产生了多个空闲区，通过把所有的进程尽可能向下移动，有可能将这些小的空闲区合成一大块。该技术称为内存紧缩。这个操作通常不进行，因为它要耗费大量的CPU时间。</p>

<p>8.若一个进程在内存中不能增长，而且磁盘上的交换区也满了，那么这个进程只有挂起直到一些空间空闲，或者可以结束该进程。</p>

<p>9.为了减少因内存区域不够而引起的进程交换和移动所产生的开销，可以当换入或移动进程时为它分配一些额外的内存。然而，当进程被换出到磁盘上时，应该只交换进程实际上使用的内存中的内容，将额外的内存交换出去是一种浪费。</p>

<p>10.空闲内存管理的两种方式：位图和链表。</p>

<p>11.在决定把一个占k个分配单元的进程调入内存时，存储管理器必须搜索位图，在位图中找出有k个连续为0的串，查找位图中指定长度的连续0串是耗时的操作（因为在位图中该串可能跨越字的边界），这是位图的缺点。</p>

<p>12.另一种记录内存使用情况的方法是，维护一个记录已分配内存段和空闲内存段的链表。链表中的每一个结点都包含以下域：空闲区或进程的指示标志，起始地址，长度和指向下一结点的指针。</p>

<p>13.段链表使用双向链表比单向链表更方便，更容易找到上一个结点，并检查是否可以合并。</p>

<p>14.首次适配算法：存储管理器沿着段链表进行搜索，直到找到一个足够大的空闲区，除非空闲区大小和要分配的空间大小正好一样，否则将该空闲区分为两部分，一部分供进程使用，另一部分形成新的空闲区。它速度很快，因为它尽可能少的搜索链表结点。</p>

<p>15.最佳适配算法：搜索整个链表，找出能够容纳进程的最小的空闲区。因为每次调用都要搜索整个链表，所以它要比首次适配算法慢。让人感到意外的是它比首次适配算法或下次适配算法浪费更多的内存，因为它会产生大量无用的小空闲区。</p>

<p>16.快速适配算法：它为哪些常用大小的空闲区维护单独的链表。快速适配算法寻找一个指定大小的空闲区是十分快速的，但当一个进程终止或者被换出时，寻找它的相邻块，查看是否可以合并的过程是非常耗时的。</p>

<p>17.虚拟内存：每个程序拥有自己的地址空间，这个空间被分割成多个块，每一块称作一页page。每一页有连续的地址范围。这些页被映射到物理内存，但并不是所有的页都必须在内存中才能运行程序。当程序引用到一部分在物理内存中的地址空间时，由硬件立刻执行必要的映射。当程序引用到一部分不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的指令。</p>

<p>18.从某个角度来讲，虚拟内存是对基址寄存器和界限寄存器的一种综合。</p>

<p>19.虚拟地址空间按照固定大小划分称为页面page的若干单元。在物理内存中对应的单元称为页框page frame。页面和页框的大小通常是一样的。现有操作系统常用的页大小一般从512字节到64kb。目前一般4kb或8kb的比较多。</p>

<p>20.当程序访问了一个未映射的页面，MMU注意到该页面没有被映射，就会产生一个缺页中断。操作系统找到一个很少使用的页框且把它的内容写入磁盘（如果它不在磁盘上）。随后把需要访问的页面读到刚才回收的页框中，修改映射关系，然后重新启动引起陷阱的指令。</p>

<p>21.虚拟地址到物理地址的映射可以概括如下：虚拟地址被分成虚拟页号（高位部分）和偏移量（低位部分）两部分。</p>

<p>22.页表的目的是把虚拟页面映射为页框。</p>

<p>23.不论是读还是写，系统都会在该页面被访问时设置访问位。它的值被用来帮助操作系统在发生缺页中断时选择要被淘汰的页面。不再使用的页面要比正在使用的页面更适合淘汰。</p>

<p>24.虚拟内存本质上是用来创造一个新的抽象概念——地址空间。这个概念是对物理内存的抽象，类似于进程是对物理机器（CPU）的抽象。虚拟内存的实现，是将虚拟地址空间分解成页，并将每一页映射到物理内存的某个页框或者（暂时）解除映射。</p>

<p>25.当发生缺页中断时，操作系统必须在内存中选择一个页面将其换出内存，以便为即将调入的页面腾出空间。如果要换出的页面在内存驻留期间已经被修改过，就必须把它写回磁盘以更新该页面在磁盘上的副本；如果该页面没有被修改过，那么它再磁盘上的副本就已经是最新的，不需要回写。</p>

<p>26.页面置换算法对比</p>

<p><img src="http://kobe1941.github.io/images/2019/02/11/1.png" alt="" /></p>

<p>27.一个进程正在使用的页面的集合称为它的工作集。</p>

<p>28.不少分页系统都会设法跟踪进程的工作集，以确保让进程运行以前，它的工作集就已经在内存中了。该方法称为工作集模型，其目的在于大大减少缺页中断率。在让进程运行前预先装入其工作集页面也称为预先调页。预先调页就是在程序继续运行之前预先装入推测出的工作集的页面。请注意工作集是随着时间变化的。</p>

<p>29.基于工作集的页面置换算法，基本思路就是找出一个不在工作集中的页面并淘汰它。</p>

<p>30.管理内存动态分配的一种方法是使用PFF（page fault frequency，缺页中断率）算法。它指出了何时增加或减少分配给一个进程的页面，但却完全没有说明在发生缺页中断时应该替换掉哪一个页面，它仅仅控制分配集的大小。</p>

<p>31.减少竞争内存的进程数的一个好方法是将一部分进程交换到磁盘，并释放他们所占有的所有页面。即使是使用分页，交换也是需要的，只是现在交换的是用来减少对内存潜在的需求，而不是收回它的页面。一些进程被周期性的从磁盘调入，而其他一些则被周期性的交换到磁盘。</p>

<p>32.当内存中的进程数过低的时候，CPU可能很长的时间都处于空闲状态。考虑到该因素，在决定交换出哪个进程时不光要考虑进程大小和分页率，还要考虑它的特性（CPU密集型还是IO密集型）以及其他进程的特性。</p>

<p>33.几个不同的用户同时运行一个程序是很常见的。那些只读的页面（诸如程序文本）可以共享，但是数据页面则不能共享。</p>

<p>34.共享数据要比共享代码麻烦，但也不是不可能。特别是在Unix中个，在进行fork系统调用后，父进程和子进程要共享程序文本和数据。但只要有一个进程更新了一点数据，就会触发只读保护，并引发操作系统陷阱。然后会生成一个该页的副本，这样每个进程都有自己的专用副本。两个复制都是可以读写的，随后对任何一个副本的写操作都不会再引发陷阱。这就是写时复制，它通过减少复制而提高的性能。</p>

<p>35.一个更加通用的技术是共享库，在Windows中称为DLL或动态链接库。</p>

<p>36.当一个程序和共享库链接时，链接器没有加载被调用的函数，而是加载了一小段能够在运行时绑定被调用函数的存根例程。依赖于系统和配置信息，共享库和程序一起被装载，或者在其所包含函数第一次被调用时被装载。当一个共享库被装载和使用时，整个库并不是被一次性的读入内存。而是根本需要，以页面为单位装载的，因此没有被调用到的函数是不会被装载到内存中的。</p>

<p>37.除了可以使可执行文件更小，节省内存空间之外，共享库还有一个优点：如果共享库中的一个函数因为修正一个bug被更新了，那么并不需要重新编译调用了这个函数的程序。</p>

<p>38.库被装载到的物理地址与这个库是否为共享库是没有任何关系的。因为所有的页面都被MMU硬件从虚拟地址映射到了物理地址。</p>

<p>39.在编译共享库时，用一个特殊的编译选项告知编译器，不要产生使用绝对地址的指令，相反，只产生使用相对地址的指令。只使用相对偏移量的代码被称作位置无关代码。</p>

<p>40.共享库实际上是一种更为通用的机制——内存映射文件的一个特例。这个机制的思想是：进程可以通过发起一个系统调用，将一个文件映射到其虚拟地址空间的一部分。在多数实现中，在映射共享的页面时不会实际读入页面的内容，而是在访问页面时才会被每次一页的读入。</p>

<p>41.如果两个或两个以上的进程同时映射了一个文件，它们就可以通过共享内存来通信。这个机制提供了一个进程之间的高带宽通道。如果内存映射文件可用，共享库就可以使用这个机制。</p>

<p>42.为保证有足够的空闲页框，很多分页系统有一个称为分页守护进程的后台进程，它在大多数时候睡眠，但定期被唤醒以检查内存的状态。如果空闲叶框过少，分页守护进程通过预定的页面置换算法选择页面换出内存。如果这些页面装入内存后被修改过，则将它们写回磁盘。</p>

<p>43.在任何情况下，页面中原先的内容都被记录下来。当需要使用一个已被淘汰的页面时，如果该叶框还没有被覆盖，将其从空闲叶框缓冲池中移出即可恢复该页面。</p>

<p>44.允许程序员对内存映射进行控制的一个原因就是为了允许两个或者多个进程共享同一部分内存。如果程序员可以对内存区域进行命名，那么就有可能实现共享内存。通过让一个进程把一片内存区域的名称通知另一个进程，而使得第二个进程可以把这片区域映射到它的虚拟地址空间中去。</p>

<p>45.页面共享也可以用来是吸纳高性能的消息传递系统。一般传递消息的时候，数据被从一个地址空间复制到另一个地址空间，开销很大。如果进程可以控制他们的页面映射，就可以这样来发送一条消息：发送进程清除那些包含消息的页面的映射，而接收进程把它们映射进来。这里只需要复制页面的名字，而不需要复制所有数据。</p>

<p>46.分布式共享内存：该方法允许网络上的多个进程共享一个页面集合，这些页面可能（而不是必要的）作为单个的线性共享地址空间。</p>

<p>47.当调度一个进程执行时，必须为新进程重置MMU，刷新TLB，以清除以前的进程遗留的痕迹。</p>

<p>48.当进程退出的时候，操作系统必须释放进程的页表、页面和页面在硬盘上所占用的空间。如果某些页面是与其他进程共享的，当最后一个使用它们的进程终止的时候，才可以释放内存和磁盘上的页面。</p>

<p>49.锁定内存中的页面：一种解决方法是锁住正在做IO操作的内存中的页面以保证它不会被移出内存。锁住一个页面通常称为在内存中钉住页面。另一种方法是在内核缓冲区完成所有的IO操作，然后再将数据复制到用户页面。</p>

<p>50.在磁盘上分配页面空间的最简单的算法是在磁盘上设置特殊的交换区，甚至从文件系统划分一块独立的磁盘（以平衡IO负载）。大多数Unix是这样处理的。在这个分区里没有普通的文件系统，这样就消除了将文件偏移转换成块地址的开销。取而代之的是，始终使用相应分区的起始块号。</p>

<p>51.由于程序正文通常是只读的，当内存资源紧张、程序页不得不移出内存时，尽管丢弃它们，在需要的时候再从可执行文件读入即可。共享库也可以用这个方式工作。</p>

<p>52.编译器编译过程中会创建的表：</p>

<p><img src="http://kobe1941.github.io/images/2019/02/11/2.png" alt="" /></p>

<p>53.分段也有助于在几个进程之间共享过程和数据。这方面的一个常见的例子就是共享库。在分段系统中，可以把图形库放到一个单独的段中由各个进程共享，从而不再需要每个进程的地址空间都保存一份（比如iOS的UIKit和Foundation）。</p>

<p>54.每个段只包含了一种类型的对象，所以这个段就可以设置针对这种特定类型的合适的保护。</p>

<p>55.分段和分页的实现本质上不同的：页面是定长的而段不是。（比如page一页一般4kb）</p>

<p>56.分段和分页的结合：MULTICS。一个段描述符包含了一个段是否在内存中的标志，只要一个段的任何一部分在内存中这个段就被认为是在内存中，并且它的页表也会在内存中。MULTICS中的一个地址由两部分构成：段和段内地址。段内地址又进一步分为页号和页内的字。</p>

<p>57.另一个分段和分页结合例子是Intel Pentium处理器。Pentium处理器中虚拟内存的核心是两张表，即LDT（局部描述符表）和GDT（全局描述符表）。每个程序都有自己的LDT，但是同一台计算机上的所有程序共享一个GDT。LDT描述局部于每个程序的段，包括其代码、数据、堆栈等；GDT描述系统段，包括操作系统本身。</p>

<p>58.系统通过交换技术可以同时运行总内存占用超过物理内存大小的多个进程，如果一个进程没有内存空间可用，它将会被换到磁盘上。内存和磁盘上的空闲空间可以使用位图或空闲区链表来记录。</p>

<p>59.虚拟内存在最简单的形式中，每一个进程的地址空间被划分为同等大小的块，称为页面page，页面可以被放入内存中任何可用的页框内。有多重页面置换算法，其中两个比较好的算法是老化算法和工作集时钟算法。</p>

<p>60.为了使分页系统工作良好，仅选择算法还是不够的，还要关注诸如工作集的确定、存储器分配策略以及所需要的页面大小等问题。</p>

<p>61.分段可以帮助处理在执行过程中大小有变化的数据结构，并能简化连接和共享。分段还有利于为不同的段提供不同的保护。有时可以把分段和分页结合起来，以提供一种二维的虚拟内存。</p>

<h2 id="section-3">第四章   文件系统</h2>

<p>1.长期存储信息的三个基本要求：①能够存储大量的信息。②使用信息的进程终止时，信息仍旧存在。③必须能使多个进程并发存取有关信息。</p>

<p>2.进程与线程，地址空间和文件，这些抽象概念均是操作系统中最重要的概念。</p>

<p>3.文件是进程创建的信息逻辑单元。如果能把每个文件看成一种地址空间，那么读者就离理解文件的本质不远了。</p>

<p>4.文件是受操作系统管理的。有关文件的构造、命名、存取、使用、保护、实现和管理方法都是操作系统设计的主要内容。操作系统中处理文件的部分称为文件系统file system。</p>

<p>5.在Unix里，如果有文件扩展名，则扩展名长度完全由用户决定，一个文件甚至可以包含两个或更多的扩展名。当然Unix中文件扩展名只是一种约定，操作系统并不强迫采用它。相反，Windows对扩展名赋予含义。</p>

<p>6.普通文件中包含有用户信息，一般分为ASCII文件和二进制文件。Unix系统还有字符特殊文件和块特殊文件。字符特殊文件和输入/输出有关，用于串行IO类设备，如终端、打印机、网络等。块特殊文件用于磁盘类设备。</p>

<p>7.ASCII文件的最大优势是可以显示和打印，还可以用任何文本编辑器进行编辑。如果以ASCII文件作为输入输出，就很容易把一个程序的输出作为另一个程序的输入，如shell管道。</p>

<p>8.文件头以所谓的魔数（magic number）开始，表明该文件是一个可执行的文件（防止非这种格式的文件偶然运行）。</p>

<p>9.能够以任何次序读取其中字节或记录的文件称作随机存取文件。有两种方法来指示从何处开始读取文件，一种是每次read操作都给出开始读文件的位置；另一种是用一个特殊的seek操作设置当前位置，在seek操作后，从这个当前位置顺序的开始读文件。</p>

<p>10.文件都有文件名和数据。操作系统还会保存其他与文件相关的信息，如文件的创建日期和时间、文件大小等。这些附加的信息称为文件属性，有些人称之为元数据。</p>

<p>11.文件的临时标志表明当创建该文件的进程终止时，文件会被自动删除。</p>

<p>12.很多系统限制进程打开文件的个数，以鼓励用户关闭不再使用的文件。磁盘以块为单位写入，关闭文件时，写入该文件的最后一块，即使这个块还没有满。</p>

<p>13.增量编译：编译时检查目标文件的修改时间，以实现最小编译。</p>

<p>14.在很多系统中，目录本身也是文件。</p>

<p>15.如果路径名的第一个字符是分隔符，则这个路径就是绝对路径。Unix中分隔符是“/”，Windows中是“\”，MULTICS中则是”&gt;”。</p>

<p>16.每个进程都有自己的工作目录，这样在进程改变工作目录并退出后，其他进程不会受到影响，文件系统也不会有改变的痕迹。</p>

<p>17.link连接技术允许在多个目录中出现同一个文件。有时称为硬连接。</p>

<p>18.文件系统存放在磁盘上。多数磁盘划分为一个或多个分区，每个分区中有一个独立的文件系统。磁盘的0号扇区称为主引导记录（MBR），用来引导计算机。在MBR的结尾是分区表。该表给出了每个分区的起始和结束地址。表中的一个分区被标记为活动分区。在计算机被引导时，BIOS读入并执行之。引导块中的程序将装载该分区的操作系统。</p>

<p>19.超级快中的典型信息包括：确定文件系统类型用的魔数，文件系统中数据块的数量以及其他重要的管理信息。</p>

<p>20.文件存储的实现的关键问题是记录各个文件分别用到哪些磁盘块。</p>

<p>21.每个文件都从一个新的块开始，这样如果文件A实际上只有1/3块，那么最后一块的结尾会浪费一些空间。</p>

<p>22.文件分配表：File Allocation Table，FAT。</p>

<p>23.目录系统的主要功能是把ASCII文件名映射成定位文件数据所需的信息。</p>

<p>24.在需要查找文件名时，加快查找速度的一个方法是在每个目录中使用散列表。</p>

<p>25.文件系统本身是一个有向无环图，而不是一棵树。</p>

<p>26.符号连接的问题是需要额外的开销。必须读取包含路径的文件，然后要一个部分一个部分的扫描路径，直到找到 i 节点。符号连接有一个优势，即只要简单的提供一个机器的网络地址以及文件在该机器上驻留的路径，就可以连接全球任何地方的机器上的文件。</p>

<p>27.每隔一段时间，或者是有特殊需要时，被缓冲在内存中的所有未决的写操作都被放到一个单独的段中，作为在日志末尾的一个邻接段写入磁盘。总而言之，所有的写操作最初都被缓冲在内存中，然后周期性的把所有已缓冲的写作为一个单独的段，在日志的末尾处写入磁盘。</p>

<p>28.LFS（日志结构文件系统）有一个清理线程，该清理线程周期的扫描日志进行磁盘压缩。整个磁盘成为一个大的环形缓冲区，写线程将新的段写到前面，而清理线程则将旧的段从后面移走。</p>

<p>29.日志文件系统的基本想法是保存一个用于记录系统下一步将要做什么的日志。这样当系统在完成它们即将完成的任务前崩溃时，重新启动后，可以通过查看日志，获取崩溃前计划完成的任务，并完成它们。微软的NTFS文件系统就是此类。</p>

<p>30.为了让日志文件系统工作，被写入日志的操作必须是 幂等 的，它意味着只要有必要，它们就可以重复执行很多次，并不会带来破坏。</p>

<p>31.为了增加可信性，一个文件系统可以引入数据库中 原子事务 的概念。NTFS有一个扩展的日志文件系统，并且它的结构几乎不会因系统崩溃而受到破坏。</p>

<p>32.Windows通过制定不同的盘符来处理这些不同的文件系统。比如“C:”、“D:”等。当一个进程打开一个文件，盘符是显式或隐式存在的，所以Windows知道向哪个文件系统传递请求，不需要尝试将不同类型文件系统整合为统一模式。</p>

<p>33.绝大多数Unix操作系统都使用虚拟文件系统（VFS）概念尝试将多种文件系统统一成一个有序的框架。关键的思想就是抽象出所有文件系统都共有的部分，并且将这部分代码放在单独的一层，该层调用底层的实际文件系统来具体管理数据。</p>

<p>34.虚拟文件系统对用户进程有一个更高层的接口，它就是著名的 POSIX 接口。</p>

<p>35.NFS：network file system网络文件系统。</p>

<p>36.几乎所有文件系统都把文件分割成固定大小的块来存储，各块之间不一定相邻。拥有大的块尺寸则意味着小文件浪费了大量的磁盘空间，小的块尺寸意味着大多数文件会跨越多个块，需要多次寻道和旋转延迟才能读出，降低了性能。（现在一般4kb-64kb一个块）</p>

<p>37.跟踪空闲块的两种方法：链表和位图。位图方法所需要的空间较少，只有在磁盘快满时，链表方案需要的块才比位图少。位图是一种固定大小的数据结构。</p>

<p>38.转存储磁盘到磁带上有两种方案：物理转储和逻辑转储。物理转储简单快速，但是不能跳过目录也不能增量转储，还不能恢复个人文件。逻辑转储可以实现增量恢复。</p>

<p>39.最常用的减少磁盘访问次数技术的是 块高速缓存 或者缓冲区高速缓存。它们在逻辑上属于磁盘，但实际上基于性能的考虑被保存在内存中。</p>

<p>40.可以使用散列表来查找某个快是否在高速缓存中。如果告诉缓存已满，则需要调入新的块，因此，要把原来的某一块调出高速缓存（如果修改过则需要写回磁盘）。这个情况跟页面置换非常相似。</p>

<p>41.在Unix系统中有一个系统调用sync，它强制性的把全部修改过的块立即写回磁盘。系统启动时，在后台运行一个通常名为update的程序，它在无限循环中不断的执行sync调用，每两次调用之间休眠30秒。</p>

<h2 id="section-4">第五章 输入输出</h2>

<p>1.IO设备大致可以分为两类：块设备和字符设备。块设备的特征是每个块都能独立于其他块而读写，比如硬盘，U盘等。字符设备以字符为单位发送或接收一个字符流，而不考虑任何块结构。比如打印机，鼠标等。</p>

<p>2.无论一个CPU是否具有内存映射IO，它都需要寻址设备控制器以便与它们交换数据。但是这样做浪费CPU的时间，所以经常用到一种称为直接存储器存取（Direct Memory Access，DMA）的不同方案。</p>

<p>3.无论DMA控制器在物理上处于什么地方，它都能够独立于CPU而访问系统总线。大多数DMA控制器使用物理内存地址进行传送。</p>

<p>4.中断信号导致CPU停止当前正在做的工作并且开始做其他的事情。通过让CPU延迟对中断的应答，直到它准备好处理下一个中断，就可以避免与多个几乎同时发生的中断相牵涉的竞争状态。</p>

<p>5.程序控制IO十分简单但是有缺点，即直到全部IO完成之前要占用CPU的全部时间。</p>

<p>6.允许CPU在等待打印机变为就绪的同时做某些其他事情的方式就是使用中断。当打印机讲字符打印完毕并且准备好接收下一个字符时，它将产生一个中断。</p>

<p>7.中断驱动IO的一个明显缺点是中断发生在每个字符上。DMA重大的成功是将中断的次数从打印每个字符一次减少到打印每个缓冲区一次。</p>

<p>8.中断最终的结果是使先前被阻塞的驱动程序现在能够继续运行。</p>

<p>9.每个连接到计算机上的IO设备都需要某些设备特定的代码来对其进行控制。这样的代码称为 设备驱动程序 。设备驱动程序通常是操作系统黑盒的一部分。实际上，有可能构造运行在用户空间的驱动程序，这一设计使得内核与驱动程序相隔离，并且使驱动程序之间相互隔离，这样做可以消除系统崩溃的一个主要源头。然而，大多数操作系统都要求驱动程序运行在内核中。</p>

<p>10.两个缓冲区轮流使用，当一个缓冲区正在被复制到用户空间的时候，另一个缓冲区正在收集新的输入。像这样的缓冲模式称为双缓冲。</p>

<p>11.磁盘被组织成柱面，每一个柱面包含若干磁道，磁道数与垂直堆叠的磁头个数相同。磁道又被分成若干扇区。</p>

<p>12.高层建筑中的电梯调度问题和磁盘臂调度很相似。</p>

<p>13.磁盘控制器的高速缓存完全独立于操作系统的高速缓存。</p>

<p>14.一个磁盘子系统具有如下特性：当一个写命令发给它时，磁盘要么就正确的写数据，要么什么也不做，让现有的数据完整无缺的留下。这样的系统称为稳定存储器。</p>

<p>15.时钟负责维护时间，并且防止一个进程垄断CPU。</p>

<p>16.时钟由三个部件构成：晶体振荡器，计数器和存储寄存器。它给计算机的各种电路提供同步信号。该信号被送到计算器，使其递减计数至0。当计数器变为0时，产生一个CPU中断。</p>

<p>17.在方波模式中，当计数器变为0并且产生中断之后，存储寄存器的值自动复制到计数器中，并且整个过程无限期的再次重复下去。这些周期性的中断称为时钟滴答。</p>

<p>18.每当一个进程启动时，便启动一个不同于主系统定时器的辅助定时器。当进程终止时，读出这个定时器的值就可以知道该进程运行了多长时间。当中断法神时应该讲辅助定时器保存起来，中断结束后再将其恢复。</p>

<p>19.用户输入主要来自键盘和鼠标，键盘包含一个嵌入式微处理器，该微处理器通过一个特殊的串行端口与主板上的空值芯片通信。每当一个键被按下的时候都会产生一个中断，并且每当一个键被释放的时候还会产生第二个中断。</p>

<p>20.在Unix中，enter键被转换成一个换行用于内部存储；而在Windows上，它被转换成一个回车跟随一个换行。</p>

<p>21.EOF字符被解释为文件结尾。</p>

<p>22.Windows是面向消息的，每一个程序都有一个消息队列，与程序的所有窗口相关的消息都被发送到该队列中。程序的主循环包括提取下一条消息，并且通过调用针对该消息类型的内部过程对其进行处理。</p>

<p>23.通过在图像上覆盖一层网格扫描输入，每一个网格方块的平均红，绿，蓝取值被采样并且保存为一个像素的值。这样的文件称为位图（bitmap）。</p>

<p>24.一个停止的磁盘是休眠而不是睡眠，因为要花费相当多的时间将磁盘再次旋转起来，导致用户感到明显的延迟。重新启动磁盘将消耗相当多额外的能量。</p>

<p>25.节省磁盘能量的另一种方法是在RAM中拥有一个大容量的磁盘高速缓存。</p>

<p>26.由于电能消耗与电压的平方成正比，将电压降低一半会使CPU的速度减慢一半，而电能消耗降低到只有1/4。</p>

<p>27.关闭高速缓存是进入睡眠状态，将主内存的内容写到磁盘并关闭主内存则是休眠。</p>

<p>28.当移动计算机将要关闭无线电设备时，让移动计算机发送一条消息到基站。从那时起，基站在其磁盘上缓冲到来的消息。当移动计算机再次打开无线电设备时，它会通知基站。此刻，所有积累的消息可以发送给移动计算机。</p>

<h2 id="section-5">第六章   死锁</h2>

<p>1.操作系统都具有授权一个进程（临时）排他性访问某一种资源的能力。</p>

<p>2.软硬件资源都可能出现死锁。大部分死锁都和资源有关。我们把需要排他性使用的对象称为资源。简单来说，资源就是随着时间的推移，必须能够获得，使用以及释放的任何东西。</p>

<p>3.资源分为两类：可抢占的和不可抢占的。存储器就是一类可抢占的资源。不可抢占资源是指在不引起相关的计算失败的情况下，无法把它从占有它的进程处抢占过来。有关可抢占资源的潜在死锁问题通常可以通过在进程之间重新分配资源而化解。</p>

<p>4.若请求时资源不可用，则请求进程被迫等待。在一些操作系统中，资源请求失败时进程会自动被阻塞，在资源可用时再唤醒它。在其他的系统中，资源请求失败会返回一个错误码，请求的进程会等待一段时间，然后重试。</p>

<p>5.当一个进程请求资源失败时，它通常会处于这样一个小循环中：请求资源，休眠，再请求。</p>

<p>6.如果一个进程集合中的每个进程都在等待只能由该进程集合中的其他进程才能引发的事件，那么，该进程就是死锁的。无中断条件使死锁的进程不能被时钟中断等唤醒，从而不能引发释放该集合中的其他进程的事件。</p>

<p>7.资源死锁的四个必要条件：</p>

<p>①互斥条件。每个资源要么已经分配给了一个进程，要么就是可用的。</p>

<p>②占有和等待条件。已经得到了某个资源的进程可以再请求新的资源。</p>

<p>③不可抢占条件。已经分配给一个进程的资源不能强制性的被抢占，它只能被占有它的进程显示的释放。</p>

<p>④环路等待条件。死锁发生时，系统中一定有由两个或两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占的资源。</p>

<p>死锁发生时，以上四个条件一定是同时满足的。如果其中任何一个条件不成立，死锁就不会发生。</p>

<p>8.有四种处理死锁的策略：</p>

<p>①忽略该问题。也许如果你忽略它，它也会忽略你。</p>

<p>②检测死锁并恢复。让死锁发生，检测它们是否发生，一旦发生死锁，采取行动解决问题。</p>

<p>③仔细对资源进行分配，动态的避免死锁。</p>

<p>④通过破坏引起死锁的四个必要条件之一，防止死锁的发生。</p>

<p>9.检测有向图环路的方法：依次将每一个节点作为一棵树的根节点，并进行深度优先搜索。如果再次碰到已经遇到过的节点，那么就算找到了一个环。</p>

<p>10.如果死锁进程数达到一定数量，就没有多少进程可运行了，所以CPU会经常空闲。</p>

<p>11.从死锁中恢复：</p>

<p>①利用抢占恢复，在不通知原进程的情况下，将某一资源从一个进程强行取走给另一个进程使用，接着又送回，这种做法是否可行主要取决于该资源本身的特性；</p>

<p>②利用回滚恢复：将该进程复位到一个更早的状态，那时它还没有取得所需的资源，接着就把这个资源分配给一个死锁进程。如果复位后的进程试图重新获得对该资源的控制，它就必须一直等到该资源可用时为止；</p>

<p>③通过杀死进程恢复：杀掉环中的一个进程。如果这样做行不通的话，就需要继续杀死别的进程知道打破死锁。另一种方法是选一个环外的进程作为牺牲品以释放该进程的资源。有可能的话，最好杀死可以从头开始重新运行而且不会带来副作用的进程。</p>

<p>12.一种能够避免死锁的的调度算法，称为银行家算法。银行家算法就是对每一个请求进行检查，检查如果满足这一请求是否会达到安全状态。若是，那么久满足该请求；若否，那么就推迟对这一请求的满足。</p>

<p>13.银行家算法虽然很有意义但缺乏实用价值，因为很少有进程能够在运行前就知道其所需资源的最大值。实际中，如果有，也只有极少的系统使用银行家算法来避免死锁。</p>

<p>14.可以通过破坏死锁发生时的四个条件，四个条件中只要有一个不成立，死锁将不会产生。</p>

<p>①破坏互斥使用条件。如果资源不被一个进程所独占，那么死锁肯定不会产生。避免分配哪些不是绝对必需的资源，尽量做到尽可能少的进程可以真正请求资源。</p>

<p>②破坏占有和等待条件。只要禁止已持有资源的进程再等待其他资源便可以消除死锁。</p>

<p>一种方法是规定所有进程在开始执行前请求所需的全部资源。如果所需的全部资源可用，那么就将它们分配给这个进程，于是该进程能够运行结束。如果有一个或多个资源正被使用，那么就不进行分配，进程等待。</p>

<p>另一种方法是，要求当一个进程请求资源时，先暂时释放其当前占用的所有资源，然后再尝试一次获得所需的全部资源。</p>

<p>③破坏不可抢占条件。一些资源可以通过虚拟化的方式来避免发生这样的情况。不过并不是所有的资源都可以进行类似的虚拟化。</p>

<p>④破坏环路等待条件。</p>

<p>一种是保证每一个进程在任何时刻只能占用一个资源，如果要请求另一个资源，它必须先释放第一个资源。</p>

<p>另一种方法是将所有的资源统一编号，进程可以在任何时刻提出资源请求，但是所有请求必须按照资源编号的顺序（升序）提出。</p>

<p><img src="http://kobe1941.github.io/images/2019/02/11/3.png" alt="" /></p>

<p>15.两阶段加锁：第一阶段，进程试图对所有所需的记录进行加锁，一次锁一个记录。如果第一阶段加锁成功，就开始第二阶段，完成更新然后释放锁。如果在第一阶段某个进程需要的记录已经被加锁，那么该进程释放它所有加锁的记录，然后重新开始第一阶段。</p>

<p>16.通信死锁：两个以上的进程利用发送信息来通信时，进程A向进程B发送请求信息，然后阻塞直至B回复。假设请求信息丢失，A将阻塞以等待回复，而B会阻塞等待一个向其发送命令的请求，因此发生死锁。</p>

<p>17.根据标准的定义，在一系列进程中，每个今晨因为等待另外一个进程引发的事件而产生阻塞，这是一种死锁。</p>

<p>18.通信死锁不能通过对资源排序或者通过仔细的安排调度来避免。但是通常可以用超时来中断通信死锁。</p>

<p>19.并非所有在通信系统或者网络发生的死锁都是通信死锁，资源死锁也会发生。</p>

<p>20.活锁：两个进程总是一再的消耗分配给它们的CPU配额，但是没有进展也没有阻塞，看起来就像是死锁发生了。</p>

<p>21.与死锁和活锁非常相似的一个问题是 饥饿 。饥饿可以通过先来先服务资源分配策略来避免，等待最久的进程会是下一个被调度的进程。</p>

<p>22.死锁检测是一个经典的图论问题。</p>

<p>23.在一组进程中，每个进程都因等待由改组进程中的另一个进程占有的资源而导致阻塞，死锁就发生了。这种情况会使所有的进程都处于无限等待的状态。</p>

<p>24.死锁的另外一种可能的情况是一组通信进程都在等待一个消息，而通信信道却是空的，并且也没有采用超时机制。</p>

<h2 id="section-6">第七章   多媒体操作系统</h2>

<p>1.机顶盒实际上就是普通的计算机，只不过其中包含特殊的芯片用于食品解码和解压缩。</p>

<p>2.NTSC制式每秒包含30帧，PAL和SECAM制式美妙包含25帧。</p>

<p>3.传输率的变动称为 颤动 。</p>

<p>4.让人可以接受的回放多媒体所要求的实时性通常通过服务质量参数来描述，这些参数包括可用平均带宽，可用峰值带宽，最小和最大延迟（两者一起限制了颤动）以及位丢失概率。</p>

<p>5.必须要有保持子文件同步的某种方法，这样才能保证当选中的音频轨迹回放与视频保持同步。</p>

<p>6.隔行扫描：首先显示所有的奇数扫描线，接着再显示所有的偶数扫描线。非隔行扫描则称为逐行扫描。</p>

<p>7.人的眼睛对亮度信号比对色度信号敏感的多，所以色度信号不需要非常精确的进行传输。理解亮度和色度对于理解视频压缩的工作原理是十分必要的。</p>

<p>8.数字视频最简单的标识方法是帧的序列，每一帧由呈矩形栅格的图像要素即像素组成。数字视频隔行扫描是不必要的，因此所有计算机显示器都采用逐行扫描，仅仅连续刷新相同的帧三次就足以消除闪烁。</p>

<p>9.运动的平滑性是由每秒不同的图像数决定的，而闪烁则是由每秒刷新屏幕的次数决定的。</p>

<p>10.奈奎斯特采样定理：如果存在最高频率的成分为f，那么以2f 的评率进行采样就足够了。</p>

<p>11.所有的压缩系统都需要两个算法：编码算法和解码算法。这些算法具有某些不对称性，这一不对称性对于理解数据压缩是十分重要的。</p>

<p>①一个多媒体文档只需要编码一次，但是需要解码数千次；②编码解码的过程不必是100%可逆的。</p>

<p>12.视频信号经过编码和解码之后与原始信号只存在轻微的差异通常就是可以接受的。被称为有损的，所有用于多媒体的压缩系统都是有损的，因为这样可以获得更好的压缩效果。</p>

<p>13.用于压缩运动图像的标准MPEG不过是分别对每一帧进行JPEG编码，再加上某些帧间压缩和运动补偿等额外的特征。</p>

<p>14.JPEG大体上是对称的：解码一幅图像花费的时间与编码基本相同。</p>

<p>15.MPEG的两个版本均利用了在电影中存在的两类冗余：空间冗余和时间冗余。</p>

<p>16.互相连续的帧常常几乎是完全相同的，这就是时间冗余，利用这一事实可以达到额外的压缩效果。DV数字视频只使用类JPEG的方案，这是因为只单独对每一帧进行编码可以达到更快的速度，从而使编码可以实时完成。</p>

<p>17.对于摄像机和背景绝对静止，而又一两个演员在四周缓慢移动的场景而言，帧与帧之间几乎所有的像素都是相同的。此时，仅仅将每一帧减去前一帧并且在差值图像上运行JPEG就相当不错。然而，对于运动的镜头场景而言，就需要某种方法对这一运动进行补偿，这正是MPEG要做的事情，实际上，这就是MPEG和JPEG之间的主要差别。</p>

<p>18.MPEG-2输出由三种不同的帧组成：</p>

<p>①I帧：自包含的JPEG编码静止图像。</p>

<p>②P帧：与上一帧逐块的差。</p>

<p>③B帧：与上一帧和下一帧的差。</p>

<p>19.在输出流中使I帧周期性的出现是十分必要的。有了I帧，就可以向前或向后跳过若干帧直到找到一个 I 帧并从那里开始观看。由于上述原因，MPEG每秒将 I 帧插入到输出流中一次或两次。</p>

<p>20.MP3是功能最强大也是最出名的音频压缩算法。MP3属于MPEG视频压缩标准里的音频部分。</p>

<p>21.音频压缩可以用两种方法完成：①波形编码技术中，信号通过傅里叶变换变换成频率分量。②感知编码是基于心理声学的——人们如何感知声音的科学。MP3正式基于感知编码。</p>

<p>22.感知编码的关键特性在于一些声音可以掩盖住其他声音。在一个频段里响亮的声音掩盖住另一频段中较柔和声音的能力，这种较柔和声音只有在没有响亮声音时才可以听到——频段屏蔽。</p>

<p>23.通过跟踪那些被附近频段能量更强的信号所屏蔽的信号，可以省略越来越多的编码信号中的频率，以此来节约二进制位。MP3编码的实质就是对声音做傅里叶变换从而得到每个频率的能量，之后只传递那些不被屏蔽掉的频率，并且用尽可能少的二进制位数来编码这些频率。</p>

<p>24.大部分的二进制位分配给拥有多数频谱能量的未屏蔽波段，小部分二进制位分配给拥有较少频谱能量的未屏蔽波段，已屏蔽的波段不分配二进制位。</p>

<p>25.多个相互竞争的进程，其中若干进程或全部进程具有必须满足的最终时限的调度称为实时调度。</p>

<p>26.在多媒体系统中，进程通常是可抢占的，这意味着允许有危险错过其最终时限的进程在正在运行的进程完成工作以前将其中断，然后当它完成工作以后，被中断的前一个进程再继续运行。</p>

<p>27.进程要访问一个文件时，首先要发出open系统调用。如果该调用成功，则调用者被给予某种令牌以便在未来的调用中使用，该令牌在Unix中倍称为文件描述符，在Windows中被称为句柄。</p>

<p>28.为了读取一个多媒体文件，用户进程发出start系统调用，指定要读的文件和各种其他参数，接着视频服务器开始以必要的速率送出帧，然后用户进程以帧进来的速率对它们进行处理。具有这种数据流模型的文件服务器被称为 推送型服务器。与此相对照的是拉取型服务器，用户可以通过重复的调用read一块接一块的取得数据，每调用一次可以拉取出一块数据。</p>

<p>29.音频压缩是独立于视频压缩的，所以对于在高速模式中显示的每一视频帧，还必须找到正确的音频帧（除非在高于正常速度播放时将声音关闭）。因此，对一个DV文件进行快进操作需要有一个索引，该索引可以使帧的查找快速的实现。MPEG要求按顺序播放文件。</p>

<p>30.多媒体文件非常庞大，通常只写一次而读许多次，并且倾向于被顺序访问。</p>

<p>31.诸如出租的电影，从图书馆借出的图书，访问的web网页，甚至一部小说中使用的英文单词或者特大城市居住的人口，相对流行性的一个合理的近似遵循着一种令人惊奇的可预测模式——zipf定律。（其实可以看一下泊松分布）</p>

<p>32.在传统的LRU缓冲区高速缓存背后的思想是，当一个块被使用之后，应该将其保存在高速缓存中，以防很快再次需要访问它。</p>

<p>33.为了保持输出给客户的数据流运行流畅，在服务器中采用双缓冲是必要的。</p>

<p>34.多媒体文件包含多重平行的轨迹，通常有一个视频轨迹和至少一个音频轨迹，有时还有一些字母轨迹。在回放期间，这些轨迹都必须保持同步。</p>

<p>35.视频压缩可以使用帧内压缩（JPEG），也可以使用帧间压缩（MPEG）。后者将P帧表示为与前一帧的差，而B帧则既可以基于前面的帧，也可以基于后面的帧。</p>

<p>36.多媒体文件系统通常使用推送型模型而不是拉取型模型。</p>

<h4 id="section-7">补充：</h4>

<p>1.直播的四大指标：画质、卡顿率、延时、秒开。画质和卡顿率要看传说的码率，码率高画质高，卡顿率也可能增大。秒开则主要是减少GOP，即减少 I 帧在视频流的间隔。</p>

<h2 id="section-8">第八章    多处理机系统</h2>

<p>1.按照爱因斯坦相对论，电子信号的速度不可能超过光速。光速=波长*频率。光速真空中大约是30cm/ns，在光纤中大概是20cm/ns。这在计算机中意味着10GHz的时钟，信号的传送距离总共不会超过2cm。——这个可能是计算机始终频率没有继续上升的原因</p>

<p>2.获取更高速度的一种处理方式是大规模使用并行计算机。在高强度的数据处理中经常采用高度并行计算机。</p>

<p>3.虚拟化技术：一种通过软件创造出更多虚拟CPU的方法。</p>

<p>4.共享存储器多处理机（简称为多处理机）是这样一种计算机系统，其两个或更多的CPU全部共享访问一个公用的RAM。运行在任何一个CPU上的任何程序都看到一个普通（通常是分页）的虚拟地址空间。这个系统唯一的性质是，CPU可对存储器字写入某个值，然后读回该字，并得到一个不同的值（因为另一个CPU改写了它）。这种性质构成了处理器间通信的基础：一个CPU向存储器写入某些数据而另一个读取这些数据。</p>

<p>5.所有的多处理机都具有每个CPU可以访问全部存储器的性质。</p>

<p>6.如果CPU试图在一个或多个远程高速缓存中写入一个字，总线硬件检测到写，并把一个信号放到总线上通知所有其他的高速缓存。如果其他高速缓存有个干净的副本，也就是同存储器内容完全一样的副本，那么它们可以丢弃该副本 并让写者在修改之前从存储器取出高速缓存块（进行写操作）。如果某些其他高速缓存有 脏 的副本，它必须在处理写之前把数据写回存储器或者把它通过总线直接传送到写者。——高速缓存一致性协议。</p>

<p>7.多核芯片：将两个或多个完整的CPU，通常称为核，放到一个芯片上。</p>

<p>8.特殊的硬件电路可以确保在一个字同时出现在两个或者多个的高速缓存中的情况下，当其中某个CPU修改了该字，所有其他高速缓存中的该字都会被自动的并且原子性的删除来确保一致性，这个过程称为 窥探。</p>

<p>9.除了所有核都是对等的多核芯片之外，还有一类多核芯片被称为片上系统（SOC）。这些芯片含有一个或多个主CPU，但是同时还包含若干个专用核，例如视频与音频解码器，加密芯片，网络接口等。</p>

<p>10.对称多处理机：在存储器中有操作系统的一个副本，且任何CPU都可以运行它。任何CPU都可以运行操作系统，但是任一时刻只有一个CPU可运行操作系统。——大多数现代多处理机都采用这种安排。</p>

<p>11.使用多个锁进行同步：给一个未能获得锁的CPU分配一个锁变量并且把它附在等待该锁的CPU链表的末端。在当前锁的持有者退出临界时，它释放链表中的首个CPU正在测试的私有锁（在自己的高速缓存中）。然后该CPU进入临界区。操作完成后，该CPU释放锁。其后继者接着使用，以此类推。</p>

<p>12.不论是连续轮询方式，间歇轮询方式，还是把自己附在进行等候CPU链表中的方式，我们都假定需要加锁的互斥信号量的CPU只是保持等待。</p>

<p>13.多数研究工作使用了这样一个模型：一个未能获得互斥信号量的线程自旋一段时间。如果时间超过某个阈值，则进行切换。在某些情形下，该阈值是一个定值，典型值是切换至另一个线程再切换回来的开销。在另一些情形下，该阈值是动态变化的，它取决于所观察到的等待互斥信号量的历史信息。</p>

<p>14.亲和调度：尽量使一个线程在它前一次运行过的同一个CPU上运行。（方便复用高速缓存的内容）</p>

<p>15.两级调度算法有三个优点：</p>

<p>①它把负载大致平均的分配在可用的CPU上；</p>

<p>②它尽可能发挥了高速缓存亲和力的优势；</p>

<p>③通过为每个CPU提供一个私有的就绪线程链表，使得对就绪线程链表的竞争减到了最小，因为试图使用另一个CPU的就绪线程链表的机会相对较小。</p>

<p>16.群调度：既可以调度时间又可以调度空间的算法，特别是对于要创建多个线程而这些线程通常需要彼此通信的线程。</p>

<p>群调度由三个部分组成：</p>

<p>①把一组相关线程作为一个单位，即一个群，一起调度。</p>

<p>②一个群中的所有成员在不同的分时CPU上同时运行。</p>

<p>③群中的所有成员共同开始和结束其时间片。</p>

<p>17.群调度的思想是，让一个进程的所有线程一起运行，这样，如果其中一个线程向另一个线程发送请求，接受方几乎会立即得到消息，并且几乎能够立即应答。</p>

<p>18.多计算机是紧耦合CPU，不共享存储器。每台计算机有自己的存储器。</p>

<p>19.很多接口板上有一个完整的CPU，可能另外还有一个或多个DMA通道。他们被称为网络处理器。这种设计意味着主CPU将一些工作分给了网卡，诸如处理可靠的传送（如果底层硬件会丢包），多播（将包发送到多于一个目的地），压缩/解压缩，加密/解密以及在多进程系统中处理安全事务等。</p>

<p>20.在多计算机系统中高性能通信的敌人是对包的过度复制。最简单的设计是使用两块网络接口板，一块映射到用户空间供应用程序使用，另一块映射到内核空间供操作系统使用。许多计算机就正是这样做的。</p>

<p>21.DMA使用武力地址而不是虚拟地址，并且独立于CPU运行。</p>

<p>22.远程过程调用RPC：允许程序调用位于其他CPU中的过程。当机器1的进程调用机器2的过程时，在机器1中的调用进程被挂起，在机器2中的被调用的过程执行。可以在参数中传递从调用者到被调用者的信息，并且可在过程的处理结果中返回信息。</p>

<p>23.虚拟化技术允许一台机器中存在多台虚拟机，每一台虚拟机可能运行不同的操作系统。好处是一台虚拟机上的错误不会自动的使其他虚拟机崩溃。</p>

<p>24.即使在不可虚拟化的硬件上，II 型管理程序也能正常工作的原因：所有的敏感指令被仿真这些指令的过程调用所替代。客户操作系统发射的敏感指令不会被真正的硬件执行。它们转换了对管理程序的调用，而这些调用仿真了那些敏感指令。</p>

<p>25.几乎全部的现代操作系统都支持虚拟内存，即从虚拟地址空间到物理地址空间的页面映射。这个映射由（多级）页表所定义。</p>

<p>26.多核芯片上的所有核共享内存。</p>

<p>27.分布式系统面对不同硬件和操作系统实现某种统一性的途径是，在操作系统的顶部添加一层软件。这层软件称为中间件。这层软件提供了一些特定的数据结构和操作，从而允许散布的机器上的进程和用户用一致的方式来操作。</p>

<p>28.用于特定计算机通信的这些规则的集合，称为协议。</p>

<p>29.所有的现代网络都使用所谓的协议栈把不同的协议一层一层叠加起来。每一层解决不同的问题。</p>

<p>30.浏览器访问网页的步骤：</p>

<p><img src="http://kobe1941.github.io/images/2019/02/11/4.png" alt="" /></p>

<p>31.采用多个CPU可以把计算机系统建造得更快更可靠。CPU的四种组织形式是多处理器，多计算机，虚拟机和分布式系统。</p>

<h2 id="section-9">第九章  安全</h2>

<p>1.安全领域中基本但却重要的工具：现代密码学。</p>

<p>2.计算机系统的四个主要安全目标：数据保密，数据完整性，系统可用性（指没有人可以扰乱系统使之瘫痪），数据隐私。</p>

<p>3.病毒就是一种能够自我复制并通常会产生危害的程序代码。</p>

<p>4.加密的目的是将明文——也就是原始信息或文件，通过某种手段变为密文，通过这种手段，只有经过授权的人才知道如何将密文恢复为明文。</p>

<p>5.在算法中使用的加密参数叫做密钥。加密算法本身应该完全公开，而加密的安全性由独立于加密算法之外的密钥决定。</p>

<p>6.公钥机制的主要问题在于运算速度要比对称密钥机制慢数千倍。</p>

<p>7.最常用的散列函数（哈希函数）有MD5，SHA-1，SHA-256，SHA-512。</p>

<p>8.所有的浏览器都预加载了大约40个著名的CA的公钥。</p>

<p>9.域（domain）是一对（对象，权限）组合。每一对组合指定一个对象和一些可在其上运行的操作子集。这里权限是指对某个操作的执行许可。</p>

<p>10.每个Unix的进程有两个部分：用户部分和核心部分。当执行系统调用时，进程从用户部分切换到核心部分。核心部分可以访问与用户部分不同的对象集。系统调用就引发了域切换。</p>

<p>11.大多数操作系统允许个人用户来决定谁可以读写他们的文件和其他对象。这一策略称为可自由支配的访问控制。</p>

<p>12.将每一个口令同一个叫做 盐 的n位随机数相关联。无论何时只要口令改变，随机数就改变。随机数以未加密的方式存放在口令文件中。对口令文件采用 加盐 的方法以及使之不可读（除非间接和缓慢的读）可以抵挡大多数的外部攻击。</p>

<p>13.更换口令更极端的方式是每次登陆换一次口令，即使用一次性口令。——现在大多数的账号系统都采用</p>

<p>14.汉明距离：两个比特字串之间的汉明距离指从一个比特串变换为另一个比特串最少需要变化的比特数。</p>

<p>15.利用代码漏洞进行攻击的几种方式：</p>

<p>①缓冲区溢出攻击：C语言函数库的gets函数可以把（未知大小）的串变量读入定长的缓冲区里，但并不校验是否溢出，这样就很容易遭受攻击。</p>

<p>②格式化字符串攻击：某个变量的值在函数printf中可能以一种不显眼的方式被修改。它意味着打印一个格式化字符串可能导致一个或多个单词被存储在内存中。由于程序员的不严禁的修改，可能导致用户有了输入格式化字符串的机会，而打印一个格式化字符串可能会导致内存被重写，这就为覆盖栈中pringtf函数的返回值提供了一种方法，通过重写这个返回地址，可以使得函数在printf函数函数时跳到任何位置。</p>

<p>③返回 libc 攻击：通过修改当前函数的返回地址到指定位置来实施攻击。</p>

<p>④整数溢出攻击：计算机进行长整形数的运算，如果结果超过了整形数可以表示的最大值，就称溢出发生了。</p>

<p>⑤代码注入攻击：将一段代码用另一种形式注入到一个函数的参数里，当参数被取出，传递给别的函数执行时，可能会有预料之外的代码被执行。</p>

<p>⑥权限提升攻击：攻击者欺骗系统为其赋予比正常情况更高的权限。</p>

<p>16.绝对多数系统安全问题都与缓冲区溢出漏洞相关，而这类漏洞很难被修复。对付这类攻击的办法是修改代码，显示的检查用户输入的所有变量的长度。从而避免把长字符串放入定长缓冲里。</p>

<p>17.之所以有如此多的攻击是因为操作系统和其他应用程序都是用C语言写的，但遗憾的是，没有一个C编译器可以做到数组边界检查。</p>

<p>18.几乎所有的C程序都连接了libc库，这个库包括了C程序几乎所有的关键函数，其中的一个就是strcpy。该函数将一个任意长度的字符串从任意地址复制到另一地址。这种攻击的本质是欺骗strcpy函数降恶意程序复制到数据段并在那里执行。</p>

<p>19.作为安装免费软件的代价，他们同时也安装了恶意软件。这种方式叫做木马攻击。——木马是受害者自己安装的。</p>

<p>20.病毒是一种特殊的程序，它可以通过把自己植入到其他程序中来进行繁殖，就像生物界中真正的病毒那样。</p>

<p>21.共事者病毒并不真正感染程序，但当程序执行的时候它也执行。</p>

<p>22.更复杂的一类病毒是感染可执行程序的病毒。它们中最简单的一类会覆盖可执行程序，这叫做覆盖病毒。</p>

<p>23.病毒把自己附在正常程序里，在病毒发作时可以让原来的程序正常工作。这类病毒叫做寄生病毒。</p>

<p>24.最具移植性的病毒是源代码病毒。</p>

<p>25.能够自我复制的程序叫做蠕虫，蠕虫包含了两部分程序，引导程序和蠕虫本身。由于蠕虫能够自我复制，因此扩散趋势比病毒要快。</p>

<p>26.间谍软件是一种迅速扩散的恶意软件，粗略的讲，间谍软件是在用户不知情的情况下加载到PC上的，并在后台做一些超出用户意愿的事情。它隐藏自身，收集用户数据，将收集到的资料传给远程的监控者，卸载它时，它还会试图进行防御。</p>

<p>27.防火墙有两种基本的类型：硬件防火墙和软件防火墙。</p>

<p>28.最简单的一种防护墙是 无状态防护墙 ：只会检查通过的包的头部，然后根据包头部的信息和防火墙的规则作出传送还是丢弃这个包的决定。</p>

<p>29.每次复制时都发生变异的病毒叫做多形态病毒。能够交换机器码指令而不影响程序功能的代码叫做变异引擎。</p>

<p>30.代码签名：我们只运行哪些来自可靠软件厂商的没有被修改过的软件。代码签名基于公钥密码体系。</p>

<p>iOS APP代码签名的流程（见这里<a href="http://blog.cnbang.net/tech/3386/">http://blog.cnbang.net/tech/3386/</a>）：</p>

<p><img src="http://kobe1941.github.io/images/2019/02/11/5.png" alt="" /></p>

<p>31.即使一个软件已经被签名了，一个好的态度是去核实它是否都能正常运行。做这件事情的一种技术是 囚禁。</p>

<p>32.封装移动代码的两种方式：</p>

<p>①沙盒法：这种方法将每个运行的Applet（或APP）限制在一定范围的有效地址中。保证每个Applet不能跳转到或引用其他的代码沙盒或数据沙盒。</p>

<p>②解释法：解释运行并阻止它们获得对硬件的控制。web浏览器使用的就是这种方法。</p>

<h2 id="linux">第十章   实例研究：Linux</h2>

<p>1.微内核背后的思想是在内核中只提供最少的功能，从而使其可靠和高校。</p>

<p>2.由于一个用户态进程崩溃后造成的损害要远小于一个内核组件崩溃后造成的损害，因此将功能代码从内核移到用户态后，系统会更加可靠。微内核的主要缺点是用户态与内核态的额外切换会带来较大的性能损失。</p>

<p>3.一直以来，Unix都被设计成一种能够同时处理多进程和多用户的交互式系统。</p>

<p>4.设计Linux的一个基本指导方针就是每个程序应该只做一件事并且把它做好。</p>

<p>5.Linux具有三种不同的接口：真正的系统调用接口，库函数接口和由标准应用程序构成的接口。</p>

<p>6.make 的作用是跟踪哪些文件依赖于哪些头文件等，然后安排所有需要进行的编译自动进行。几乎所有的Linux程序，除了最小的那些，都是依靠make进行编译的。</p>

<p>7.Linux把进程和线程简单的看作可运行的实体，并使用统一的调度策略对它们进行调度。</p>

<p>8.Linux系统中主要的活动实体就是进程。每个进程执行一段独立的程序并且在进程初始化的时候拥有一个独立的控制线程。每一个进程都拥有一个独立的程序计数器，用这个程序计数器可以追踪下一个将要被执行的指令。</p>

<p>9.在大多数单用户的工作站里，即使用户已经退出登录，仍然会有很多后台进程，即守护进程，在运行。在系统启动的时候，这些守护进程就已经被shell脚本开启。</p>

<p>10.系统中还存在其他的守护进程，他们接收或发送电子邮件，管理打印队列，检测内存中是否有足够的空闲页等。在Linux系统中，守护进程可以直接实现，因为它不过是与其他进程无关的另一个独立的进程而已。</p>

<p>11.系统调用fork将会创建一个与原始进程完全相同的进程副本。调用fork函数的进程称为父进程，新的进程称为子进程。父进程和子进程都拥有自己的私有内存映像。</p>

<p>12.Linux系统中的进哼可以通过一种消息传递的方式进行通信。在两个进程之间，可以建立一个通道，一个进程向这个通道里写入字节流，另一个进程从这个通道里读取字节流。这些通道称为 管道（pipe）。使用管道也可以实现同步，因为如果一个进程试图从一个空的管道中读取数据，这个进程就会被挂起直到管道中有可用的数据为止。shell中的管线就是用管道技术实现的（比如<code>git log | grep xxx</code>）。</p>

<p>13.进程还可以通过另一种方式通信：软件中断。一个进程可以给另一个进程发送信号（signal）。</p>

<p>一个进程只可以给它所在进程组中的其他进程发送信号，这个进程组包括它的父进程（以及远祖进程），兄弟进程和子进程（以及后裔进程）。同时，一个进程可以利用系统调用给它所在的进程组中所有的成员发送信号。</p>

<p><img src="http://kobe1941.github.io/images/2019/02/11/6.png" alt="" /></p>

<p>14.一个进程在某一个特定的时刻只能有唯一一个未处理的警报。第一次alarm系统调用设置的信号被第二次alarm系统调用取消了。</p>

<p>15.pause系统调用，它会通知Linux系统将本进程挂起知道下一个信号到来。</p>

<p>16.每一个进程都有一个运行用户程序的用户模式。但是当它的某一个线程调用系统调用之后，进程会陷入内核模式并且运行在内核上下文中，它将使用不同的内存映射并且拥有对所有机器资源的访问权。它还是同一个线程，但是现在拥有更高的权限，同时拥有自己的内核堆栈以及内核程序计数器。</p>

<p>17.Linux系统内核中，进程通过数据结构task_struct被表示成任务。一个多线程的进程将为每一个用户级线程分配一个任务数据结构。Linux是多线程的，并且它所拥有的是与任何用户进程无关的内核级线程。</p>

<p>18.内核将所有进程的任务数据结构组织成一个双向链表。不需要遍历这个链表来访问进程描述符，PID可以直接被映射成进程的任务数据结构所在的地址，从而立即访问进程的信息。</p>

<p>19.关于信号的信息必须永远保存在内存里，即使这个进程已经不在内存当中了。换句话说，关于文件描述符的信息可以被保存在用户级的数据结构里，当进程存在于内存当中并且可以执行的时候，这些信息才需要被调入内存。</p>

<p>20.写时复制所带来的额外好处是，不需要在内存中维护同一个程序的两个副本，从而节省了RAM。</p>

<p>21.从历史观点上说，进程是资源容器，而线程是执行单元。一个进程包含一个或多个线程，线程之间共享地址空间，已打开的文件，信号处理函数，警报信号和其他。</p>

<p>22.传统观念上，当一个新线程被创建的是偶，之前的线程和新线程除了寄存器内容之外共享所有的信息。特别是，已打开文件的文件描述符、信号处理函数、警报信号和其他每个进程（不是每个线程）都具有的全局属性。</p>

<p>23.Unix系统为每一个进程分配一个独立的PID，不论它是单线程的进程还是多线程的进程。Linux对进程标识符（PID）和任务标识符（TID）进行了区分。当调用clone函数创建一个新进程而不需要和旧进程共享任何信息时，PID被设置成一个新值；否则，任务得到一个新的任务标识符，但是PID不变。这样一来，一个进程中所有的线程都会拥有与该进程中第一个线程相同的PID。</p>

<p>24.Linux系统的线程是内核线程，所以Linux系统的调度是基于线程的。</p>

<p>25.Linux调度算法使用一个重要的数据结构——调度队列。在系统中，一个CPU有一个调度队列，调度队列有两个数组，一个是正在活动的，一个是过期失效的。这两个分量都是指向数组的指针，每个数组都包含了140个链表头，每个链表具有不同的优先级。链表头指向给定优先级的双向进程链表。</p>

<p>26.当正在活动数组中没有其他的任务了，调度器交换指针，使得正在活动的数组变为过期失效数组，过期失效数组变为正在活动数组。</p>

<p>27.不同的优先级被赋予不同的时间片长度。Linux系统会赋予高优先级的进程较长的时间片。</p>

<p>28.Linux系统区分静态优先级和动态优先级。线程的动态优先级不断的被重新计算。</p>

<p>29.调度器只考虑可以运行的任务，这些任务被放在适当的调度队列当中。不可运行的任务和正在等待各种IO操作或内核事件的任务被放入另一个数据结构当中，即等待队列。等待队列的头包含一个指向任务链表的指针及一枚自旋锁。为了保证等待队列可以在主内核代码、中断处理函数或其他异步处理请求代码中进行并发操作，自旋锁是非常必要的。</p>

<p>30.每个Linux进程都有一个地址空间，逻辑上有三个段组成：代码、数据和堆栈段。通常代码段是只读的，不会发生改变。数据段包含了所有程序变量、字符串、数字和其他数据的存储。它有两部分，初始化数据段和未初始化数据（BSS）。所有BSS部分中的变量在加载后被初始化为0。</p>

<p>31.未初始化数据的存在实际上仅仅是个优化，大部分全局变量并没有初始化，因此都是0。</p>

<p>32.为了避免分配一个全是0的物理页框，在初始化的时候，Linux就分配了一个静态零页面，即一个全0的写保护页面。当加载程序的时候，未初始化数据区域被设置为指向该零页面。</p>

<p>33.Linux允许数据段随着内存的分配和回收而增长和缩减，通过这种机制来解决动态分配的问题。</p>

<p>34.第三段是栈段，在多数机器里，它从虚拟地址空间的顶部或者附近开始，并且向下生长。当一个程序启动的时候，它的栈并不是空的，它包含了所有的环境变量以及为了调用它而向shell输入的命令行。</p>

<p>35.大多数Linux系统支持共享代码段（进程多开的原理）。</p>

<p>36.数据段和栈端从来不共享，除非是在一个fork之后，并且仅仅是哪些没有被修改过的页面。</p>

<p>37.除了动态分配更多的内存，Linux中的进程可以通过内存映射文件来访问文件数据。这个特性使我们可以把一个文件映射到进程空间的一部分而该文件就可以像位于内存中的字节数组一样被读写。把一个文件映射进来使得随机读写比使用read和write之类的IO系统调用要容易得多。共享库的访问就是用这种机制映射进来后运行的。</p>

<p>38.把一个文件映射进来的一个附加好处是两个或更多的进程可以同时映射相同的文件，其中一个进程对文件的写可以被其他进程马上看到。</p>

<p>39.mmap的第一个参数，addr决定文件被映射的地址，第二个参数len指示要映射的字节数。最后一个参数offset告诉从文件中的什么位置开始映射，并不一定要从0字节开始映射，任何页面边界都是可以的。</p>

<p>mmap(addr,len,prot,flags,fd,offset);</p>

<p>40.32位机器上的每个Linux进程通常有3GB的虚拟地址空间，还有1GB留给其页表和其他内核数据。在用户态下运行时，内核的1GB是不可见的，但是当进程陷入到内核时是可以访问的。内核内存通常驻留在低端物理内存中，但是被映射到每个进程虚拟地址空间顶部的1GB中。</p>

<p>41.内核维护内存的一个映射，该映射包含了所有系统物理内存使用情况的信息，比如区域，空闲页框等。</p>

<p>42.首先，Linux维护一个页描述符数组，称为mem_map，其中页描述符是page类型的，而且系统当中的每个物理页框都有一个页描述符。每个页描述符都有个指针，在页面非空闲时指向它所属的地址空间，另有一对指针可以使得它跟其他描述符形成双向链表，来记录所有的空闲页框和一些其他的域。</p>

<p>43.区域描述符包含了每个区域中内存利用情况的信息，例如活动和非活动页的数组，页面置换算法所使用的高低水位，还有许多其他的域。此外，区域描述符包含一个空闲区数组。</p>

<p>44.每个节点描述符包含了内存使用的信息和该节点上的区域。</p>

<p>45.分页缓存并不是一个独立的缓存，而是那些不再需要的或者等待换出的用户页面集合。如果分页缓存当中的一个页面在被换出内存之前复用，它可以被快速收回。</p>

<p>46.Linux支持动态加载模块，最常见的是设备驱动。</p>

<p>47.虚拟地址空间被分割成同构连续页面对齐的区域。每个区域由一系列连续的具有相同保护和分页属性的页面组成。代码段和映射文件就是区的例子。</p>

<p>48.在内核中，每个区是用vm_area_struct项来描述的。一个进程所有vm_area_struct用一个链表链接在一起，并且按照虚拟地址排序以便可以找到所有的页面。当这个链表太长时（多余32项），就创建一个树来加速搜索。——通常被组织成一个二叉红黑树。</p>

<p>49.内存管理单元是一个页，并且几乎所有的内存管理部件以页为操作粒度。交换子系统也是以页为操作粒度，并且跟页框回收算法紧耦合在一起。</p>

<p>50.代码、数据和栈段的页面是动态载入的，仅仅是在它们被引用的时候。如果用户表和页面不在内存中，知道交换器把它们载入内存进程才能运行。</p>

<p>51.分页是一部分由内核是实现而一部分由一个新的进程，页面守护进程，实现的。跟所有守护进程一样，页面守护进程周期性的运行。如果它发现空闲页面数量太少，就开始释放更多的页面。</p>

<p>52.分页文件被动态的添加或删除。一个页总是被连续的写到磁盘，用一个分页文件，也许是或者也许不是这样的。</p>

<p>53.页面只有在需要的时候才在分页设备或者分区上被分配。</p>

<p>54.Linux区分其中不同的页面：不可回收的，可交换的，可同步的，可丢弃的。不可回收页面包括保留或者锁定页面，内核态栈等，不会被换出页面。可交换页面必须在回收之前写回到交换区或者分页磁盘区。可同步的页面如果被标记为dirty就必须要写回到磁盘。最后，可丢弃的页面可以被立即回收。</p>

<p>55.在启动的时候，init开启一个页面守护进程kswapd（每个内存节点都有一个），并且配置它们能周期性的运行。如果有足够的空闲页面，它就继续睡眠。当然它也可以在需要更多页面时被提前唤醒。如果任何内存区域的可用空间低于一个阈值，kswapd初始化页框回收算法。</p>

<p>56.每次PFRA（页框回收算法）执行，它首先回收容易的页面，然后处理难的。可丢弃页面和未被引用的页面都是可以被立即回收的，同时把它们添加到区域的空闲链表中。共享页面带来的挑战是，如果一个页面被回收，那么所有共享了该页面的所有地址空间的页表都要同步更新。Linux维护高效的类似树的数据结构来方便的找到一个共享页面的所有使用者。</p>

<p>57.PFRA用一个类似时钟的算法来选择旧页面换出。这个算法的核心是一个循环。</p>

<p>58.内存管理系统的一个方面是另一个守护进程pdflush，实际上就是一组后台守护线程。pdflush要么周期性醒来（通常是500ms），把非常旧的脏页面写回到磁盘；或者当可用的内存水平下降到一个阈值时由内核显示唤醒，把压面缓存的脏页面写回到磁盘。脏页面也可以通过显示的同步请求写出到磁盘，比如通过系统调用sync，fsync等。</p>

<p>59.Linux系统中，所有的IO设备都被当做文件来处理，并且通过与访问所有文件同样的read和write系统调用来访问。</p>

<p>60.Linux把设备当做一种特殊文件整合到文件系统中，每个IO设备都被分配了一条路径。</p>

<p>61.特殊文件（设备）分为两类，块特殊文件和字符特殊文件。块特殊文件的主要特性是：每一个块都能够被独立的寻址和访问。也就是说，一个程序能够打开一个快特殊文件，并且不用读第0块到第123块就能读第124块。磁盘就是块特殊文件的典型应用。字符特殊文件通常用于表示输入和输出字符流的设备（比如键盘，打印机，鼠标等）。</p>

<p>62.IO的另外一个例子是网络，关键概念是套接字。套接字可以被动态创建和销毁。创建一个套接字成功后，系统返回一个文件描述符。创建连接、读数据、写数据、解除连接时要用到这个文件描述符。</p>

<p>63.每个套接字支持一种特定的网络类型，这在套接字创建时指定。最常用的类型是：</p>

<p>①可靠的面向连接的字节流；</p>

<p>②可靠的面向连接的数据包流；</p>

<p>③不可靠的数据包传输。</p>

<p>第一种套接字类型允许在不同机器上的两个进程之间建立一个等同于管道的连接。第三种方式的优点是有更高的性能，而有时候它比可靠性更加重要（比如在传输多媒体时，快速比正确性更有用——及时视频聊天）。</p>

<p>64.在创建套接字时，有一个参数指定使用的协议。对于可靠字节流通信来说，使用最广泛的协议是TCP。对于不可靠数据包传输来说，UDP是最常用的协议。</p>

<p>65.一方在本地套接字上使用一个listen系统调用，它创建一个缓冲区并且阻塞，直到数据到来。另一方使用connect系统调用，并且把本地套接字的文件描述符和远程套接字的地址作为参数传递进去。如果远程一方接受了此次调用，则系统在两个套接字之间建立起一个链接。一旦连接建立成功，它的功能就类似于一个管道。</p>

<p>66.Linux中IO是通过一系列的设备驱动来实现的，每个设备类型对应一个设备驱动。设备驱动的功能是对系统的其他部分隔离硬件的细节</p>

<p>67.IO系统被划分为两大部分：处理块特殊文件的部分和处理字符特殊文件的部分。</p>

<p>68.Linux系统在磁盘驱动程序和文件系统之间放置了一个高速缓存（cache），在2.2版本内核之前，Linux系统完整的维护着两个单独的缓存：页面缓存和缓冲器缓存。2.2版本以后的Linux内核版本只有一个统一的缓存。</p>

<p>69.cache高速缓存是内核里面用来保存数以千计的最近使用的数据块的表。不管本着什么样的目的而需要一个磁盘快，系统首先检查这个块是否在cache里边。一个程序要回写一个块时，它被写到cache里，而不是直接写到磁盘上。当cache增长到超过一个指定值时，pdflush守护进程会把这个块写回到磁盘上。另外为了防止数据块被写回到磁盘之前在cache里存留太长时间，每隔30秒系统会把所有的“赃块”都写回到磁盘上。</p>

<p>70.可加载模块是在系统运行时可以加载到内核的代码块。</p>

<p>71.Linux使用虚拟文件系统（VFS）层支持很多类型的文件系统。在Linux链接时，用户可以选择要构造到内核中的文件系统。如果需要其他文件系统，可以在运行时作为模块动态加载。</p>

<p>72.Linux提供了一种指向已存在文件的目录项，称作链接。</p>

<p>73.系统提供了两种锁，共享锁和互斥锁。如果文件的一部分已经被加了共享锁，那么在上面尝试加共享锁是允许的，但是加互斥锁是不会成功的；如果文件的一部分已经被加了互斥锁，那么在互斥锁解除之前加任何锁都不会成功。</p>

<p>74.creat系统调用不仅创建了一个新文件，还以写的方式打开了这个文件。create成功时返回一个非负整数，这个非负整数叫做文件描述符。</p>

<p>75.最常使用的文件系统调用是read和write。它们每个都有三个参数：文件描述符（表明要读写的文件）、缓冲区地址（给出数据存放的位置或者读取数据的位置），长度（给出要传输的数据的字节数）。</p>

<p>76.虽然几乎所有程序都是顺序读写文件的，但是一些程序需要能够从文件的任何位置随机的读写文件。每个文件都有一个指针指向文件当前的读写位置。lseek系统调用可以改变位置指针的值，所以之后的read和write可以从文件的任何位置开始读写。</p>

<p>77.lseek有三个参数：第一个是文件描述符，第二个是文件读写位置，第三个表明读写位置是相对于文件开头、当前位置还是文件尾。lseek的返回值是当读写位置改变后的绝对位置。lseek是唯一一个从不会引起实际的磁盘寻道的文件系统调用，因为他所做的只是修改了内存中的一个值（文件读写位置）。</p>

<p>78.pipe系统调用用来创建一个shell管线。它创建了一种伪文件，用于缓冲管线通信的数据，并给缓冲区的读写都返回文件描述符。</p>

<p>79.大多数Unix文件系统不使用位图，而使用空闲列表。</p>

<p>80.打开文件描述表的重点是允许父进程和子进程共享一个文件读写位置，而给不相关的进程提供各自私有的值。</p>

<p>81.NFS网络文件系统的基本思想是允许任意选定的一些客户端和服务器共享一个公共文件系统。NFS允许一台机器同时既是客户端又是服务器。</p>

<p>82.NFS的目标之一是支持异构系统，客户端和服务器可能在不同硬件上运行不同操作系统。</p>

<p>83.NFS支持大多数的Linux系统调用，但是也许很让人惊讶的是，open和close不被支持。</p>

<p>84.当一个文件句柄发送过来要求访问文件时，它检查该句柄。如果是有效的句柄，就使用它。如果安全策略被启用，验证包含对RPC头中的认证密钥的检验。</p>

<p>85.UID为0的用户是一个特殊用户，称为超级用户（或者根用户）。超级用户能够读和写系统中的任何文件，不论这个文件为谁所有，也不论这个文件的保护模式如何。</p>

<p>86.目录也是一种文件，并且具有普通文件一样的保护模式。不同的是，目录的x比特位表示查找权限而不是执行权限。</p>

<p>87.最常用到的安全相关的系统调用是chmod。它用来改变保护模式。</p>

<p>88.当一个文件的保护模式在它被打开后修改，新模式将无法影响已经打开该文件的进程。</p>

<p>89.Linux有三种主要接口：shell、C函数和系统调用。</p>

<p>90.一个进程，或者称为一个任务，通过两个关键的部分来表示，即任务结构和描述用户地址空间的附加信息。前者常驻内存，后者可能被换出内存。</p>

<p>91.每个进程的内存模型由三个部分组成：代码、数据和堆栈。页面守护进程采用一种修改过的双指针时钟算法保证系统有足够多的空闲页。</p>

<p>92.文件系统内部主要使用三种表：文件描述符表、打开文件描述表和 i 节点表。其中 i 节点表是最重要的表，包含了文件管理所需要的所有信息和文件位置信息。</p>

<h2 id="windows-vista">第十一章  实例研究：Windows Vista</h2>

<p>1.Windows平台的动态链接库叫做DLL，可执行文件为EXE。</p>

<p>2.桩程序是进行不同的使用子系统的进程间通信的。对子系统进程的调用通常是利用内核态的本地过程调用（LPC）所提供的功能。LPC实现了跨进程的进程调用。</p>

<p>3.本地系统调用包括管理虚拟地址的跨进程功能、线程、句柄和为了运行运用来使用特定子系统的程序而创建的进程中的异常。</p>

<p>4.每次创建和打开对象的调用都返回一个结构叫句柄（类似Unix的文件描述符）给调用者。句柄在接下来用于执行对象的操作。句柄是特定于创建它们的具体的进程的。通常句柄不可以直接交给其他进程，也不能用于同一个对象。</p>

<p>5.一个进程能够复制一个可读写的句柄，并在目标进程中把它改变为只读的版本。</p>

<p>6.Windows有内核对象。Unix系统也同样支持内核态对象，例如文件、网络数据包、管道、进程、共享内存的IPC设备、消息端口、信号和IO设备。</p>

<p>7.Windows会挂载一种特殊的文件系统（为小文件做了优化）到名字空间。这个文件系统称作注册表。</p>

<p>8.内核线程调度程序负责决定哪些线程执行在系统的每一个CPU上。</p>

<p>9.如果下一个运行的线程是在一个不同的地址空间（例如进程），调度程序也必须改变地址空间。</p>

<p>10.在其他类型的操作系统中被编译进内核的功能是被Windows内核动态装载和链接的，包括网络协议栈和文件系统。</p>

<p>11.进程管理管理着进程和线程的创建和终止，包括建立规则和参数指导它们。但是线程运行方案由核心层决定，它控制着线程的调度和同步，以及它们之间相互控制的对象，如APC。进程包含线程、地址空间和一个可以用来处理进程指定内核态对象的句柄表。</p>

<p>12.在大多数PC机中，最初的初始化程序是BIOS，它知道如何在一台PC机上找到设备的标准类型。引导程序知道如何在根目录的文件系统卷之外阅读足够的信息去发现独立的Windows BootMgr程序。</p>

<p>13.为了避免由于竞争条件而过早的释放对象，对象管理器实现了一个引用计数机制，以及引用指针的概念。</p>

<p>14.对象管理器保持一个单独的句柄为每个对象计数。</p>

<p>15.信号量、互斥体和事件，都可以处理进程间的同步。事件可以在两种状态之一：已标记信号或未标记信号。如果一个线程等待事件处于已标记信号状态，线程被立即释放。如果该事件是未标记信号状态，它会一直阻塞知道一些其他线程信号释放所有被阻止的线程（通知事件）的活动或只是第一个被阻止的线程（同步事件）。</p>

<p>16.端口是进程之间交换LPC消息的通道。</p>

<p>17.动态链接库DLL，即代码是在程序运行的时候完成的链接，而非编译时。共享的库不是一个新的概念，最现代化的操作系统使用它们。</p>

<p>DLL通过允许在进程之间共享通用代码来提供系统效率，保持常用代码在内存中，处理减少从程序磁盘到内存中的加载时间。并允许操作系统的库代码进行更新时无需重新编译或重新链接所有使用它的应用程序，从而提供系统的使用能力。</p>

<p>18.Windows Vista中的进程是程序的容器。它们持有的虚拟地址空间，以及指向内核态的对象的线程的句柄。作为线程的容器，它们提供线程执行所需要的公共资源。</p>

<p>19.线程是在Windows中调度CPU的内核抽象。每个线程都有两个单独调用堆栈，一个在用户态运行，一个在内核态执行。</p>

<p>20.内核态与每个进程共享的，即用户共享数据。这个是可以由内核写的页，但是每个用户态进程只能读。</p>

<p>21.在创建一个过程时创建的进程将接收一个句柄，这个句柄允许它通过映射段、分配虚拟内存、写参数和环境变量数据、复制文件描述符到它的句柄表、创建线程来修改新的进程。</p>

<p>22.进程是持有资源的容器，线程是内核调度的实体。</p>

<p>23.线程是CPU调度的基本单位，因为操作系统总是选择一个线程而不是进程来运行。因此，每一个线程有一个调度状态（就绪态、运行态、阻塞态），而进程没有调度状态。</p>

<p>24.线程通常在用户态运行，但是当它进行一个系统调用时，就切换到内核态，并以其在用户态下相同的属性以及限制继续运行。每个线程有两个堆栈，一个在用户态使用，一个在内核态使用。</p>

<p>25.需要注意的是线程是一个调度的概念，而不是一个资源所有权的概念。任何线程可以访问其所属进程的所有对象，只需要使用句柄值，并进行核实的win32调用。</p>

<p>26.线程间可以通过多种方式进行通信，包括管道、命名管道、邮件槽、套接字、远程过程调用RPC、共享文件等。</p>

<p>管道有两种模式：字节管道和消息管道。</p>

<p>邮件槽跟管道类似，但不完全相同，它们是单向的，而管道是双向的。而且允许发送进程将消息广播给多个接收者而不仅仅是一个接收者。</p>

<p>套接字也与管道类似，只不过它们通常连接的是不同机器上的两个进程。例如，一个进程往一个套接字里面写入内容，远程机器上的另外一个进程从这个套接字中读出来。套接字同样也可以被用在同一台机器上的进程通信，但是因为它们比管道带来了更大的开销，所以一般来说它们只被用于网络环境下的通信。</p>

<p>远程过程调用RPC时一种进程A命令进程B调用进程B地址空间中的一个函数。实现RPC的时候，通常是把它作为传输层之上的抽象层来实现。例如对于Windows来说，可以通过TCP/IP套接字、命名管道、ALPC来进行传输。ALPC的全程是高级本地过程调用，他是内核态下的一种消息传递机制。ALPC的实现是通过拷贝参数以及基于消息大小的临时共享内存分配。</p>

<p>进程间可以共享对象，通过这个机制，在生产者消费者问题中用到的共享缓冲区就可以轻松的实现。</p>

<p>27.进程间也可以使用多种形式的同步对象。包括信号量、互斥量、临界区和事件。所有的这些机制只在线程上工作，而非进程。所以当一个线程由于一个信号量而阻塞时，同一个进程的其他线程会继续运行而并不会被影响。</p>

<p>信号量是一个内核态对象。</p>

<p>互斥量也是用于同步的内核态对象，但是比信号量简单，因为互斥量不需要计数器。他们其实是锁。临界区不是内核态的对象，也不能在进程间传递。</p>

<p>事件有两类：通知事件和同步事件。一个事件的状态有两种：收到信号和没收到信号。对于通知事件来说，所有等待的线程都会被释放；对于同步事件来说，如果有一个或多个线程在等待，那么有且仅有一个线程被唤醒并且事件被清除。</p>

<p>28.在下面这些情况下，当前正在执行的线程会执行调度程序代码：</p>

<p>①当前执行的线程发生了信号量、互斥、事件、IO等类型的阻塞。</p>

<p>②线程向一个对象发信号（如发一个信号或者唤醒一个事件）时。</p>

<p>③配额过期（时间）。</p>

<p>因为Windows完全是可抢占式的，在另外两种情况下，调度程序也会被调度：</p>

<p>①一个输入输出操作完成时。</p>

<p>②等待时间结束时。</p>

<p>29.当在最高的优先级有多条线程处于就绪状态，它们就按时间片轮转法来调度。如果没有就绪的线程，那么处理器空闲，并设置成低功耗状态来等待中断的发生。</p>

<p>值得注意的是，调度取决于线程而不是取决于新城所属的进程。因此调度程序并不是首先查看进程然后再是进程中的线程。它直接找到线程。调度程序并不考虑哪个线程属于哪个进程，除非进行线程切换时需要做地址空间的转换。</p>

<p>30.每个线程都有一个基于进程优先级的基本优先级和一个线程自己ID相对优先级。</p>

<p>31.线程获得互斥量却长时间得不到调度的时候会发生一个类似的问题，致使更重要的系统线程由于等待互斥量而不能运行发生饥饿。——spin自旋锁</p>

<p>32.在Windows Vista系统中，每个用户进程都有它自己的虚拟地址空间。对于x86机器，虚拟地址是32位的；因此每个进程拥有4GB大小的虚拟地址空间。其中用户态进程的虚拟地址大小为2GB（在服务器系统中，用户态进程的虚拟地址大小可以配置成3GB）。另外的2GB（或1GB）空间为内核进程所用。对于x86和x64机器，虚拟地址空间需要分页，并且页的大小一般都是固定在4kb。</p>

<p>33.虚拟地址的每页处于三种状态之一：无效、保留或提交。</p>

<p>无效页面是指一个页面没有被映射到一个内存区对象，对它的访问会引发一个相应的页面失效。</p>

<p>保留页面的功效是：可以保证栈不会太长而覆盖其他进程的数据。</p>

<p>34.对于失效页面的一个可能的优化是：在进行一次IO操作时预调入一些额外的页面。修改过的页面被集中到一起，统一进行写入操作。</p>

<p>35.Windows Vista操作系统为每个进程都单独提供了一个4GB大小的按需分页的线性地址空间，不支持任何形式的分段。</p>

<p>36.调度器选择单个线程来运行而不太关心进程。存储管理器在不同，它完全是在处理进程而不太关心线程。毕竟，是进程而非线程拥有地址空间，而地址空间正是存储管理器所关心的。</p>

<p>37.超级预读取技术尝试预先读入很多需要的页面到内存中，尽管进程尚未在这些页面上发生页面失效。这一技术通过重叠从磁盘上读入页面和执行映像中的初始化代码，减少了启动应用程序所需的延时。同时，它改进了磁盘的吞吐量。</p>

<p>38.如果内存管理器能够从内存中找到需要的页而不是去磁盘查找从而响应页面失效，则称为软异常。如果需要从磁盘进行复制，则称为赢异常。</p>

<p>39.当一个物理页面不再映射到任何进程的页表，将进入以下三种状态之一：空闲、修改或后备。</p>

<p>40.物理页面有三种不同的链表：空闲链表，后备链表和已修改链表。除此以外还有第四种链表，即全部被填零的空闲页面。系统会频繁的请求全零的页面。当为进程提供新的页面，或者读取一个文件的最后部分不足一个页面时，需要全零页面。还有第五种链表存放有硬件错误的页面（即通过硬件错误检测）。</p>

<p>41.两个系统线程——映射页面写入器和已修改页面写入器，周期性的被唤醒来检查是否系统中有足够的干净页面。如果没有，这两个线程从已修改链表的顶部取出页面，写回到磁盘，然后将这些页面插入后备链表。当一个页面被写入时没有足够的内存，就会导致死锁。</p>

<p>42.另一个称为零页面线程的低优先级线程将空闲链表中的页面写全零并将页面放入全零页链表。全零页面很可能比空闲页面更加有用。</p>

<p>43.Windows高速缓存通过把最近和经常使用的文件片段保存在内存中的方式来提升文件系统的性能。</p>

<p>44.在文件系统、高速缓存管理器和内存管理器之间管理文件最困难的方面在于文件中最后一个字节的偏移。</p>

<p>45.在Windows中，所有与硬件无关的程序，如文件系统、反病毒过滤器、卷管理器、网络协议栈，甚至内核服务，都是用IO驱动程序来实现的。</p>

<p>46.在多处理器中，可以通过关闭不需要的CPU和降低正在运行的CPU的频率来减少功耗。</p>

<p>47.休眠——该模式将物理内存复制到磁盘，然后把电力消耗降低到很低的水平。待机模式——电源管理器将整个系统降到最低的功率状态，仅使用足够RAM刷新的功率。因为不需要将内存复制到磁盘，进入待机状态比进入休眠状态的速度更快。</p>

<p>48.NTFS限制每个独立的文件名最多由255个字符组成，全路径最多有32767个字符。文件名采用Unicode编码。大多数NTFS磁盘使用4kb的快。</p>

<p>49.安全描述符描述了谁可以对对象执行何种操作。安全描述符还包括一个系统访问控制列表，不过它表示的并不是谁可以使用对象，而是哪些对象访问操作会被记录在系统范围内的安全事件日志中。</p>

<p>50.进程拥有虚拟地址空间并且是资源的容器。线程是执行的单元并被内核层使用优先级算法调度执行，该优先级算法使优先级最高的就绪线程总在运行，并且如有必要可抢占低优先级线程。</p>

<p>51.Windows支持按需分页虚拟内存。分页算法基于工作集的概念。</p>

<p>52.Windows在最近的发行版本中增加了大量的安全特性，包括用Bitlocker来加密整个卷，采用地址空间随机化（ASLR），不可执行的堆栈以及其他措施使得缓冲区溢出攻击更加困难。</p>

<h2 id="symbian">第十二章  实例研究：Symbian</h2>

<p>1.一个对象提供了具体的数据以及功能，但隐藏了具体实现。一个合理实现的对象可以被移除并被另外一个不同的对象代替，只要系统其他部分对这个对象的使用（也即其接口）保持不变。</p>

<p>2.使用内核端对象通常意味着一个应用程序具有一个对象的句柄，也就是对对象的一个引用，然后通过这个句柄来获得对该对象接口的访问。</p>

<p>3.Symbian操作系统采用了面向对象的设计。系统功能的实现是隐藏的，系统数据的使用通过系统对象已定义的接口完成。</p>

<p>4.Symbian操作系统是一个多任务多线程的操作系统。许多进程可以同时运行，相互间可以进行通信，也可以在各进程内运行多个线程。</p>

<p>5.尽管Symbian操作系统不使用虚拟内存映射，但它通过按页管理实现对内存访问，并支持页的置换，也就是说支持页面换入，但不支持页面换出。</p>

<p>6.许多应用程序具有类似的执行模式：它们向一个通信套接字写数据或者通过管道发送信息，然后在等待接收者的响应时阻塞。这样设计活动对象，是为了当它们从这种阻塞状态返回时，具有进入被调用代码的单一入口点，这简化了它们的实现。</p>

<p>7.套接字是Symbian操作系统使用的基本通信模型。它是两个端点之间抽象的通信管道。Symbian使用套接字的概念在客户端和服务器端之间，线程到设备之间以及线程之间进行通信。</p>

<p>8.Symbian操作系统中广泛使用了信号量和互斥量的一些形式。这些为进程和线程提供同步能力。</p>

<p>9.Symbian签名系统代替用户来对软件进行完整性验证，并且该验证必须被执行。Symbian操作系统识别开发人员的特殊签名。一个开发人员必须获得一个有时效限制的证书和一个特殊的智能手机，即可使用自己的数字证书来创建安装包。</p>

<h2 id="section-10">第十三章   操作系统设计</h2>

<p>1.对于通用的操作系统而言，需要留心4个基本的要素：</p>

<p>①定义抽象概念；</p>

<p>②提供基本操作；</p>

<p>③确保隔离；</p>

<p>④管理硬件。</p>

<p>2.一个操作系统最重要但可能最困难的任务是定义正确的抽象概念。</p>

<p>3.确保每个用户只能在授权的数据上执行授权的操作是系统设计的关键目标。然而，用户还希望共享数据和资源，因此隔离必须是选择性的并且要在用户的控制之下。</p>

<p>4.指导接口设计的原则：简单、完备和能够有效的实现。</p>

<p>5.对精炼的定义是以机制的最少化和清晰度的最大化实现指定的功能。换言之，每一个特性，功能和系统调用都应该尽自己的本分。它应该做意见事情并且把它做好。</p>

<p>6.Unix有一个系统调用exec，用来覆盖一个进程的虚拟地址空间。</p>

<p>7.抽象的目的是隐藏不合需要的特性，而不是隐藏值得需要的特性。</p>

<p>8.任何面相连接的机制与无连接的机制之间的权衡在于建立连接的机制要求的额外开销，以及在后续调用中避免进行连接所带来的好处。</p>

<p>9.除了在后台运行的内核线程以外，大多数操作系统还要启动许多守护进程。虽然这些守护进程不是操作系统的组成部分，但它们通常执行“系统”类型的活动。这些活动包括接收和发送电子邮件，并且对远程用户各种各样的请求进行服务，例如FTP和Web网页。</p>

<p>10.另一个有助于体系结构一致性的原理是机制与策略的分离。</p>

<p>11.独立的组合单独概念的能力称为正交性，它是简单性和完整性原理的直接结果。</p>

<p>12.在Unix中，进程的创建分为两步完成：fork和exec。创建新的地址空间与用新的内存映像装载该地址空间是分开的，这就为在两者之间做一些事情提供了可能。</p>

<p>13.对于用户线程，栈可以初始化成从虚拟地址空间的顶部向下生长，所以大小不需要预先设定。对于内核线程，大小必须预先设定，因为栈占据了某些内核虚拟地址空间并且可能存在许多栈。</p>

<p>14.重入指的是代码同时被执行两次或多次的能力。最好操作系统的大部分为可重入的，关键的数据结构用互斥量来保护，并且在中断不被允许的时刻禁用中断。</p>

<p>15.性能一旦达到一个合理的水平，榨出最后一点百分比的努力和复杂性或许并不值得。避免灾难比获得优化的性能要重要的多。</p>

<p>16.改进性能的一种一般性的方法是权衡时间与空间。</p>

<p>17.双向链表比单向链表占据更多的内存，但是经常使得访问表项速度更快。散列表甚至更浪费空间，但是要更快。</p>

<p>18.用于改进性能的一种众所周知的技术是高速缓存。</p>

<p>19.进程正在有效的使用的页面可以被标记为它的工作集，并且操作系统能够确保党进程被允许运行时，它的工作集在内存中，这样就减少了缺页的次数。</p>

<p>20.对于一个延期的软件项目，增加人力降使它更为延期。</p>

<p>21.顶尖的程序员比拙劣的程序员生产效率要高出10倍。</p>

<p>22.大多数错误不是在代码中，而是在设计中。</p>

<p>23.两三个人编写一个系统与300个人生产一个大型系统是不同的。在后一种情况下，团队结构和项目管理对于项目的成败起着至关重要的作用。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PLCrashreporter源码分析其二]]></title>
    <link href="http://kobe1941.github.io/blog/plcrashreporter-2.html"/>
    <updated>2019-01-25T23:26:26+08:00</updated>
    <id>http://kobe1941.github.io/blog/plcrashreporter-2</id>
    <content type="html"><![CDATA[<p>本篇文章主要对PLC内部用到的一些当时看源码时不太理解的底层函数进行分析，以及对一些为了理解PLC的原理需要了解的概念进行汇总。</p>

<!--more-->

<p>1.BSD和Mach层，POSIX层的区别和含义 。</p>

<p>先看YYKit的作者对这一段的<a href="&lt;https://blog.ibireme.com/2015/05/18/runloop/&gt;">表述</a> 。</p>

<p><img src="http://kobe1941.github.io/images/2019/01/25/1.png" alt="" /></p>

<p>XNU 内核的内环被称作 Mach，其作为一个微内核，仅提供了诸如处理器调度、IPC (进程间通信)等非常少量的基础服务。</p>

<p>BSD 层可以看作围绕 Mach 层的一个外环，其提供了诸如进程管理、文件系统和网络等功能。</p>

<p>IOKit 层是为设备驱动提供了一个面向对象(C++)的一个框架。</p>

<p>Mach 本身提供的 API 非常有限，而且苹果也不鼓励使用 Mach 的 API，但是这些API非常基础，如果没有这些API的话，其他任何工作都无法实施。在 Mach 中，所有的东西都是通过自己的对象实现的，进程、线程和虚拟内存都被称为”对象”。和其他架构不同， Mach 的对象间不能直接调用，只能通过消息传递的方式实现对象间的通信。”消息”是 Mach 中最基础的概念，消息在两个端口 (port) 之间传递，这就是 Mach 的 IPC (进程间通信) 的核心。</p>

<p>为了实现消息的发送和接收，mach_msg() 函数实际上是调用了一个 Mach 陷阱 (trap)，即函数mach_msg_trap()，陷阱这个概念在 Mach 中等同于系统调用。当你在用户态调用 mach_msg_trap() 时会触发陷阱机制，切换到内核态；内核态中内核实现的 mach_msg() 函数会完成实际的工作，如下图：</p>

<p><img src="http://kobe1941.github.io/images/2019/01/25/2.png" alt="" /></p>

<p>Mach 是一个 XNU 的微内核核心，Mach 异常是指最底层的内核级异常，被定义在 下 。每个 thread，task，host 都有一个异常端口数组，Mach 的部分 API 暴露给了用户态，用户态的开发者可以直接通过 Mach API 设置 thread，task，host 的异常端口，来捕获 Mach 异常，抓取 Crash 事件。</p>

<p>所有 Mach 异常都在 host 层被ux_exception转换为相应的 Unix 信号，并通过threadsignal将信号投递到出错的线程。iOS 中的 POSIX API 就是通过 Mach 之上的 BSD 层实现的。</p>

<p>因此，<code>EXC_BAD_ACCESS (SIGSEGV)</code>表示的意思是：Mach 层的<code>EXC_BAD_ACCESS</code>异常，在 host 层被转换成 <code>SIGSEGV</code> 信号投递到出错的线程。</p>

<p><img src="http://kobe1941.github.io/images/2019/01/25/3.png" alt="" /></p>

<p>2.注册信号的函数在<code>PLCrashSignalHandler</code>类里<code>registerHandlerWithSignal:</code>函数里。这个函数会首先调用<code>sigaltstack</code>函数，它的具体作用？</p>

<p><img src="http://kobe1941.github.io/images/2019/01/25/4.png" alt="" /></p>

<p><code>sigaltstack</code>函数的作用：</p>

<p>① 分配一块内存区，当然是从堆中分配，这块内存区就称为“可替换信号栈”(alternate signal stack)，顾名思义，我们就是希望将信号处理函数的栈挪到堆中，而不和进程共用一块栈区。</p>

<p>② 使用 <code>sigaltstack()</code> 系统调用通知内核“可替换信号栈”已经建立。</p>

<p>③ 接着建立信号处理函数，此时需要对 <code>sigaction()</code> 函数的 <code>sa_flags</code> 成员设立 <code>SA_ONSTACK</code> 标志，该标志告诉内核信号处理函数的栈帧就在“可替换信号栈”上建立。</p>

<p>回到 sigaltstack() 函数，该函数的第 1 个参数 sigstack 是一个 stack_t 结构的指针，该结构存储了一个“可替换信号栈” 的位置及属性信息。第 2 个参数 old_sigstack 也是一个 stack_t 类型指针，它用来返回上一次建立的“可替换信号栈”的信息(如果有的话)。</p>

<p>要想创建一个新的可替换信号栈，ss_flags必须设置为0，ss_sp和ss_size分别指明可替换信号栈的起始地址和栈大小。系统定义了一个常数SIGSTKSZ，该常数对极大多数可替换信号栈来说都可以满足需求，MINSIGSTKSZ规定了可替换信号栈的最小值。</p>

<p>如果想要禁用已存在的一个可替换信号栈，可将ss_flags设置为SS_DISABLE。</p>

<p>而<code>sigaltstack</code>第一个参数为创建的新的可替换信号栈，第二个参数可以设置为NULL，如果不为NULL的话，将会将旧的可替换信号栈的信息保存在里面。函数成功返回0，失败返回-1.</p>

<p>见stack_t的数据结构：</p>

<p><img src="http://kobe1941.github.io/images/2019/01/25/5.png" alt="" /></p>

<p>这两个参数都可以设置为 NULL。比如说，如果只是想找出已有的“可替换信号栈”而不需要去改变它，那么可以将 sigstack 这个参数指定为 NULL 。</p>

<p>stack_t 结构中的 ss_sp 成员指定了“可替换信号栈”的起始地址(内核在分配这个地址时会根据不同的硬件平台而自动对齐的，这个无需担心)，ss_size 成员指出了该栈的大小。</p>

<p>一般的，“可替换信号栈” 既可以动态分配，也可以静态分配。通常，我们可以利用 SIGSTKSZ 这个常数(iOS里为128k)指定该栈的大小，另一个常数 MINSIGSTKSZ 则表示该栈最小分配需求(在iOS里为32k)。</p>

<p><img src="http://kobe1941.github.io/images/2019/01/25/6.png" alt="" /></p>

<p>需要注意的是，内核并不会再重新划分“可替换信号栈”的大小。如果所分配的栈溢出了，那么结果将是错乱的。但是这种情况通常也无需担心，因为我们一般只用“可替换信号栈”来处理一些标准栈(主进程所用的栈)溢出这种特殊情况，因此在这种情形下，我们往往只是在 SIGSEGV 信号处理函数里做些清理，或是结束进程，抑或是使用非局部跳转用以解除标准栈溢出的问题，因此在“可替换信号栈”中也就只会分配一个或者少数几个栈帧，故而不用太担心会在此间造成溢出问题。</p>

<p>stack_t 结构中的 ss_flags 成员可以使用下面两个值：</p>

<p>SS_ONSTACK</p>

<p>如果在从当前建立的“可替换信号栈”(old_sigstack)中获取相关信息时设置该标志，那么表示进程当前正在“可替换信号栈”中执行，如果此时试图去建立一个新的“可替换信号栈”，那么会遇到 EPERM (禁止该动作) 的错误。</p>

<p>SS_DISABLE</p>

<p>如果在返回的 old_sigstack 中看到此标志，那么说明当前没有已建立的“可替换信号栈”。如果在 sigstack 中指定该标志，那么当前禁止建立“可替换信号栈”。</p>

<p>结论：<code>sigaltstack</code>函数的作用就是在在堆中为函数分配一块区域，作为该函数的栈使用。所以，虽然递归函数将系统默认的栈空间用尽了，但是当调用我们的信号处理函数时，使用的栈是它实现在堆中分配的空间，而不是系统默认的栈，所以它仍旧可以正常工作。</p>

<p><img src="http://kobe1941.github.io/images/2019/01/25/7.png" alt="" /></p>

<p><img src="http://kobe1941.github.io/images/2019/01/25/8.png" alt="" /></p>

<p>一般来说，使用可替换信号栈的步骤如下：</p>

<p>①在内存中分配一块区域作为可替换信号栈</p>

<p>②使用<code>sigaltstack()</code>函数通知系统可替换信号栈的存在和内存地址</p>

<p>③使用<code>sigaction()</code>函数建立信号处理函数的时候，通过将<code>sa_flags</code>设置为<code>SA_ONSTACK</code>来告诉系统信号处理函数将在可替换信号栈上面运行。</p>

<p>3.<code>Sigaction</code>信号处理相关函数的含义 。</p>

<p>函数原型：</p>

<p><code>intsigaction(int signum, const struct sigaction * act, struct sigaction * oldact); </code></p>

<p>第一个参数signum指明我们想要改变其信号处理函数的信号值。注意，这里的信号不能是<code>SIGKILL</code> 和<code>SIGSTOP</code>。这两个信号的处理函数不允许用户重写，因为它们给超级用户提供了终止程序的方法（ <code>SIGKILL</code> and <code>SIGSTOP</code> cannot be caught, blocked, or ignored）。</p>

<p>第二个和第三个参数是一个struct sigaction的结构体，该结构体在 <code>&lt;signal.h&gt;</code> 中定义，用来描述信号处理函数。如果act不为空，则其指向信号处理函数（修改信号的处理函数为新的act里的函数指针）。如果oldact不为空，则之前的信号处理函数将保存在该指针中。PLC就是通过这个函数来获取别的SDK注册的信号处理函数，并将其函数指针保存下来，在崩溃时进行回调。也就是说PLC本身的源码除了OC的异常外，其他信号异常都支持多个SDK的崩溃收集服务共存。</p>

<p>如果act为空，则之前的信号处理函数不变。我们可以通过将act置空，oldact非空来获取当前的信号处理函数。</p>

<p><img src="http://kobe1941.github.io/images/2019/01/25/9.png" alt="" /></p>

<p><img src="http://kobe1941.github.io/images/2019/01/25/10.png" alt="" /></p>

<p>Union联合体的意思是，这个数据结构里，在不同时候只会有一个数据有值，可能是其中的任何一个。目的是为了节省内存。</p>

<p><code>sa_handler</code>是一个函数指针，指向我们定义的信号处理函数，该值也可以是SIG_IGN（忽略信号）或者SIG_DEL（使用默认的信号处理函数）。</p>

<p>sa_mask字段说明了一个信号集，信号处理函数执行期间这一信号集要加到进程的信号屏蔽字中。仅当从信号处理函数返回时再将进程的信号屏蔽字复位为原先的值。这样在调用信号处理函数时就能阻塞某些信号。在信号处理函数被调用时，操作系统建立的新信号屏蔽字包括正在被递送的信号。因此保证了在处理一个给定信号时，如果这种信号再次发生，那么它会被阻塞到对前一个信号的处理结束为止。</p>

<p>sa_flags字段指定对信号处理的一些选项，有两个PLC里用到的选项，其含义说明如下（在 <signal.h>中定义）：</signal.h></p>

<p>SA_SIGINFO</p>

<p>此选项对信号处理程序提供了附加信息：一个指向siginfo结构的指针以及一个指向进程上下文标识符的指针。</p>

<p>SA_ONSTACK</p>

<p>若用<code>sigaltstack</code>声明了以替换栈，则将此信号递送给替换栈上的进程。</p>

<p><code>sa_sigaction</code>是一个替代的信号处理函数，当sa_flags字段设置为SA_SIGINFO时，使用该信号处理函数。需要注意的是，对于<code>sa_sigaction</code>和<code>sa_handler</code>字段，其实现可能使用同一存储区，所以应用程序只能一次使用这两个字段中的一个。</p>

<p>4.这一段代码的作用是什么？</p>

<p><img src="http://kobe1941.github.io/images/2019/01/25/11.png" alt="" /></p>

<p><code>SIG_DFL</code>是一个空函数，清掉所有信号的注册<code>sa_handler</code>，注意下方注册信号的handler函数时，用的是<code>sa_sigaction</code>而不是<code>sa_handler</code>。</p>

<p><code>SIG_DFL</code>这个宏就是把0强制转换给所定义的函数指针，意思就是一个空函数，没有任何实现。</p>

<p>这是C语言的知识点，详细推理见底部的参考链接。</p>

<p>所以这一段代码的意思就是把数组里定义的信号，其默认的信号处理动作全部清掉。</p>

<p>在PLC的实现中，这一段代码是放在<code>signal_handler_callback</code>函数里的，所以我猜原作者的意思是，当有异常信号被PLC捕捉到，调用到指定的callback函数时，把所有之前初始化PLC时注册的信号handler函数全部清掉，这是为了避免之后PLC写完线程堆栈信息文件后，重新抛出信号时再次捕获相同的信号？PLC的正常流程是写完崩溃日志后重新抛出异常信号，一般这个时候APP就崩溃了。——这是猜测，因为这个机制好像只对BSD层有效，对Mach层是怎么处理的还不知道？？</p>

<p>另外一点就是，清理所有向操作系统的信号注册，也意味着，如果你的APP集成了PLC，那么如果有第三方的SDK也有崩溃收集服务，只要你在别的SDK初始化后继续调用一下这段清理代码，别的SDK的崩溃收集服务功能就被干掉啦。本身如果自己已经集成了PLC的话，就不再需要第三方的崩溃收集服务了，而且只有你自己才有对应的符号表，所以别的SDK就算收集到了崩溃日志，也解析不出来，没啥用。当然使用PLC的<code>PLCrashReporterSymbolicationStrategy</code>不为<code>PLCrashReporterSymbolicationStrategyNone</code>那么还是会有一点符号信息的，不过，在做安装包size优化的时候，编译选项里大多数都已经去掉了符号了，所以很可能很多APP内部是没有符号的，你不选<code>PLCrashReporterSymbolicationStrategyNone</code>的枚举选项，拿到的日志也可能全部都是地址没法看。</p>

<p>5.<code>raise()</code>函数抛出异常的含义；.</p>

<p>——标准的Linux函数调用。</p>

<p>发生信号的函数: kill()、raise()。</p>

<p>捕捉信号的函数: alarm()、pause()。</p>

<p>处理信号的函数: signal()、sigaction()。</p>

<p>与kill()函数不同的是，raise()函数允许进程向自身发送信号。</p>

<p>PLC默认的处理是，当没有PLC没有callback来处理信号，就重新抛出信号，如果处理了就不抛出了。所以可能市场上的各个SDK，可能自己修改的PLC的代码实现。</p>

<p><img src="http://kobe1941.github.io/images/2019/01/25/12.png" alt="" /></p>

<p>6.<code>mach_task_self()</code>函数是做什么的？</p>

<p>——获取当前所在的进程，下图的<code>task_threads</code>函数，传入当前进程后，可以获取当前进程的所有线程。</p>

<p><img src="http://kobe1941.github.io/images/2019/01/25/13.png" alt="" /></p>

<p>7.<code>pl_mach_thread_self()</code>这个函数是做什么的？有点像是获取当前所在的线程？</p>

<p><img src="http://kobe1941.github.io/images/2019/01/25/14.png" alt="" /></p>

<p><img src="http://kobe1941.github.io/images/2019/01/25/15.png" alt="" /></p>

<p>——是的，<code>mach_thread_self()</code>函数可以获取当前线程。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class=""><span class="line">kern_return_t task_threads
</span><span class="line">(
</span><span class="line">    task_inspect_t target_task,
</span><span class="line">    thread_act_array_t *act_list,
</span><span class="line">    mach_msg_type_number_t *act_listCnt
</span><span class="line">);</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>iOS的操作系统是基于Darwin内核实现的，这个内核提供了task_threads接口让我们获取所有的线程列表（注意这里的线程是最底层的 mach 线程。），以及接口thread_info来获取单个线程的信息。</p>

<p><code>task_threads</code>的第一个参数的<code>target_task</code>传入进程标记，这里使用<code>mach_task_self()</code>获取当前进程，后面两个传入两个指针分别返回线程列表和线程个数。</p>

<p>对于每一个线程，可以用 <code>thread_get_state</code> 方法获取它的所有信息，信息填充在 _STRUCT_MCONTEXT 类型的参数中。</p>

<p>在 _STRUCT_MCONTEXT 类型的结构体中，存储了当前线程的 Stack Pointer 和最顶部栈帧的 Frame Pointer，从而获取到了整个线程的调用栈。</p>

<p>进程的内存使用信息同样放在了另一个结构体<code>mach_task_basic_info</code>中，存储了包括多种内存使用信息</p>

<p>详情见底部的参考链接。</p>

<p>8.<code>pthread_cond_init()</code>这个函数是什么意思？</p>

<p>——条件锁。一般和 <code>pthread_cond_signal()</code> 以及<code> pthread_cond_wait()</code> 配套使用。</p>

<p><img src="http://kobe1941.github.io/images/2019/01/25/16.png" alt="" /></p>

<p><img src="http://kobe1941.github.io/images/2019/01/25/17.png" alt="" /></p>

<p>9.set_reading(true)和set_reading(false)经常成对出现，这是某种形式的锁？</p>

<p>——对，其实对其包围的代码片段进行加锁。见下方的解释</p>

<p><img src="http://kobe1941.github.io/images/2019/01/25/18.png" alt="" /></p>

<p>10.<code>OSMemoryBarrier()</code>函数的作用。</p>

<p>为了达到最佳性能，编译器通常会将汇编级别的指令进行重新排序，从而保持处理器的指令流水线尽可能的满。作为优化的一部分，编译器可能会对内存访问的指令进行重新排序(在它认为不会影响数据的正确性的前提下)，然而，这并不一定都是正确的，顺序的变化可能导致一些变量的值得到不正确的结果。如果看似独立的变量实际上 是相互影响,那么编译器优化有可能把这些变量更新成了错误的顺序,导致潜在不不正确结果。</p>

<p>Memory Barriers是一种不会造成线程block的同步工具，它用于确保内存操作的正确顺序。Memory Barriers像一道屏障，迫使处理器在其前面完成必须的加载或者存储的操作。Memory Barriers常被用于确保一个线程中可被其他线程访问的内存操作按照预期的顺序执行。</p>

<p>Barriers严格限制了内存访问顺序。所有出现在barriers之前的加载和存储操作完成后，才会运行barriers之后的加载和存储操作。</p>

<p>大多数代码都应该使用barrier函数来确保在线程间共享的内存是正确同步的。</p>

<p>例如，如果我们想要初始化一个共享的数据结构，然后自动增加某个变量值来标识初始化操作完成，则我们必须使用OSAtomicIncrement32Barrier来确保数据结构的存储操作在变量自动增加前完成。</p>

<p>同样的，该数据结构的消费者也必须使用<code>OSAtomicIncrement32Barrier</code>，以确保在自动递增变量值之后再去加载这些数据。另一方面，如果我们只是简单地递增一个全局计数器，那么使用<code>OSAtomicIncrement32</code>会更安全且可能更快。</p>

<p>如果不能确保我们使用的是哪个版本，则使用barrier变量以保证是安全的。</p>

<p>值得注意的是，大部分锁类型都合并了内存屏障，来确保在进入临界区之前它前面的加载和存储指令都已经完成。</p>

<p>另外，自旋锁和队列操作总是包含一个barrier。</p>

<p><code>OSMemoryBarrier()</code>函数就是用来设置内存屏障，它即可以用于读操作，也可以用于写操作。</p>

<p>相较于<code>@synchronized</code>，OSAtomic原子操作更趋于数据的底层，从更深层次来对单例进行保护。同时，它没有阻断其它线程对函数的访问。</p>

<p>11.崩溃日志里的Binary Images是什么，有什么作用？</p>

<p>崩溃日志里的这部分内容列出了在进程被终止时加载在进程中的二进制文件（binary images）。</p>

<p>image加载的时候都会相对基地址进行重定位，并且每次加载的基地址都不一样，函数栈frame的地址是重定位后的绝对地址，我们要的是重定位前的相对地址。</p>

<p>可以看到Crash Log的Binary Images块包含每个image加载起止地址、image名、arm架构、uuid、image路径。</p>

<p>Crash时刻App加载的所有的库，其中第一行是Crash发生时我们App可执行文件的信息，可以看出为armv7，可执行文件的包得uuid位c0f……cd65，解析Crash的时候dsym文件的uuid必须和这个一样才能完成Crash的符号化解析。</p>

<p>每一行都包含了一个二进制文件的以下细节信息：</p>

<p>①在进程内的二进制文件的地址空间</p>

<p>②一段二进制的名称或者bundle id（仅针对macOS）。一个MacOS的crash report，如果二进制是OS的一部分，会在前面加上a。</p>

<p>③（仅针对macOS）二进制的短版本(short version)和bundle版本，通过破折号来分割。</p>

<p>④（仅针对iOS）二进制文件的架构名。一个二进制可能包含多个分片，每一个架构它都支持。其中只有一个可以被加载到进程中。</p>

<p>⑤一个可以唯一标示二进制文件的id，即UUID。这个值会随每一次构建而发生变化，并且它会用来定位需要符号化时的dSYM文件。</p>

<p>⑥磁盘上二进制文件的path。</p>

<p>12.PLC源码里C++实现的aync_list是数组还是链表，或者是其他的什么容器？</p>

<p>——看代码实现应该是链表</p>

<p>13.hpp文件的含义。</p>

<p>——hpp,其实质就是将.cpp的实现代码混入.h头文件当中，定义与实现都包含在同一文件，则该类的调用者只需要include该hpp文件即可，无需再 将cpp加入到project中进行编译。而实现代码将直接编译到调用者的obj文件中，不再生成单独的obj,采用hpp将大幅度减少调用 project中的cpp文件数与编译次数，也不用再发布烦人的lib与dll,因此非常适合用来编写公用的开源库。——百度百科</p>

<p>补充知识点：</p>

<p>1.abort函数会先清除对SIGABRT信号阻塞（如果有阻塞的话），然后调用raise函数向调用进程发送信号。注意：如果abort函数使得进程终止了，那终止前会刷新和关闭所有打开的流。</p>

<p>kill 函数发送信号给进程或进程组， raise 函数发送信号给自己。</p>

<p>abort 函数可以发送 SIGABRT 信号到调用进程，相当于 raise(SIGABRT) ，它使程序终止。</p>

<p>2.如何检测后台线程中更新UI？</p>

<p>从Xcode9开始，诊断选项里有个叫”Main Thread checker”的，默认是打开的，在程序运行期间，如果检测到了主线程之外的线程中更新UI，那么会在控制台中打出警告。但问题是，很多开发者选择无视，需要依赖于开发者的自觉，才能避免之类的问题。</p>

<p>也可以自己去实现一套机制，原理是通过hook UIView的-setNeedsLayout, -setNeedsDisplay, -setNeedsDisplayInRect三个方法，确保它们都是在主线程中执行。如果不是，那么让程序发生崩溃，可以强制开发者去修改。</p>

<p>3.关于Mach和BSD层，以及Mach层的异常处理见底部念茜的文章。</p>

<p>Mach异常是什么？它又是如何与Unix信号建立联系的？</p>

<p>Mach是一个XNU的微内核核心，Mach异常是指最底层的内核级异常，被定义在下 。每个thread，task，host都有一个异常端口数组，Mach的部分API暴露给了用户态，用户态的开发者可以直接通过Mach API设置thread，task，host的异常端口，来捕获Mach异常，抓取Crash事件。</p>

<p>所有Mach异常都在host层被ux_exception转换为相应的Unix信号，并通过threadsignal将信号投递到出错的线程。iOS中的 POSIX API 就是通过 Mach 之上的 BSD 层实现的。</p>

<p><img src="http://kobe1941.github.io/images/2019/01/25/19.png" alt="" /></p>

<p>参考链接：</p>

<p>1.[深入理解runloop](<a href="https://blog.ibireme.com/2015/05/18/runloop/">https://blog.ibireme.com/2015/05/18/runloop/</a> )</p>

<p>2.<a href="http://www.groad.net/bbs/forum.php?mod=viewthread&amp;tid=7336">sigaltstack() – 替换信号处理函数栈</a></p>

<p>3.<a href="http://blog.jobbole.com/101619/">Linux 信号应用之黑匣子程序设计</a></p>

<p>4.<a href="https://www.cnblogs.com/nufangrensheng/p/3515945.html">信号之sigaction函数</a></p>

<p>5.<a href="https://www.cnblogs.com/liulipeng/p/3555395.html">#define SIG_DFL ((void(*)(int))0)</a></p>

<p>6.<a href="https://blog.csdn.net/yishizuofei/article/details/78351119">* (<em>(void(</em>) ())0)();——这是什么？</a></p>

<p>7.<a href="https://www.jianshu.com/p/22a077fd51f1">质量监控-资源使用</a></p>

<p>8.<a href="https://bestswifter.com/callstack/">获取任意线程调用那些事</a></p>

<p>9.<a href="http://southpeak.github.io/2014/10/17/osatomic-operation/">OSAtomic原子操作</a></p>

<p>10.<a href="http://www.cocoachina.com/ios/20150701/12301.html">漫谈iOS crash收集框架</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PLCrashreporter源码分析其一]]></title>
    <link href="http://kobe1941.github.io/blog/plcrashreporter-1.html"/>
    <updated>2019-01-19T22:53:32+08:00</updated>
    <id>http://kobe1941.github.io/blog/plcrashreporter-1</id>
    <content type="html"><![CDATA[<p>大概总共会分三篇文章来分析PLC，第一篇讲整体的工作流程，第二篇梳理PLC内部使用到的一些特殊函数的含义，第三篇会尝试做一个实践。</p>

<p>不定期更新，我想明白PLC的某个细节可能就会来更新一下。</p>

<!--more-->

<p>代码在GitHub的<a href="&lt;https://github.com/plausiblelabs/plcrashreporter&gt;">仓库地址</a>，只不过GitHub上的代码只是一份镜像，几年都没有更新了。</p>

<p>有一个<a href="https://www.plcrashreporter.org/">官网</a>可以下载最新的代码和查看部分文档。</p>

<p>本次以GitHub上的代码为主。clone到本地后打开工程，可以看到以下工程目录：</p>

<p><img src="http://kobe1941.github.io/images/2019/01/19/1.png" alt="" /></p>

<p>CrashDemo目录下的main.m是入口，了解PLC的原理和流程，从这里开始就可以了。</p>

<p>整体流程：</p>

<p>1.入口</p>

<p>①main函数里配置好PLCrashReporterConfig，然后初始化一个PLCrashReporter，保存下任何已经存在的崩溃日志save_crash_report(reporter);</p>

<p>②设置好崩溃时，收集完崩溃日志后的回调PLCrashReporterCallbacks，</p>

<p>③调用PLCrashReporter的 enableCrashReporterAndReturnError函数开启崩溃信号拦截和崩溃日志收集服务。</p>

<p><img src="http://kobe1941.github.io/images/2019/01/19/2.png" alt="" /></p>

<p>2.注意上述流程的设置callback这一步，PLCrashReporter内部有一个静态全局变量用来保存该callback函数指针，当崩溃发生时PLC会收集崩溃日志，收集完成后会来回调这个callback，这个是PLC提供给外部的额外回调，你可以在这里做一些类似统计打点或者数据落地的工作。demo里这个callback就仅仅只是打印了一个log而已；</p>

<p><img src="http://kobe1941.github.io/images/2019/01/19/3.png" alt="" /></p>

<p><img src="http://kobe1941.github.io/images/2019/01/19/4.png" alt="" /></p>

<p><img src="http://kobe1941.github.io/images/2019/01/19/5.png" alt="" /></p>

<p>3.PLCrashReporter内部的enableCrashReporterAndReturnError函数，是用来启动崩溃信号捕获的函数；</p>

<p>①首先第一段代码用来确保，单个APP进程仅有一份PLCrashReporter的实例存在；</p>

<p><img src="http://kobe1941.github.io/images/2019/01/19/6.png" alt="" /></p>

<p>②创建文件目录，当后面收集到崩溃日志时要立马写文件；</p>

<p><img src="http://kobe1941.github.io/images/2019/01/19/7.png" alt="" /></p>

<p>③创建一个崩溃之前的page-guarded allocator，我自己理解是崩溃时用来保护内存的page避免崩溃时的信息丢失。</p>

<p>signal_handler_context是一个全局结构体变量，内部有好几个变量，包括writer，path，allocator，dynamic_loader，如果定义的是Mach的异常，则还有一个mach的port变量，这些变量都会在下面逐一进行初始化赋值。</p>

<p>先看看这个结构体，见下图：</p>

<p><img src="http://kobe1941.github.io/images/2019/01/19/8.png" alt="" /></p>

<p>在此时创建的正是这个allocator，如下图，取这个结构体的一个allocator的地址传给构造函数</p>

<p><img src="http://kobe1941.github.io/images/2019/01/19/9.png" alt="" /></p>

<p>C++的函数在内部创建好后，对该指针进行赋值：</p>

<p><img src="http://kobe1941.github.io/images/2019/01/19/10.png" alt="" /></p>

<p>同时把文件目录赋值给该静态的结构体的一个内部文件指针：</p>

<p><img src="http://kobe1941.github.io/images/2019/01/19/11.png" alt="" /></p>

<p>创建dynamic loader，取结构体的该变量的地址，在构造函数内部对该指针进行赋值：</p>

<p><img src="http://kobe1941.github.io/images/2019/01/19/12.png" alt="" /></p>

<p><img src="http://kobe1941.github.io/images/2019/01/19/13.png" alt="" /></p>

<p>④之后是初始化结构体里的另外一个变量writer。</p>

<p>这个是当崩溃时收集到线程堆栈信息后用来写文件用的，当然还要传入另一个符号化策略的参数PLCrashReporterSymbolicationStrategy，有三个值，None，Table或者Objc，或者Table和Objc，一般选None比较合适，因为你崩溃的时候去做符号化，一来耗时比较长，二来有些APP在Xcode的编译选项里设置了strip symbol的话（见另一篇安装包size优化的文章），这里是拿不到符号的，另外就是网上有人反应，这里的符号化不够准确，没有代码行数，另外也没有系统动态库比如UIKit的符号。所以直接选None就好了，崩溃日志收集到之后，再用符号表统一进行符号化即可。</p>

<p>这个初始化writer的操作跟之前的差不太多，都是传入指针，构造函数new一个对象出来后，对指针进行赋值。多的一点就是writer是一个结构体，内部很多基本类型变量的初始化，也是在这个函数里做的，同时因为类的封装问题，内部还有一个plcrash_async_symbol_strategy_t的枚举跟PLCrashReporterSymbolicationStrategy一一对应，这里也一起做了转换：</p>

<p><img src="http://kobe1941.github.io/images/2019/01/19/14.png" alt="" /></p>

<p>⑤注册C和C++的异常处理</p>

<p>这里分两种，BSD层和Mach层，不同的层的信号处理策略不太一样，在使用的时候通过枚举变量选择使用哪一层的异常处理。</p>

<p>PLC默认仅处理这6中信号的异常</p>

<p><img src="http://kobe1941.github.io/images/2019/01/19/15.png" alt="" /></p>

<p>这里有一个分支分别处理BSD层和Mach层的异常，使用的时候可以二选一。</p>

<p>BSD层</p>

<p>对信号数组进行遍历，分别给对应的异常信号注册回调和context，这个context是上方提到的全局静态变量，其实就是个单例。</p>

<p><img src="http://kobe1941.github.io/images/2019/01/19/16.png" alt="" /></p>

<p>Mach层</p>

<p>就像注释里所讲的，Mach层也需要额外对SIGABRT信号做注册。</p>

<p>Mach层对其他信号的捕获是通过启动一个machServer来实现的，在创建这个machServer的时候，传入了三个变量的地址，方便在构造函数里对这几个变量进行赋值。</p>

<p>mach_exception_callback是mach层捕获到异常信号时的回调，跟BSD层的signal_handler_callback回调函数想对应。</p>

<p><img src="http://kobe1941.github.io/images/2019/01/19/17.png" alt="" /></p>

<p>在开启Mach层的server后，传入的_previousMachProts也被创建好了，之后要设置一下静态全局变量的port_set:</p>

<p><img src="http://kobe1941.github.io/images/2019/01/19/18.png" alt="" /></p>

<p>⑥注册OC的异常处理handler函数</p>

<p><img src="http://kobe1941.github.io/images/2019/01/19/19.png" alt="" /></p>

<p>PLC没有对OC的异常做多SDK兼容性处理，常见的兼容性处理是调用 NSGetUncaughtExceptionHandler()函数获取之前别的SDK注册的handler，用一个全局变量保存，当OC异常进行回调时，自己处理完后，对之前的handler也进行一次回调，然后再去调用abort函数。</p>

<p><img src="http://kobe1941.github.io/images/2019/01/19/20.png" alt="" /></p>

<p>OC的NSException里有异常名字，原因和线程回溯。</p>

<p><img src="http://kobe1941.github.io/images/2019/01/19/21.png" alt="" /></p>

<p>上面就是所有的注册信号处理函数的所有流程了，还是比较清晰的。</p>

<p>4.下面来看具体注册信号的细节，这些实现决定了发生崩溃时，怎么进行回调。</p>

<p>从三个方面来分析，以此是BSD层，Mach层和OC的异常处理。</p>

<p>①BSD层的信号处理细节</p>

<p>最外层传入的回调函数是signal_handler_callback，传入之后会被保存到静态全局变量shared_handler_context的callbacks里。</p>

<p><img src="http://kobe1941.github.io/images/2019/01/19/22.png" alt="" /></p>

<p>具体的注册信号函数在PLCrashSignalHandler类里registerHandlerWithSignal:函数里。</p>

<p>shared_handler_context则是另一个静态的结构体，也可以认为是个单例。这里保存了传入的context和callBack，同时内部用一个List的结构来支持保存多个信号的注册回调callback和context。</p>

<p><img src="http://kobe1941.github.io/images/2019/01/19/23.png" alt="" /></p>

<p>需要注意的是，上方有一个nasync_prepend()的函数，在实际的注册函数里，还会调用nasync_append()函数。这两个函数的差别是，append是拼接到List的末尾，而prepend则是插入到首部的位置。如果已经注册过该信号到List里则直接返回，不做额外处理。</p>

<p>具体在执行上，prepend函数是把传进来的callback和context封装的结构体插入到了callbacks的List的最前面的位置。</p>

<p>而注册函数内部的append函数的操作，其结构体的context是NULL，然后callback是 previous_action_callback，而不是传进来的callback，其是把一个新的结构体，插入到callbacks的List的最后面：</p>

<p><img src="http://kobe1941.github.io/images/2019/01/19/24.png" alt="" /></p>

<p>所以当异常信号发生时，外部传入的callback函数，和这个previous_action_callback函数都会被调用。</p>

<p>这里要注意一下previous_action_callback这个函数，下面会做分析。</p>

<p>具体的注册信号函数在PLCrashSignalHandler类里registerHandlerWithSignal:函数里。</p>

<p>每一个信号注册过后，信号和这个信号之前旧的处理函数（ sa_prev）都会被构造成一个结构体，该结构体被append到shared_handler_context全局静态变量的previous_actions结构里，这个previous_actions跟callbacks是一样的List。</p>

<p>当然，如果一个信号已经被PLC注册过了（就是说已经在previous_actinos里），是不会重复注册的。</p>

<p><img src="http://kobe1941.github.io/images/2019/01/19/25.png" alt="" /></p>

<p>如果该信号没注册就进行注册，注册信号使用sigaction函数，关联上signo和sa变量就算注册好了，信号过来时，会回调赋值给sa变量的sa_sigaction的函数。下图中就是 plcrash_signal_handler这个函数，所以崩溃时，最开始的回调入口就是plcrash_signal_handler函数。</p>

<p>但是如果该信号之前被别的SDK注册过，PLC会保存下来，之后当异常信号发生时再统一进行回调，这里是把之前别的SDK注册该信号的handler添加到了shared_handler_context.previous_actions的List里：</p>

<p><img src="http://kobe1941.github.io/images/2019/01/19/26.png" alt="" /></p>

<p>注册的时候，sa_sigaction是取了plcrash_signal_handler这个函数的地址，也就是说，如果有异常信号过来，会回调plcrash_signal_handler这个函数。</p>

<p>看一下这个函数的实现</p>

<p><img src="http://kobe1941.github.io/images/2019/01/19/27.png" alt="" /></p>

<p>注释告诉我们，除非你是进行单元测试，否则这个函数不要去手动调用。</p>

<p>同时看注释可以知道，如果崩溃发生时，callbacks的List里，没有任何人来处理这个收到的信号，则会重新把该信号抛出来。</p>

<p>问题：如果处理了，是否信号就不会被再次抛出来了？那么如果APP内有多个SDK都有类似PLC的崩溃收集服务，如何兼容呢？ ——PLC内部做了兼容，sigaction函数会把之前的信号处理handler函数一起保存到callbacks里，崩溃发生时会统一进行回调。但是据说实际工作可能有问题，需要测试才知道。</p>

<p>继续往下看，这个函数对静态全局变量的callbacks的List进行遍历，对每一个元素进行递归调用，最终每个被添加到callbacks里的handler都会被调用到。</p>

<p>函数里的prev指针，指向context，而context外部传入的是NULL，next()函数传入NULL，那么会返回_head指针，也就是List的头结点，所以current初始值就是List的头结点。</p>

<p>如果List里有多个值，也就是说有多个处理信号的callback函数，则递归的调用该函数，其实也就是相当于一个数组，对数组遍历，让数组里的每个元素都能处理该信号。</p>

<p><img src="http://kobe1941.github.io/images/2019/01/19/28.png" alt="" /></p>

<p>上方提到了previous_action_callback这个函数，作为callback加入到shared_handler_context.callbacks的List的尾部。</p>

<p>所以当崩溃发生时遍历callbacks的List时，除了回调之前外部传入的callback函数，也会回调previous_action_callback这个函数。</p>

<p>我们来看下previous_action_callback这个函数的实现：</p>

<p>就像注释里说的，如果在PLC注册信号之前，进程内已经有别的handler注册了该信号，那么此处也会递归的调用这些handler：</p>

<p><img src="http://kobe1941.github.io/images/2019/01/19/29.png" alt="" /></p>

<p>如果没有的话，则执行默认的处理逻辑：</p>

<p>遍历previous_actions的List，如果信号类型能比对上，则调用之前注册时设置的sa_sigaction函数。这里可以对应最初保存别的SDK注册信号的处理：</p>

<p><img src="http://kobe1941.github.io/images/2019/01/19/30.png" alt="" /></p>

<p>需要注意的是，遍历的时候，只要信号类型（比如SIGABRT）对的上，那么就去找sa_flags对应的标记，如果你注册的是sigaction的sa_sigaction那么回调这个，如果注册的是sa_handler，则对应进行回调。SIG_IGN表示忽略则不进行额外处理，SIGDFL是一个空函数，会在下一篇文章里进行分析，目前知道一下就好。</p>

<p>if-else的逻辑进行了区分处理。但是不管怎样，只要找到一个handler处理完毕后就直接break跳出循环了。</p>

<p><img src="http://kobe1941.github.io/images/2019/01/19/31.png" alt="" /></p>

<p>关于BSD层的信号回调函数signal_handler_callback，这个函数会在callbacks的List遍历时进行回调，它也是PLC抓线程堆栈信息和写文件的核心。</p>

<p>注册的时候，取这个函数的地址作为参数传入注册函数，后面崩溃信号来的时候，就会对这个函数进行回调。</p>

<p>下图这个函数的第一步更像是一个清理信号的操作？——崩溃信号过来时，清理掉所有信号的注册handler。正常流程也是收集完崩溃日志后就让APP崩溃，留着这些信号handler也没用。</p>

<p><img src="http://kobe1941.github.io/images/2019/01/19/32.png" alt="" /></p>

<p>后面一步则是获取线程状态，去初始化context，然后进行一些BSD和Mach层的信息转换：</p>

<p><img src="http://kobe1941.github.io/images/2019/01/19/33.png" alt="" /></p>

<p>之后就是去抓取线程堆栈的状态信息然后写文件了，写完文件后去回调用户额外的一个callback，这个callback是main函数里设置好的：</p>

<p><img src="http://kobe1941.github.io/images/2019/01/19/34.png" alt="" /></p>

<p>plcrash_write_report是核心，暂停线程，抓线程堆栈信息，写文件和恢复线程都在这个函数里。</p>

<p>如下图所示，基本步骤是打开指定目录的文件，初始化writer，用writer写文件，然后关闭writer，之后再把数据落地，然后关闭文件。open()，close()，write()这些函数都是Unix标准的系统调用。</p>

<p><img src="http://kobe1941.github.io/images/2019/01/19/35.png" alt="" /></p>

<p>具体抓线程信息和写文件的关键实现在plcrash_log_writer_write这个函数里，这个函数内部会去读image_list，获取所有线程，暂停除了当前线程之外的所有线程，</p>

<p><img src="http://kobe1941.github.io/images/2019/01/19/36.png" alt="" /></p>

<p>然后写数据。写数据包括写文件头部信息，写手机的硬件和操作系统等信息，然后写线程堆栈，写Binary Images信息，</p>

<p><img src="http://kobe1941.github.io/images/2019/01/19/37.png" alt="" /></p>

<p>需要注意的是，单个线程的堆栈地址获取，是在图中的plcrash_writer_write_thred()这个函数里去做的。</p>

<p><img src="http://kobe1941.github.io/images/2019/01/19/extra_1.png" alt="" /></p>

<p>这个函数会去读取thread当前的寄存器状态值，把当前函数调用的堆栈，全部保存到一个链表式的结构体里（其实就是栈的数据结构）。</p>

<p>其内部实现如下图：</p>

<p><img src="http://kobe1941.github.io/images/2019/01/19/extra_2.png" alt="" /></p>

<p>说到底还是调用了thread_get_state()这个函数。
thread_get_state()函数用于读取每个线程当前的寄存器状态，拿到这些寄存器的值了之后，就可以获取到该线程当时的代码执行堆栈地址。只要对地址进行符号化后，就是我们熟悉的崩溃日志里某个线程的堆栈了。</p>

<p>PLC在这一块的处理比较绕，可以看看<a href="https://github.com/bestswifter/BSBacktraceLogger">BSBackTraceLogger</a> 这个库，在调用thread_get_state()获取到一个线程的状态后，是如何遍历获取堆栈的指针值的（当然BSBackTraceLogger里对堆栈地址进行符号化的操作没啥必要）。</p>

<p><img src="http://kobe1941.github.io/images/2019/01/19/extra_3.png" alt="" /></p>

<p>如果有额外的OC异常信息，也会把OC的异常信息写入到文件，之后还会写一下信号的信息到日志里，</p>

<p><img src="http://kobe1941.github.io/images/2019/01/19/38.png" alt="" /></p>

<p>最后就是恢复所有线程让其继续执行，然后一些清理内存和端口的工作。</p>

<p><img src="http://kobe1941.github.io/images/2019/01/19/39.png" alt="" /></p>

<p>②Mach层的信号处理细节</p>

<p>传入一个MachPort的地址和callback函数的地址，供开启server函数的内部赋值用：</p>

<p><img src="http://kobe1941.github.io/images/2019/01/19/40.png" alt="" /></p>

<p>Mach层的开启server的函数内部的实现，exc_mask是一个exception_mask_t类型的枚举变量，用来表示Mach层的异常类型用的。</p>

<p><img src="http://kobe1941.github.io/images/2019/01/19/41.png" alt="" /></p>

<p>用外部传入的callback和context作为传入参数创建了一个server，然后用exc_mask返回了一个异常端口port，之后用这个端口去注册了一个task，然后就结束啦，虽然也看不懂具体在做啥，反正就是注册异常信号，有异常信号过来时就回调之类的。</p>

<p><img src="http://kobe1941.github.io/images/2019/01/19/42.png" alt="" /></p>

<p>Mach层不太能看得懂里边的具体实现细节，比如上图中的server的构造函数，里边全是mach_port开头的函数，这个后面等我看懂了再来补充吧。</p>

<p>总之有一点原则就是，最初构造server时传入的callback一定会在异常信号过来时会被回调，至于是怎么回调的以后看懂再说嘛。。。</p>

<p>最开始注册Mach异常时外部传入的 _previousMachPorts 在这里进行了赋值：</p>

<p><img src="http://kobe1941.github.io/images/2019/01/19/43.png" alt="" /></p>

<p>接下来看看Mach层的异常回调函数mach_exception_callback的实现，跟BSD层的signal_handler_callback大致是类似的，有几个不同的点：</p>

<p>一是在回调main函数设置的callback之前做了些信号之间的转换，</p>

<p><img src="http://kobe1941.github.io/images/2019/01/19/44.png" alt="" /></p>

<p><img src="http://kobe1941.github.io/images/2019/01/19/45.png" alt="" /></p>

<p>中间的这一部分，看注释也能明白，就是写线程堆栈信息的，然后Mach层读取线程状态和写文件不是走的C函数，而是一个汇编语言实现的函数plcrash_async_thread_state_current 。</p>

<p><img src="http://kobe1941.github.io/images/2019/01/19/46.png" alt="" /></p>

<p>二是多了个PLCrashMachExceptionForward函数，目的是让其他注册的server也能够处理收到的异常信号，当然这个函数内部要么调用exception_raise函数针对端口重新抛出异常信号，要么返回失败让程序继续往下走，如果重新抛出异常，则mach_exception_callback这个函数会根据raise函数的返回值（正常流程是返回失败，所以要看exception_raise的返回值）决定是否需要直接返回。</p>

<p><img src="http://kobe1941.github.io/images/2019/01/19/47.png" alt="" /></p>

<p><img src="http://kobe1941.github.io/images/2019/01/19/48.png" alt="" /></p>

<p>③OC的异常处理函数比较简单，上方已经贴过代码实现。简而言之就是把 signal_handler_context这个静态全局变量的writer传入到OC的异常处理函数里，当系统给OC异常做回调时，拿到writer，把NSException的name和reason还有backtrace这些值写到writer里。在writer写文件落地时，就可以把这些数据一起写到崩溃日志里了。</p>

<p>实际上你看崩溃日志也可以发现OC的异常，是有reason的，比如常见的数组越界，不能响应的方法之类的，都会在崩溃名字里直接显示出来，而C和C++的崩溃日志，其名字里就只有崩溃的信号名称比如SIGSEGV，而没有更多的原因和信息。</p>

<p>关于OC的异常处理，这里有个疑问点，APP发生了OC的异常崩溃后，是怎么抓取所有线程的堆栈的？——可能OC的异常，一样会触发BSD或者Mach层的异常信号。看代码逻辑是这样子，待验证。</p>

<p>下图中，OC异常的信息写入是在线程和Binary Images信息之后的位置的，</p>

<p><img src="http://kobe1941.github.io/images/2019/01/19/49.png" alt="" /></p>

<p>这是OC的异常过来时，uncaught_exception_handler这个函数调用的。</p>

<p><img src="http://kobe1941.github.io/images/2019/01/19/50.png" alt="" /></p>

<p>5.PLC的自定义异常日志收集</p>

<p>除了真的崩溃的时候可以收集到所有线程堆栈的日志，PLC还支持自定义错误信息收集，此时会去抓所有线程的堆栈，预留了接口来实现。</p>

<p><img src="http://kobe1941.github.io/images/2019/01/19/51.png" alt="" /></p>

<p>需要注意的是，生成自定义日志的接口需要传入一个thread对象，这个thread表示crash的线程。函数里边做了个判断，如果传入的thread是当前正在执行代码的线程，则走的是汇编的函数实现，否则才去走跟BSD层一样的C函数实现逻辑。PLC的单元测试里都是新建一个thread传入这个接口。</p>

<p><img src="http://kobe1941.github.io/images/2019/01/19/52.png" alt="" /></p>

<p>事实上， plcrash_log_writer_write这个函数内部也用断言做了判断，注释里也写的比较清楚，如果crash的线程是当前执行代码的线程，则必须提供context：</p>

<p><img src="http://kobe1941.github.io/images/2019/01/19/53.png" alt="" /></p>

<p>要打印当前执行代码的线程，必须要提供context，否则无法抓取到线程的堆栈信息</p>

<p><img src="http://kobe1941.github.io/images/2019/01/19/54.png" alt="" /></p>

<p>6.其他信息</p>

<p>原始崩溃日志的文件格式是protobuf，PLC有一个专门的格式化的类可以用来处理格式的转换，上传崩溃日志的时候用的上。</p>

<p>另外protobuf格式的文件比json格式的文件压缩比要高，同一份文件protobuf格式比json格式的数据量要小，所以一些公司在TCP长连接的时候会采用这种格式来传输数据，消耗的流量更小一些，对弱网的支持会更好。</p>

<p>TODO:</p>

<p>1.把PLC放到demo里跑起来，测试一下从收到信号到重新抛出信号，PLC的总耗时和各个阶段的耗时；</p>

<p>2.测试一下崩溃发生时，OC异常和C++异常的回调时序是怎样的？ BSD或Mach层的信号回调和OC的信号回调，这两者会有一个先后顺序的问题，需要测试一下先后顺序，是否会影响到崩溃日志的收集？</p>

<p>3.在PLC的基础上尝试封装完成一个检测ANR和捕获到ANR时抓堆栈信息的模块，测试抓堆栈和写文件的时间，也许可以改成异步写文件；</p>

<p>4.OC的异常处理函数这里处理完后直接调用了abort()函数，理论上APP这个时候会崩溃，但是这个信号按照原理来说同样会被PLC捕获，具体的处理还有待分析。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[腾讯体育iOS客户端逆向实践]]></title>
    <link href="http://kobe1941.github.io/blog/tencent-sports.html"/>
    <updated>2018-11-11T19:40:58+08:00</updated>
    <id>http://kobe1941.github.io/blog/tencent-sports</id>
    <content type="html"><![CDATA[<h4 id="section">最终实现的结果：</h4>

<p>可以跳过闪屏+直播间广告，如果是免费的比赛，或者你是会员的话，可以提取直播间的超清直播URL（蓝光画质是服务器鉴权），该URL可以复制到手机Safari或者电脑端播放。</p>

<h4 id="section-1">实践总结：</h4>

<p>1.所有拉流直播链接都是服务器鉴权的，即使免费的比赛，你未登录时也会给你分配一个key；</p>

<p>2.一个普通非会员账号，是可以蹭几场会员才能看的比赛的，但是因为腾讯体育的服务器对同个账号的拉流有IP数量限制和流量限制，所以一般说来，除非是免费的比赛，否则不要把链接扩散给别人，另外就是蹭了几场比赛后，你的账号拿到的拉流URL，将只能试看1分钟，之后被断流。腾讯体育支持微信和QQ登录，你也可以准备多个账号用来救急某些重要比赛，当然还是买会员支持正版比较直接啦；</p>

<p>3.会员才能看的比赛，非会员也有一个方式可以看直播，清晰度一般但是勉强能看。<strong>还是买会员看蓝光画质美滋滋</strong>；</p>

<p>4.直播间获取直播链接的接口前缀为：<code>http://info.zb.video.qq.com/</code>，后面会拼接很多的参数，其中一个key跟用户账号绑定，服务器用这个来做ip打击和流量控制，抓包请认准该接口，返回数据为json格式，<strong>未做二次加密</strong>。在腾讯体育APP里，这个请求是用<code>NSURLConnection</code>这个类发出去的，要hook的话也要hook这个类的网络请求，而不是<code>NSURLSession</code>；</p>

<p>5.腾讯体育的直播拉流协议使用HLS，你用Charles抓包会看到ts文件不断的被下载下来播放。</p>

<!--more-->

<p>以下是具体操作流程，大致分为越狱，砸壳，静态分析，动态分析，写hook函数这么几个过程。</p>

<p>需要准备的硬件工具：</p>

<p>越狱手机，Windows电脑和Mac电脑。</p>

<h2 id="ios933">iOS9.3.3系统的越狱</h2>

<p>PP助手的Mac版已经没有在维护了，用Windows最新版本的pp助手可以实现一键越狱。如果手机越狱完了，重启之后Cydia会闪退，解决方案：</p>

<p>手机Safari打开 <a href="http://z.25pp.com">z.25pp.com</a> 然后选择越狱版页面，点击iOS9.3.x越狱激活，按照指示的去做就OK（此步骤网络必须要OK）。之后如果出现重启手机后Cydia闪退，按照上述步骤做一次即可打开Cydia。</p>

<p>注意：执行上述步骤时，请退出Mac上的pp助手。</p>

<h2 id="dumpdecrypted">dumpdecrypted砸壳</h2>

<p>需要注意的点是，如果砸壳失败，很有可能是dumpdecrypted出了问题，比如更新Xcode后，默认的SDK可能会有更改，重新拉代码make生成dumpdecrypted.dylib一般可以解决。</p>

<p>砸壳后拷贝到电脑端的是类似QQSportsV3.decrypted这种文件，把文件后缀直接去掉，然后chmod 777修改文件的权限为可读可写可执行，然后就可以进行class-dump和拷贝到APP包里替换掉原来的二进制文件了。</p>

<h2 id="section-2">静态分析</h2>

<p>①使用class-dump把砸壳后的二进制导出头文件；</p>

<p>②利用monkeyDev把目标APP用Xcode跑起来，在你想要的页面用Xcode查看这个页面的view所属的类，然后通过nextResponder去找响应链可以找到对应页面的控制器或跟这个view相关联的类；</p>

<p>③用sublime打开所有头文件，找到你想要分析的类，观察其属性的函数接口，如果函数很多的话，找到目标函数需要花的时间跟运气直接相关，一般也可以通过一些搜索匹配关键字来过滤；</p>

<p>④hooper或者IDA静态分析二进制文件，搜索定位到对应的类和函数，看其内部实现。</p>

<h4 id="ocblock">恢复符号表（OC+Block）</h4>

<p>因为你已经知道一些基本的类和函数名了，Xcode跑起来后可以设置一些符号断点，进行调试和观察。此时需要先恢复符号表，才能看到断点后具体的堆栈调用回溯。</p>

<p>恢复符号表可以参考这篇文章 <a href="http://blog.imjun.net/posts/restore-symbol-of-iOS-app/">http://blog.imjun.net/posts/restore-symbol-of-iOS-app/</a></p>

<p>如果用monkeyDeb创建的工程，OC的符号表恢复可以通过targets→beuild settings 的最下面的User-define里设置MONKEYDEV_RESTORE_SYMBOL为YES，但是block符号需要手动去恢复。</p>

<p>需要注意的就是，在用Xcode查看调用堆栈是，Xcode左侧边栏可能仅显示1个或2个调用，NSThread的callStackSymbols函数可能会打印出一些字符串很奇怪的函数调用堆栈，这并不代表block符号恢复失败，这个情况，通常要用LLDB的bt指令去检查看下是否OK。</p>

<h2 id="section-3">动态挂载分析</h2>

<p>可以参考这里提供的函数调用打印<a href="http://bbs.iosre.com/t/app-ios/12157">http://bbs.iosre.com/t/app-ios/12157</a> 辅助分析。其实就是使用了一个叫做HookZz的库。</p>

<p>动态分析主要是指不通过Xcode，而是通过终端来调试别人的APP，如果是自己的APP，或者自己证书签名的APP，则可以用monkeyDev直接在Xcode里跑起来；</p>

<p>动态分析主要用到了debugserver和LLDB，通常在这一步前先做静态分析，才能知道要打的断点的位置，动态分析通过打断点和读取、修改寄存器值的方式来调试APP，观察APP的行为。</p>

<p>具体过程可以直接参考《iOS应用逆向工程》书里的步骤，需要注意的一点就是，使用WiFi来连接实在是有点慢，所以用iproxy通过USB来调试是比较合适的。</p>

<p><code>brew install usbmuxd</code> 安装好后即可以使用iproxy，</p>

<p>要启动debugserver，需要先ssh到越狱手机上，然后执行：</p>

<p><code>debugserver  *:1234 -a WeChat</code></p>

<p>这个指令的意思是让手机的1234端口待命，准备接受LLDB的指令，-a表示启动后面微信的process ，同时这个APP会被卡住暂停执行，所以也不会响应用户的手势；</p>

<p>在电脑上执行<code> iproxy 1234 1234</code>实现端口转发；</p>

<p>在电脑端直接执行lldb会打开lldb调试器，然后执行</p>

<p><code>process connect connect://localhost:1234</code></p>

<p>可以连接到手机上。如果不使用iproxy来做转发，则需要把localhost替换为手机的ip，同时手机要跟电脑处于同一个网段；</p>

<p>之后等待，当终端出现 <code>Process 867 stopped</code> 类似这种就说明连接成功了，执行c即可让APP继续运行。</p>

<p>连接过程中可能会出现类似<code>ImportError: cannot import name _remove_dead_weakref</code>的错误：</p>

<p><img src="http://kobe1941.github.io/images/2018/11/1.png" alt="" /></p>

<p>基本上不用理会，继续等就好了，使用USB来调试，大概等个十来秒就可以连接上，如果用WiFi，可能要等挺久的。</p>

<p>如果出现 <code>error: failed to get reply to handshake packet</code>  这个错误提示，可以尝试拔掉USB线重新连接，或者重启手机来解决，当然也有另一种尝试的方案，就是先连接下自己的证书签名的APP，然后再去连接App Store下载的APP。</p>

<p>使用LLDB的指令 ` b adress ` 或  <code>br s -a address</code>  可以对地址入口打个断点。</p>

<h2 id="section-4">去除启动闪屏+直播间90秒广告</h2>

<p>1.hook <code>TADSplashManager</code> 的<code>splashItemForItem</code>函数返回nil，可以去掉闪屏广告；</p>

<p>2.hook <code>TADVideoViewController</code>的<code>viewDidAppear</code>函数，调用其<code>skipAdPlay</code>函数可以跳过直播间90秒广告。</p>

<p>这里讲一下去掉闪屏的分析方式：</p>

<p>①直接法，通过Xcode启动APP，从UI入手，找到对应的view和控制器（nextResponder响应链），然后hook相关的函数来实现修改其逻辑。 这个方式在《iOS应用逆向工程》里讲的很清楚；</p>

<p>②间接法，所有的闪屏基本都是APP打开后先发请求去获取闪屏配置信息，然后下载闪屏内容，之后等到下次启动，检查本地有闪屏则显示，无闪屏则直接进入主页面的逻辑，而闪屏的英文是splash，所以用这个关键字在class-dump出来的头文件去搜索，会得到很多很直接的信息，我就是这么试了一下就成功的；</p>

<p>③闪屏信息通过一个接口来获取，可以block掉这个接口。</p>

<p>另外关于闪屏的设计，其实发现腾讯体育和腾讯视频基本是一模一样，连类名和接口名都没变，可能是一个团队做的？</p>

<h2 id="section-5">破解会员才能看直播的限制</h2>

<p>客户端会根据当前登录用户的状态来判断是否可以试看，服务器的接口会返回一个直播的链接和链接可以播放的时效（300秒），可以测试下这个链接是否一直有效：</p>

<p>——接口会返回一个带鉴权key的直播URL，这个链接拉流时间收到服务器限制。</p>

<p>步骤</p>

<p>①把链接地址抓出来看看是否能在Safari上播放；——可以播放</p>

<p>②hook一下客户端对播放时间的限制，去除该限制，看看是否可以一直播放下去。——不行，服务器鉴权。</p>

<p>首页普通全屏视频播放的响应链为：</p>

<p>QSFullScreenMediaPlayerViewController  ——  QSMPVideoLayersViewController。。。</p>

<p>如果不是全屏则从QSMediaPlayerViewController。。。 开始，而且是把这个控制器的view添加到了tableView上面去</p>

<p>直播间播放器的响应链反推直播间的控制器到播放器的关系为（仅代表响应链，不带表持有关系）：</p>

<p>QSMatchDetailViewController  ——  QSMatchDetailTopViewController  ——   QSMediaPlayerViewController  ——  QSMPVideoLayersViewController ——</p>

<p>QSPlayerViewController  ——  QSRootPlayerViewController  ——  KKMediaRootView  ——  QLVideoView ——  QQPlayerView  ——  QLAVPlayer/QQPlayer。</p>

<p>其中QLVideoView持有两个QQPlayerView，分别为view0和view1，（也许跟试看有关？比如正常播放用一个，试看用另一个？）；</p>

<p>QQPlayerView持有QQPlayer和QQSelfPlayerVideoView（这个只是用来做openGL相关的一个view，没有其他联系）;</p>

<p>QQPlayer持有两个类名为QQPlayerItem的数据源，同时持有QQSelfPlayer和AVPlayer；</p>

<p>QLAVPlayer继承自QQplayer；</p>

<p>QQPlayer的item是QLAVPlayerItem，其继承自QQPlayerItem。</p>

<h4 id="section-6">获取直播链接</h4>

<p>获取直播url的请求为 <code>info.zb.video.qq.com</code></p>

<p>hook <code>NSURLConnection</code>的<code>initWithRequest:delegate:</code>函数之后，发现调用栈为：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class="objective-c"><span class="line"><span class="n">frame</span> <span class="err">#</span><span class="mi">0</span><span class="o">:</span> <span class="mh">0x0000000102fa4b18</span> <span class="n">libTencentSportsDylib</span><span class="p">.</span><span class="n">dylib</span><span class="err">`$</span><span class="n">NSURLConnection_initWithRequest</span><span class="err">$</span><span class="n">delegate</span><span class="err">$</span><span class="n">_method</span><span class="p">(</span><span class="nb">self</span><span class="o">=</span><span class="mh">0x000000014fc53cb0</span><span class="p">,</span> <span class="n">_cmd</span><span class="o">=</span><span class="s">&quot;initWithRequest:delegate:&quot;</span><span class="p">,</span> <span class="n">arg1</span><span class="o">=</span><span class="mh">0x000000014fc55b80</span><span class="p">,</span> <span class="n">arg2</span><span class="o">=</span><span class="mh">0x000000014fc56550</span><span class="p">)</span> <span class="n">at</span> <span class="n">TencentSportsDylib</span><span class="p">.</span><span class="nl">m</span><span class="p">:</span><span class="mi">189</span>
</span><span class="line"><span class="n">frame</span> <span class="err">#</span><span class="mi">1</span><span class="o">:</span> <span class="mh">0x0000000100ac95e0</span> <span class="n">QQSportsV3</span><span class="err">`</span><span class="o">-</span><span class="p">[</span><span class="n">TTRequestLoader</span> <span class="nl">connectToURL</span><span class="p">:]</span> <span class="o">+</span> <span class="mi">312</span>
</span><span class="line"><span class="n">frame</span> <span class="err">#</span><span class="mi">2</span><span class="o">:</span> <span class="mh">0x0000000100acfbf0</span> <span class="n">QQSportsV3</span><span class="err">`</span><span class="o">-</span><span class="p">[</span><span class="n">TTURLRequestQueue</span> <span class="nl">sendRequest</span><span class="p">:]</span> <span class="o">+</span> <span class="mi">672</span>
</span><span class="line"><span class="n">frame</span> <span class="err">#</span><span class="mi">3</span><span class="o">:</span> <span class="mh">0x00000001009852c0</span> <span class="n">QQSportsV3</span><span class="err">`</span><span class="o">-</span><span class="p">[</span><span class="n">MakeJsonData</span> <span class="nl">createDataByRequestURL</span><span class="p">:]</span> <span class="o">+</span> <span class="mi">1032</span>
</span><span class="line"><span class="n">frame</span> <span class="err">#</span><span class="mi">4</span><span class="o">:</span> <span class="mh">0x0000000100a3598c</span> <span class="n">QQSportsV3</span><span class="err">`</span><span class="o">-</span><span class="p">[</span><span class="n">KKMediaPlayPreparer</span> <span class="nl">makeLiveProgInfo</span><span class="p">:]</span> <span class="o">+</span> <span class="mi">1428</span>
</span><span class="line"><span class="n">frame</span> <span class="err">#</span><span class="mi">5</span><span class="o">:</span> <span class="mh">0x00000001009af3fc</span> <span class="n">QQSportsV3</span><span class="err">`</span><span class="o">-</span><span class="p">[</span><span class="n">KKMediaRootViewController</span> <span class="n">startPrepareMediaToPlay</span><span class="p">]</span> <span class="o">+</span> <span class="mi">720</span>
</span><span class="line"><span class="n">frame</span> <span class="err">#</span><span class="mi">6</span><span class="o">:</span> <span class="mh">0x00000001009b12cc</span> <span class="n">QQSportsV3</span><span class="err">`</span><span class="o">-</span><span class="p">[</span><span class="n">KKMediaRootViewController</span> <span class="n">startMediaPlayToPlay</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2176</span>
</span><span class="line"><span class="n">frame</span> <span class="err">#</span><span class="mi">7</span><span class="o">:</span> <span class="mh">0x00000001009788dc</span> <span class="n">QQSportsV3</span><span class="err">`</span><span class="o">-</span><span class="p">[</span><span class="n">TVKMediaPlayer</span> <span class="nl">openMediaPlayerWithChannelID</span><span class="p">:</span><span class="nl">andPID</span><span class="p">:]</span> <span class="o">+</span> <span class="mi">516</span>
</span><span class="line"><span class="n">frame</span> <span class="err">#</span><span class="mi">8</span><span class="o">:</span> <span class="mh">0x00000001005ebcec</span> <span class="n">QQSportsV3</span><span class="err">`</span><span class="o">-</span><span class="p">[</span><span class="n">QSPlayerViewController</span> <span class="n">startMediaPlayer</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1408</span>
</span><span class="line"><span class="n">frame</span> <span class="err">#</span><span class="mi">9</span><span class="o">:</span> <span class="mh">0x00000001005eac1c</span> <span class="n">QQSportsV3</span><span class="err">`</span><span class="o">-</span><span class="p">[</span><span class="n">QSPlayerViewController</span> <span class="nl">viewDidAppear</span><span class="p">:]</span> <span class="o">+</span> <span class="mi">64</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>两个获取直播URL的方法：</p>

<p>①可以hook这个请求，匹配到URL的域名后，多发一次请求，然后解析返回的参数就可以获取直播的URL（已采用）；</p>

<p>②可以hook一下<code>-[QQMediaPlayerController prepareToPlayAsset:withMediaUrl:withIsAsset:withKeys:withCacheOrder:withMediaQuence:]</code>这个函数，第1个参数AVURLAsset里包含有直播的完整url。</p>

<p>对试看view的弹出逻辑探索：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
</pre></td><td class="code"><pre><code class="objective-c"><span class="line"><span class="n">frame</span> <span class="err">#</span><span class="mi">0</span><span class="o">:</span> <span class="mh">0x0000000188c14acc</span> <span class="n">UIKit</span><span class="err">`</span><span class="o">-</span><span class="p">[</span><span class="bp">UIViewController</span> <span class="n">viewDidLoad</span><span class="p">]</span>
</span><span class="line"><span class="n">frame</span> <span class="err">#</span><span class="mi">1</span><span class="o">:</span> <span class="mh">0x00000001002bdad8</span> <span class="n">QQSportsV3</span><span class="err">`</span><span class="o">-</span><span class="p">[</span><span class="n">QSViewController</span> <span class="n">viewDidLoad</span><span class="p">]</span> <span class="o">+</span> <span class="mi">48</span>
</span><span class="line"><span class="n">frame</span> <span class="err">#</span><span class="mi">2</span><span class="o">:</span> <span class="mh">0x00000001003a504c</span> <span class="n">QQSportsV3</span><span class="err">`</span><span class="o">-</span><span class="p">[</span><span class="n">QSWindowController</span> <span class="n">viewDidLoad</span><span class="p">]</span> <span class="o">+</span> <span class="mi">60</span>
</span><span class="line"><span class="n">frame</span> <span class="err">#</span><span class="mi">3</span><span class="o">:</span> <span class="mh">0x0000000100662030</span> <span class="n">QQSportsV3</span><span class="err">`</span><span class="o">-</span><span class="p">[</span><span class="n">QSMPAuthenticationResultViewController</span> <span class="n">viewDidLoad</span><span class="p">]</span> <span class="o">+</span> <span class="mi">64</span>
</span><span class="line"><span class="n">frame</span> <span class="err">#</span><span class="mi">4</span><span class="o">:</span> <span class="mh">0x0000000188b94b40</span> <span class="n">UIKit</span><span class="err">`</span><span class="o">-</span><span class="p">[</span><span class="bp">UIViewController</span> <span class="n">loadViewIfRequired</span><span class="p">]</span> <span class="o">+</span> <span class="mi">996</span>
</span><span class="line"><span class="n">frame</span> <span class="err">#</span><span class="mi">5</span><span class="o">:</span> <span class="mh">0x0000000188b94744</span> <span class="n">UIKit</span><span class="err">`</span><span class="o">-</span><span class="p">[</span><span class="bp">UIViewController</span> <span class="n">view</span><span class="p">]</span> <span class="o">+</span> <span class="mi">28</span>
</span><span class="line"><span class="n">frame</span> <span class="err">#</span><span class="mi">6</span><span class="o">:</span> <span class="mh">0x00000001003a5b64</span> <span class="n">QQSportsV3</span><span class="err">`</span><span class="o">-</span><span class="p">[</span><span class="n">QSWindowController</span> <span class="nl">setRootViewController</span><span class="p">:]</span> <span class="o">+</span> <span class="mi">256</span>
</span><span class="line"><span class="n">frame</span> <span class="err">#</span><span class="mi">7</span><span class="o">:</span> <span class="mh">0x00000001003a5ee8</span> <span class="n">QQSportsV3</span><span class="err">`</span><span class="o">-</span><span class="p">[</span><span class="n">QSWindowController</span> <span class="nl">setRootViewController</span><span class="p">:</span><span class="nl">animationType</span><span class="p">:]</span> <span class="o">+</span> <span class="mi">636</span>
</span><span class="line"><span class="n">frame</span> <span class="err">#</span><span class="mi">8</span><span class="o">:</span> <span class="mh">0x0000000100654b50</span> <span class="n">QQSportsV3</span><span class="err">`</span><span class="o">-</span><span class="p">[</span><span class="n">QSMediaPlayerViewController</span> <span class="nl">setRootViewController</span><span class="p">:</span><span class="nl">animationType</span><span class="p">:]</span> <span class="o">+</span> <span class="mi">76</span>
</span><span class="line"><span class="n">frame</span> <span class="err">#</span><span class="mi">9</span><span class="o">:</span> <span class="mh">0x0000000100654c10</span> <span class="n">QQSportsV3</span><span class="err">`</span><span class="o">-</span><span class="p">[</span><span class="n">QSMediaPlayerViewController</span> <span class="nl">setRootViewController</span><span class="p">:</span><span class="nl">animated</span><span class="p">:]</span> <span class="o">+</span> <span class="mi">52</span>
</span><span class="line"><span class="n">frame</span> <span class="err">#</span><span class="mi">10</span><span class="o">:</span> <span class="mh">0x0000000100658948</span> <span class="n">QQSportsV3</span><span class="err">`</span><span class="o">-</span><span class="p">[</span><span class="n">QSMediaPlayerViewController</span> <span class="nl">setPlayerState</span><span class="p">:]</span> <span class="o">+</span> <span class="mi">1280</span>
</span><span class="line"><span class="n">frame</span> <span class="err">#</span><span class="mi">11</span><span class="o">:</span> <span class="mh">0x0000000100659bec</span> <span class="n">QQSportsV3</span><span class="err">`</span><span class="o">-</span><span class="p">[</span><span class="n">QSMediaPlayerViewController</span> <span class="nl">didConsumeEventFromBus</span><span class="p">:]</span> <span class="o">+</span> <span class="mi">3824</span>
</span><span class="line"><span class="n">frame</span> <span class="err">#</span><span class="mi">12</span><span class="o">:</span> <span class="mh">0x0000000100893120</span> <span class="n">QQSportsV3</span><span class="err">`</span><span class="o">-</span><span class="p">[</span><span class="n">QSBusSystem</span> <span class="nl">triggerOtherEvent</span><span class="p">:]</span><span class="n">_block_block</span> <span class="o">+</span> <span class="mi">44</span>
</span><span class="line"><span class="n">frame</span> <span class="err">#</span><span class="mi">13</span><span class="o">:</span> <span class="mh">0x000000010085c858</span> <span class="n">QQSportsV3</span><span class="err">`</span><span class="o">+</span><span class="p">[</span><span class="n">QSSystemUtil</span> <span class="nl">performBlock</span><span class="p">:</span><span class="nl">onRunLoop</span><span class="p">:]</span><span class="n">_block</span> <span class="o">+</span> <span class="mi">40</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>上述堆栈里设置rootVC的时候，传入的就是QSMPAuthenticationViewController，所以是否应该弹出试看的view，应该就在这个函数  ` -[QSMediaPlayerViewController setPlayerState:]`。</p>

<p>用IDA打开这个函数可以看到，state有9个值分别对应不同的<code>switch-case</code>分支：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="objective-c"><span class="line"><span class="n">state</span><span class="o">=</span><span class="mi">0</span><span class="o">/</span><span class="mi">1</span>   <span class="n">QSMPPreviewViewController</span>
</span><span class="line"><span class="n">state</span><span class="o">=</span><span class="mi">2</span>     <span class="n">QSMPWWANConfirmViewController</span>
</span><span class="line"><span class="n">state</span><span class="o">=</span><span class="mi">3</span>     <span class="n">QSMPAuthenticationViewController</span>
</span><span class="line"><span class="n">state</span><span class="o">=</span><span class="mi">4</span>     <span class="n">QSMPAuthenticationResultViewController</span>  <span class="err">会弹出限制只能试看的逻辑</span>
</span><span class="line"><span class="n">state</span><span class="o">=</span><span class="mi">5</span>     <span class="n">QSMPAuthenticationResultViewController</span>  <span class="err">会弹出限制只能试看的逻辑</span>
</span><span class="line"><span class="n">state</span><span class="o">=</span><span class="mi">6</span>     <span class="n">QSMPADViewController</span>
</span><span class="line"><span class="n">state</span><span class="o">=</span><span class="mi">7</span>     <span class="p">[</span><span class="nb">self</span> <span class="n">playerViewControllerWithCurrentPlayerMode</span><span class="p">]</span>
</span><span class="line"><span class="n">state</span><span class="o">=</span><span class="mi">8</span>     <span class="n">QSProjectionControlViewController</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>以勇士某一场比赛为例，需要会员才能看。</p>

<p>进来后state先设置为3，然后请求了一些数据后，设置state为4，弹出了试看限制的view</p>

<p>如果是不需要会员的比赛，则先设置state为6，把广告弹出来，然后广告完了后设置state为7，进行播放比赛。</p>

<p>如果是需要会员才能播放的比赛，则在state=7之后，发送 <code>info.zb.video.qq.com</code>  网络请求去获取直播URL，之后state一直为7.</p>

<p>可以通过hook这个函数，然后对state进行监听，当state=4时，修改其值为6，避开试看逻辑的限制：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class="objective-c"><span class="line"><span class="n">CHMethod</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="kt">void</span><span class="p">,</span> <span class="n">QSMediaPlayerViewController</span><span class="p">,</span> <span class="n">setPlayerState</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">arg1</span><span class="p">){</span>
</span><span class="line">    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;hook到 %@ 函数啦%@，参数 arg1 = %ld&quot;</span><span class="p">,</span> <span class="nb">self</span><span class="p">,</span> <span class="n">NSStringFromSelector</span><span class="p">(</span><span class="n">_cmd</span><span class="p">),</span> <span class="n">arg1</span><span class="p">);</span>
</span><span class="line">    <span class="bp">NSObject</span> <span class="o">*</span><span class="n">object</span> <span class="o">=</span> <span class="nb">self</span><span class="p">;</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">state</span> <span class="o">=</span> <span class="n">arg1</span><span class="p">;</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="n">arg1</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="n">state</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
</span><span class="line">        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;修改state为6&quot;</span><span class="p">);</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">return</span> <span class="n">CHSuper</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">QSMediaPlayerViewController</span><span class="p">,</span> <span class="n">setPlayerState</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>因为广告会自动跳过，所以理论上以上修改后就可以正常播放了，但是实践发现试看的URL拉流时被服务器限制了，试看时间过后就断流。</p>

<p>补充一些其他信息 ：</p>

<p>1.闪屏广告的接口：<code>http://news.l.qq.com/app</code>；</p>

<p>2.直播间广告内容的接口案例：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objective-c"><span class="line"><span class="nl">http</span><span class="p">:</span><span class="c1">//lives.l.qq.com/livemsg?unicomtype=2&amp;newnettype=1&amp;ty=web&amp;defn=hd&amp;ad_type=WL_WK&amp;from=3&amp;vid=100209800&amp;dtype=3&amp;sdtfrom=v3004&amp;live=1&amp;pf=iphone&amp;offline=0&amp;guid=E2CF48156FC246B6A3AB28CFD5115335&amp;pu=1&amp;adaptor=1&amp;v=TADIOSPlayerV1.0&amp;openudid=9da01dcc0f93fea12757814c91074ce440526128&amp;appversion=180911&amp;chid=-1&amp;data=Aejy45%2BNeSZwbpL4wK7%2BCY%2B8ZB%2BzakBg6yuDN6tgzCGupUBraVX4YLCLoIFolnAuCgIePnV34J%2FjX09dPQdSGx2xrnB1tknG92ewRhyw2TpdVNffdS2tgVntHcg%2FcDSmDjrvKiEGRPEOE9KItwzX%2F0xyeJnU2Ap0LZnZKnP7CpNbww77jnM2DC3tvD6X9mCn89P3avg%2FyDbRTsJdWYwIAQsFH%2BaGBIpUTl5ixVCCDHYpDBBFYzTNd10bzeZUiaXfD5T6ZDevRiC0TZryNwN%2FWQVh5ME8lt4fy9UmFAR5UYPHAbI9UWuxAk7kNVeLOe8QaLBM2VslgcTVoGL2vVlXxcxiEqapbM6ZiYjssAlW1sk43zagNNW0K8CtgdBAGBrh5tJ7Y61e9HparuJ0YampHjaLCEnnc9vQ7lEVdQWTFScHyPR9Vfew3F%2FTWg5pJ05j%2BNk%2BsuvjtQ4ikHOt5hpB12JbhGeEghJeUxirpFc5NxEeXvVFV8mI5AO4zg4Bs0i4R52Lx5VvsH%2FODH0wGJAX5P%2B5VJNO4KeE2Qb%2F0bGeaDZ4Qk%2FFEAsRTzDp6E64uBDJgwx%2BHtC3ntqGJ5%2FH3dM6mhh8pPngMHr9J0vTeRAjldnEOG%2BMIQZ99OKqN2lXelrlBRbRXJ%2BxHhZx%2BGKoDdZOJ8T45WF9ZW5x%2Bd6Sgt13SE5jbcofbP3BRTCCbop%2BwEISByPLMpw6i1Lpp4DsC4J7Jg1f0t%2BIcWUNL4QZBXun%2Fu7v7Qoogh%2F%2BmXNniJg0sDXWYuVOjy11HjRCbSCHhZqejORcOISjHekJnnrCSeCrjWpRGrVIsPIGRi7Uz7QM7AG6Rhv3NfVdXdVFl2VPEG1WcYAyiwPFeU4SdNFrFGh3cYPe</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>XML数据格式。有广告的视频连接，包含视频广告内容本身和点击跳转的链接，内容很长，全是广告，去广告也可以考虑hook一下这个接口；</p>

<p>3.NBA比赛的直播链接里，默认的域名前缀通常是<code>http://vzb.tc.qq.com</code>，通常接口会返回4个播放地址，一个是域名，另外几个是IP地址开头对应不同服务器吧。</p>

<p>其中一个直播 链接为：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objective-c"><span class="line"><span class="nl">http</span><span class="p">:</span><span class="c1">//183.61.13.200:8080/zijian.hls.video.qq.com/45E618DD0290B2A1DCB53C6314D7F0C2047F57A531962422E845E8AD9434D7142A3D50B07F5A37E9C67F86926A772DD94486064D5D7B2EB64B44B5740D0749DF9040E406818BAACCBD29D0108A6B28D8B6180AA8BE3BFC52/100209402.m3u8?cdncode=%2f18907E7BE0798990%2f&amp;time=1540006787&amp;cdn=zijian&amp;sdtfrom=v20431&amp;platform=40403&amp;butype=2&amp;scheduleflag=1&amp;buname=qqlive&amp;useblockid=1&amp;vkey=45E618DD0290B2A1DCB53C6314D7F0C2047F57A531962422E845E8AD9434D7142A3D50B07F5A37E9C67F86926A772DD94486064D5D7B2EB64B44B5740D0749DF9040E406818BAACCBD29D0108A6B28D8B6180AA8BE3BFC52</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>前面的没有用域名，而是IP地址，没啥好处理的。其中的一个关键是中间的URL<code>zijian.hls.video.qq.com</code>，抓数据的时候用这个关键字。</p>

<p>上述链接中<code>vkey</code>是必不可少，且跟你当前登录账号绑定。</p>

<p>清晰度不一样主要是通过xxxx.m3u8这个来区分的，往往蓝光的id比超清的数字多1而已，其他清晰度一次递减。比如标清是1001.m3u8，高清是1002.m3u8，超清是1003.m3u8，蓝光则为 1004.m3u8。</p>

<h4 id="section-7">问题备注：</h4>

<p>1.pp助手客服见这里<a href="https://pro.25pp.com/faq_detail/pc5/20305608">https://pro.25pp.com/faq_detail/pc5/20305608</a>，有不懂的可以问客服，包括新版软件怎么下载，有哪些功能等等；</p>

<p>2.最新版的手机pp助手，可以下载腾讯体育的历史版本，但是最新版的pp助手APP，要连着Windows的pp助手才能下载，应用内直接更新是不行的；</p>

<p>3.IPA包安装到手机上后，bundle里有原版所有文件，用一台越狱的手机，可以直接scp全部拷贝到电脑上用，当然越狱版IPA的可执行文件就是砸壳的，正版的就是加密的，可以自己砸壳生成QQSportsV3.decrypted文件，去掉后缀，再chmod 777改下文件权限就OK了；</p>

<p>4.使用LLDB的bt指令来代替Xcode左边栏的可视化堆栈和NSThread的callStackSymbols函数，bt指令比这两者要准确靠谱得多；</p>

<p>5.普通视频播放和直播的方式不太一样，直播可以直接拿到URL到PC播放，视频的应该是腾讯体育有自定义一个协议，只有播放器内部能播，复制到浏览器无法播放，例如:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objective-c"><span class="line"><span class="nl">streaming</span><span class="p">:</span><span class="c1">//127.0.0.1:16697/playmp4?data_id=e22ee22fd2992c4674950&amp;clip_id=1&amp;guid=3F30E560A8A3459DBA410FFEBA7EFAC3</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>6.LLDB打断点的时候可以考虑对<code>-[UIViewController viewDidLoad]</code>打个断点，这样子可以捕获所有的控制器被初始化；如果想知道某个UI页面的按钮被点击后做了啥，也可以对应去打断点；</p>

<p>7.HookZz可以hook <code>objc_msgSend</code>函数，打印所有的函数调用，但是新版的ZzReplace接口需要额外研究下怎么用（知道的麻烦告知一下），而且log太多了需要过滤处理；</p>

<p>8.不要修改腾讯体育的包名，否则播放器无法播放视频和看直播，其他功能正常；</p>

<p>9.HTTPS的握手失败是因为手机没有安装Charles的证书，同一台手机连接不同电脑时，都需要安装这台电脑所对应的Charles证书。</p>

<h4 id="section-8">参考</h4>

<p>1.<a href="https://book.douban.com/subject/26363333/">《iOS应用逆向工程》</a>；</p>

<p>2.<a href="https://book.douban.com/subject/30239776/">《iOS应用逆向与安全》</a>；</p>

<p>3.<a href="http://bbs.iosre.com/t/app-ios/12157">逆向世界杯直播</a><a href="http://bbs.iosre.com/t/app-ios/12157">App</a> <a href="http://bbs.iosre.com/t/app-ios/12157">央视影音</a><a href="http://bbs.iosre.com/t/app-ios/12157">-iOS</a><a href="http://bbs.iosre.com/t/app-ios/12157">客户端</a> 。</p>

<h4 id="nba">声明：本篇文章仅作为学习和研究逆向技术用途，请勿用于商业行为。腾讯体育给球迷们带来了良好的观看NBA比赛的体验，在此表示感谢~</h4>
]]></content>
  </entry>
  
</feed>
